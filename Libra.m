(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



System`GenCoefficientRules::usage="GenCoefficientRules[expr,vars] does the same as CoefficientRules[expr,vars], but applies also to noninteger powers.";


System`GenCoefficient::usage="GenCoefficient[expr,vars, pows] returns coefficient in front of the Times@@(vars^pows).";


System`GenCoefficientRules[expr_,var_]:=System`GenCoefficientRules[expr,{var}];
System`GenCoefficientRules[expr_List,vars_]:=System`GenCoefficientRules[#,vars]&/@expr;
System`GenCoefficientRules[expr_,vars_List]:=Module[
{ps=Table[Unique[],{Length@vars}],expanded,tov,v},
expanded=Expand[expr*Times@@(vars^ps)];
tov=DeleteDuplicates[Cases[expanded,(_.)(Times@@(vars^(Pattern[#,Blank[]]&/@ps))):>Evaluate[Times@@(vars^ps)->v@@ps],All]];
Thread[Last/@tov ->Last/@CoefficientRules[expanded/.tov,Last/@tov]]/.v->List/.Thread[ps->0]
];
System`GenCoefficient[expr_,var_,pow_]:=System`GenCoefficient[expr,{var},{pow}];
System`GenCoefficient[expr_,vars_List,pows_List]:=Module[{ps=Table[Unique[],{Length@vars}],expanded,v},
expanded=ExpandAll[expr*Times@@(vars^ps)];
Coefficient[expanded/.Times@@(vars^Expand[ps+pows]):>v,v]
]


System`PartitionByLengths::usage="PartitionByLengths[list,lengths] splits list into chunks of the given leghts.\nExample:PartitionByLengths[{a,b,c,d,e,f},{3,1,2}] \[LongRightArrow] {{a,b,c},{d},{e,f}}";


System`PartitionByLengths[a_List,b_List]:=Module[{es=Accumulate[b],bs},
bs=Prepend[Most@es+1,1];
Take[a,#]&/@Transpose[{bs,es}]
]


System`ShuffleProduct::usage="ShuffleProduct[l1,l2] implements the shuffle product, e.g., ShuffleProduct[{a,b},{c,d}] \[LongRightArrow] {{a,b,c,d},{a,c,b,d},{a,c,d,b},{c,a,b,d},{c,a,d,b},{c,d,a,b}}.";


System`ShuffleProduct[a_List,b_List]:=Module[{chrs=Join[a,b],nums},nums=Range[Length[chrs]];Join@(Permute[chrs,#])&/@(Join[#,Complement[nums,#]]&/@Subsets[nums,{Length[a]}])]


System`StuffleProduct::usage="StuffleProduct[l1,l2] implements the stuffle product, e.g., StuffleProduct[{a,b},{c,d}] \[LongRightArrow]{{a,b,c,d},{a,b+c,d},{a,c,b,d},{a,c,b+d},{a+c,b,d},{a+c,b+d},{a,c,d,b},{a+c,d,b},{c,a,b,d},{c,a,b+d},{c,a,d,b},{c,a+d,b},{c,d,a,b}}.\nTo replace '+' in the above expression with function f, use the option Function\[Rule]f. E.g. StuffleProduct[{a,b},{c,d},Function\[Rule]f] \[LongRightArrow]{{a,b,c,d},{a,f[b,c],d},{a,c,b,d},{a,c,f[b,d]},{f[a,c],b,d},{f[a,c],f[b,d]},{a,c,d,b},{f[a,c],d,b},{c,a,b,d},{c,a,f[b,d]},{c,a,d,b},{c,f[a,d],b},{c,d,a,b}}.";


Options[System`StuffleProduct]={Function->Plus}


System`StuffleProduct[alist_List,blist_List,OptionsPattern[]]:=Module[{res,ar=Range[Length@alist],br=-Reverse@Range[Length@blist],p,s,l},
res=ShuffleProduct[ar,br];
res=Flatten[Outer[l,Sequence@@(List/@#//.{pre___,{a:Alternatives@@ar},{b:Alternatives@@br},post___}:>{pre,{s[a,b],p[a,b]},post})]&/@res]/.{s->Sequence,l->List}/.Thread[Join[ar,br]->Join[alist,blist]]/.p->OptionValue[Function]
]


BeginPackage["Libra`"]


Print["\!\(\*
StyleBox[\"Libra\",\nFontWeight->\"Bold\"]\) (\:2696) is a package for the manipulation with differential systems.\n\[Copyright] Roman N.Lee 2018.\nRead from: "<>$InputFileName<>"\nMD5: "<>ToString[FileHash[$InputFileName,"MD5"]]];


$LibraUseFermat=False;
If[Not[ValueQ[$LibraTODO]],$LibraTODO=False];
$LibraVersion="1.0\[Beta]";


NewDSystem;


History;HistoryIndex;Undo;Redo;
HistoryAppend;HistoryAddExtra;HistoryDeleteExtra;HistoryConsolidate;
HistoryBurn;


Notations;AddNotation;


EntangledBlocksIndices;DependentRowIndices;DependentColumnIndices;DiagonalBlocksIndices;


DeleteDependentRows;


ODot;OInverse;


Transform;ChangeVar;


TClosure;


Denominators;PolesPosition;PolesInfo;


DiagonalQ;
NilpotentQ;
FuchsianQ;
JFormQ;


JDecomposition;JDecompositionData;


RatFuncQ;PolyQ;


Factors;FactorPlus;FactorListPlus;


LeadingOrder;


SeriesCoefficients;LeadingSeries;LeadingSeriesCoefficient;LeadingSeriesCoefficients;


PoincareRank;


DSystemQ;


Balance;VisBalancing;(*Libra;*)


A0ToSubspaces;A0A1ToSubspaces;GetSubspaces;Projector;


FactorOut;FactorDependence;


GaussSolve;


InvertMod;QuolyMod;OQuolyMod;


DenominatorOrder;


BlockTriangularToFuchsian;


ToOneDE;ToCompanionDS;


BTSolve;


RadicalsUp;


HistoryCheck;HistoryChop;


PexpExpansion;
II;Protect[II];
II::usage="II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x] denotes iterated integral, \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary (with convention II[{},x]=1). II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)] specifies \!\(\*SubscriptBox[\(x\), \(0\)]\). By definition, II[{\!\(\*SubscriptBox[\(x\), \(0\)]\),\[Ellipsis],\!\(\*SubscriptBox[\(x\), \(0\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)]=Log[x-\!\(\*SubscriptBox[\(x\), \(0\)]\)\!\(\*SuperscriptBox[\(]\), \(n\)]\)/n!."


SeriesSolutionData;ConstructSeriesSolution;


SpotCoefficients;


FactorLeadingLetter;FactorTrailingLetter;


Begin["`Private`"]


todolist={};
donelist={};
todo[s_String]:=AppendTo[todolist,s];
done[s_String]:=AppendTo[donelist,s];


History::usage="History[ds] is the central object. It is a list with the elements of the following form:
{M,\"Operation\",extra1\[Rule]\[Ellipsis],\[Ellipsis]}";


HistoryIndex::usage="HistoryIndex[ds] is the current position in the History[ds]";


History::first="Undo can not be done. Already at the beginning.";


History::last="Redo can not be done. Already at the end.";


History::nothing="History change not required.";


HistoryAppend::usage="HistoryAppend[ds,{M,{func,arg1,\[Ellipsis]},extra1\[Rule]\[Ellipsis],\[Ellipsis]}] adds the most recent entry to the history.";


Options[HistoryAppend]={HistoryChop->False};


HistoryAppend::chop="Did not change history to avoid overwriting forward entries. Use HistoryChop[`1`] first."


HistoryAppend[ds_Symbol?DSystemQ,event:{_Association,_List,___},OptionsPattern[]]:=If[
TrueQ[OptionValue[HistoryChop]||Length[History[ds]]<=HistoryIndex[ds]],
Unprotect[ds];History[ds]^=Append[Take[History[ds],HistoryIndex[ds]],event];
HistoryIndex[ds]^=HistoryIndex[ds]+1;Protect[ds];Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]],
Message[HistoryAppend::chop,ds]];


HistoryAddExtra::usage="HistoryAddExtra[ds_Symbol,extra1\[Rule]\[Ellipsis],\[Ellipsis]] adds some optional information to the current history event.";


HistoryAddExtra[ds_Symbol?DSystemQ,rules__Rule]:=(
Unprotect[ds];History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->Join[DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@First/@{rules}->_],{rules}]];
Protect[ds];
Print[Style["Added extra(s) "<>StringRiffle[ToString/@First/@{rules},","]<>" to current history entry.",Small]])


HistoryDeleteExtra::usage="HistoryDeleteExtra[ds_Symbol,extra1,\[Ellipsis]] removes optional information from the current history event.";


HistoryDeleteExtra[ds_Symbol?DSystemQ,extras___]:=(
Unprotect[ds];History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@extras->_]];
Protect[ds];
Print[Style["Added extra(s) "<>StringRiffle[ToString/@extras,","]<>" to current history entry.",Small]])


Undo[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]>n,
Unprotect[ds];Print[Style["History length is "<>ToString[HistoryIndex[ds]^=HistoryIndex[ds]-n]<>".",Small]];
Protect[ds];
History[ds][[HistoryIndex[ds],1]],Message[History::first]];


Undo[ds_?DSystemQ,All]:=(
Unprotect[ds];Print[Style["History length is "<>ToString[HistoryIndex[ds]^=1]<>".",Small]];
Protect[ds];History[ds][[HistoryIndex[ds],1]])


Redo[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]<=Length@History[ds]-n,Unprotect[ds];Print[Style["History length is "<>ToString[HistoryIndex[ds]^=HistoryIndex[ds]+n]<>".",Small]];Protect[ds];History[ds][[HistoryIndex[ds],1]],Message[History::last]];


Redo[ds_?DSystemQ,All]:=(Unprotect[ds];Print[Style["History length is "<>ToString[HistoryIndex[ds]^=Length@History[ds]]<>".",Small]];Protect[ds];History[ds][[HistoryIndex[ds],1]]);


HistoryChop::usage="HistoryChop[ds_] chops off forward entries in history. Use before applying HistoryConsolidate.";


HistoryChop[ds_?DSystemQ]:=(Unprotect[ds];History[ds]^=Take[History[ds],HistoryIndex[ds]];Protect[ds];HistoryIndex[ds])


HistoryConsolidate::usage="HistoryConsolidate[ds] consolidates history";


HistoryConsolidate::err="Undo history entry is met.";
HistoryConsolidate::chop="Did not change history to avoid overwriting forward entries. Use HistoryChop[`1`] first."


Options[HistoryConsolidate]={HistoryChop->False,HistoryAppend->True,
Inverse->True(*whether to calculate inverse transformation matrix*)
};


HistoryConsolidate[ds_?DSystemQ,OptionsPattern[]]:=Module[{T=IdentityMatrix[Length@ds],Ti=IdentityMatrix[Length@ds],i,ii,t,start,end,val,old,new,subs,inv=OptionValue[Inverse]},
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[Take[History[ds],HistoryIndex[ds]],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
old=new=subs=Keys[val];
end=HistoryIndex[ds];
Monitor[Do[
Replace[History[ds][[i,2]],{
{Transform,ds,tt_?SquareMatrixQ}:>(T=ODot[T,tt];If[inv,Ti=ODot[OInverse[tt],Ti]]),
{Transform,ds,tt_?SquareMatrixQ,ii_}:>((*Modified 14.05.2019*)(*(*Deleted 14.05.2019*)t=IdentityMatrix[Length@ds];t[[ii,ii]]=tt;T=ODot[T,t];If[inv,Ti=ODot[OInverse[t],Ti]](*/Deleted 14.05.2019*)*)
(*Added 14.05.2019*)T[[All,ii]]=ODot[T[[All,ii]],tt];If[inv,Ti[[ii]]=ODot[OInverse[tt],Ti[[ii]]]](*/Added 14.05.2019*)
(*/Modified 14.05.2019*)),
{Transform,ds,tt:{_?SquareMatrixQ,_?SquareMatrixQ}}:>(T=ODot[T,tt[[1]]];If[inv,Ti=ODot[tt[[2]],Ti]]),
{Transform,ds,tt:{_?SquareMatrixQ,_?SquareMatrixQ},ii_}:>(
(*Modified 14.05.2019*)(*(*Deleted 14.05.2019*)t=IdentityMatrix[Length@ds];t[[ii,ii]]=tt[[1]];T=ODot[T,t];
If[inv,
t=IdentityMatrix[Length@ds];t[[ii,ii]]=tt[[2]];
Ti=ODot[t,Ti]](*/Deleted 14.05.2019*)*)
(*Added 14.05.2019*)
T[[All,ii]]=ODot[T[[All,ii]],tt[[1]]];
If[inv,
Ti[[ii]]=ODot[tt[[2]],Ti[[ii]]]](*/Added 14.05.2019*)
(*/Modified 14.05.2019*)),
{ChangeVar,ds,tt_,nw_,___}:>(T=Factor[T/.tt];If[inv,Ti=Factor[Ti/.tt]];subs=Factor[subs/.tt];new=nw),
{Factor,ds}:>(T=Factor[T];If[inv,Ti=Factor[Ti]]),
{Simplify,ds,tt___}:>(T=Simplify[T,tt];If[inv,Ti=Simplify[Ti,tt]];subs=Simplify[subs,tt]),
{Map,f_,ds,tt___}:>(T=Map[f,T,tt];If[inv,Ti=Map[f,Ti,tt]];),
{MapAt,f_,ds,tt___}:>(T=MapAt[f,T,tt];If[inv,Ti=MapAt[f,Ti,tt]]),
{Undo,__}:>(Message[HistoryConsolidate::err];Abort[])
}
],
{i,start+1,end}],
Overlay[{ProgressIndicator[i,{start,end}],ToString[i-start]<>"/"<>ToString[end-start]},Alignment->Center]];
If[TrueQ@OptionValue[HistoryAppend],
If[TrueQ@OptionValue[HistoryChop]||Length@History[ds]<=HistoryIndex[ds],
HistoryAppend[ds,{val,{Undo,ds,end-start}}];
ChangeVar[ds,Thread[old->subs],new];
If[inv,
Transform[ds,{T,Ti}],
Transform[ds,T]
],
Message[HistoryConsolidate::chop,ds]
]];
T
]


todo["implement HistoryRewrite"];


HistoryCheck::usage="HistoryCheck[ds_] checks history consistency. It simply redoes all transformations and checks whether the same result is obtained.";


HistoryCheck::inconsistent="History[`1`] is inconsistent at index `2`.";
HistoryCheck[des_]:=Module[
{m,i,hi=HistoryIndex[des],mn,action},
Monitor[
Do[
mn=History[des][[i,1]];
action=History[des][[i,2]]/.des->m;
#1[##2]&@@action;
(*Print[m];Print[mn];*)
If[!TrueQ@(Union[Keys[mn]]===Union[Keys[m[]]]&&(And@@(MatchQ[Factor[mn[#]-m[#]],{{0...}...}]&/@Keys[mn]))),Message[HistoryCheck::inconsistent,des,i];Return[$Failed]];
,{i,hi}],
Overlay[{ProgressIndicator[i,{1,hi}],i},Alignment->Center]
];
Print["History is consistent!"];
]


HistoryBurn::err="Can not burn!";


HistoryBurn::usage="HistoryBurn[ds] "


HistoryBurn[ds_?DSystemQ]:=Module[{T=IdentityMatrix[Length@ds],i,t,start,end,val},
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[History[ds],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
end=HistoryIndex[ds];
If[val=!=History[ds][[1,1]],Message[HistoryBurn::err];Return[$Failed]];
Unprotect[ds];
History[ds]^=Prepend[History[ds][[start+1;;end]],History[ds][[1]]];
HistoryIndex[ds]^=Length@History[ds];
Protect[ds];
]


todo["rethink how HistoryBurn should work"];


NewDSystem::usage="NewDSystem[ds,{x->Mx, y->My,\[Ellipsis]}] defines a new differential system associated with the variable ds.";
NewDSystem::size="Size of the systems mismatch.";
NewDSystem::error="Something went wrong. Aborting...";


Options[NewDSystem]={Print->True};


Notations::usage="Notations[ds] is a list of notations used."


Notations[ds_?DSystemQ]:=Association[];


NewDSystem[ds_,def_Rule,opts:OptionsPattern[]]:=NewDSystem[ds,{def},opts]
NewDSystem[ds_Symbol,defs_Association,opts:OptionsPattern[]]:=NewDSystem[ds,defs/.Association->List,opts]
NewDSystem[ds_Symbol,defs:{(_Symbol->_?SquareMatrixQ)..},opts:OptionsPattern[]]:=Module[{l},
Quiet[Unprotect[ds];Clear[ds]];(*in case ds was defined earlier*)
Check[
History[ds]^={};HistoryIndex[ds]^=0;
DSystemQ[ds]^=True;
Notations[ds]^=Association[];
(*will be used in arguments patterns*)l=Length/@Last/@defs;
If[!(SameQ@@l),Message[NewDSystem::size]];
Length[ds]^=First@l;
HistoryAppend[ds,{Association[defs],{NewDSystem,ds,Association[defs]}}];
(*ToExpression[#<>"$M:=History["<>#<>"][[HistoryIndex["<>#<>"],1]];Protect["<>#<>"$M]"]&[SymbolName[ds]]*),
Message[NewDSystem::error];Abort[];
];
Unprotect[ds];
redefineOperations[ds];
Protect[ds];
If[TrueQ@OptionValue[Print],Print["Successfully created differential system for "<>ToString@Length@ds<>" functions of "<>StringRiffle[ToString/@First/@defs,","]<>"."];
(*Print["Next, you might want to find denominators appearing. See ?Denominators."];*)];
ds::usage="Differential system for "<>ToString@Length@ds<>" functions of "<>StringJoin@@Riffle[ToString/@First/@defs,","]<>".";

]


redefineOperations[ds_Symbol]:=Module[{t1,i,keys,l},
(#[ds,opts___]^:=Function[ds$M,t1=#[ds$M,opts];If[t1===ds$M,Message[History::nothing],HistoryAppend[ds,{t1,{#,ds,opts}}];t1]][History[ds][[HistoryIndex[ds],1]]];)&/@{Factor,Simplify,FullSimplify,Apart,Together};
Variables[ds]^:=Keys[History[ds][[HistoryIndex[ds],1]]];
Protect/@Variables[ds];
ds[x_]:=(History[ds][[HistoryIndex[ds],1]])[x];
ds[]:=ds[[]];
ds/:Part[ds,a___]:=Map[Part[#,a]&,History[ds][[HistoryIndex[ds],1]]];
ds/:Map[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
Monitor[(t1[#]=Map[(i++;#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}]];
HistoryAppend[ds,{t1,{Map[f,#1,##2]&,ds,pars}}]);
ds/:MapAt[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
Monitor[(t1[#]=MapAt[(i++;#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}]];
HistoryAppend[ds,{t1,{MapAt[f,#1,##2]&,ds,pars}}])
]


DSystemQ::usage="DSystemQ[ds] returns True if ds is a differential system.";
DSystemQ[_]=False;


DeleteDependentRows::usage="DeleteDependentRows[{v1,v2,...}] constructs basis in linear span of vectors v1,v2,\[Ellipsis]. Basically, it removes all dependent vectors from the given list.";


DeleteDependentRows[vectors:{__List}]:=Module[{r=0,basis={},rrbasis={}},
Scan[(If[MatrixRank[AppendTo[basis,#]]>r,r++,basis=Most[basis]])&,vectors];basis
]


JDecomposition::usage="JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\)] yields the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result is a list {\!\(\*
StyleBox[\"b\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)} where \!\(\*
StyleBox[\"b\", \"TI\"]\) is a similarity matrix and \!\(\*
StyleBox[\"n\", \"TI\"]\) is the Jordan canonical form of \!\(\*
StyleBox[\"m\", \"TI\"]\). JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"l\", \"TI\"]\)] does the same, except that it puts \!\(\*
StyleBox[\"l\", \"TI\"]\) above diagonal instead of 1.";


JDecomposition[m_?SquareMatrixQ]:=Module[
{s,d,a,b,p,jc,n=Length@m},
Check[{s,a}=JordanDecomposition[m],Return[$Failed]];
s=Factor@s;
a=Simplify@Transform[m,s];
If[!JFormQ[a],Return[$Failed]];
(*Ugly hack to deal with Mathematica's bugs related to JordanDecomposition*)
d=DiagonalMatrix[FoldList[If[#2===0,1,#1/#2]&,1,Diagonal[a,1]]];s=ODot[s,d];a=Simplify@Transform[a,d];
{s,a}
]


JDecompositionData::usage="JDecompositionData[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives data for the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result has a form {{\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\),\!\(\*
StyleBox[\"ulist\", \"TI\"]\),\!\(\*
StyleBox[\"vlist\", \"TI\"]\)},...} where each element corresponds to Jordan cell with the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) , \!\(\*
StyleBox[\"ulist\", \"TI\"]\) being a Jordan chain vectors, starting from the eigenvectors, and \!\(\*
StyleBox[\"vlist\", \"TI\"]\) being the same for transposed matrix. Note that dual bases are \!\(\*
StyleBox[\"ulist\", \"TI\"]\) and Reverse[\!\(\*
StyleBox[\"vlist\", \"TI\"]\)].";


JDecompositionData[m_]:=Module[{
n=Length@m,
t,j,
inds,
sizes,
evals,
us,vs
},
{t,j}=JDecomposition[m];
inds=Flatten[{0,Position[Diagonal[j,1],0,{1}],n}];
sizes=Differences[inds];
Assert[n===Plus@@sizes];
evals=j[[#,#]]&/@Rest[inds];
us=PartitionByLengths[Transpose[t],sizes];
vs=Factor[Reverse/@PartitionByLengths[Inverse[t],sizes]];
(*Outer[ODot,Flatten[vs,1],Flatten[us,1],1](*supposed to be identity matrix*)*)
Transpose[{evals,us,vs}]
]


GaussSolve::usage="GaussSolve[eqs,vars] implements gauss method of the solution of linear equations. Option Continue\[Rule]True|False defines how the procedure proceeds when hitting the equation that can not be satisfied (like 1\[Equal]0). With Continue\[Rule]True such equation is simply neglected, and with Continue\[Rule]False the procedure immediately returns $Failed (i.e., no solution).";


GaussSolve::inconsistent="Inconsistent equation encountered.";


Options[GaussSolve]={Monitor->True,Continue->True};


GaussSolve[eqs_,vars_,OptionsPattern[]]:=Module[{sol1,res,i=0,l=Length@eqs,sf,cnt=TrueQ[OptionValue[Continue]]},
sf=Collect[#,vars,Together]&;
If[TrueQ[OptionValue[Monitor]],Monitor,#1&][
Catch[Fold[
(i++;
Quiet[Check[
{sol1}=Quiet[Solve[0==sf[#2/.#1],vars],{Solve::svars}],
sol1={};If[cnt,Message[GaussSolve::inconsistent],Throw[$Failed]],
{Set::shape}],{Set::shape}];Join[(#1->sf[#2/.sol1])&@@@#1,sol1])&,{},eqs]],
Overlay[{ProgressIndicator[i,{0,l}],ToString[i]<>"/"<>ToString[l]},Alignment->Center]]
]


todo["Implement GaussSolve for matrices. Or at least better version of NullSpace."]


InvertMod::usage="InvertMod[poly1,poly2,x] gives the polynomial invpoly1 such that invpoly1*poly1= 1 (mod poly2).";


InvertMod[poly1_,poly2_,x_]:=Module[{gcd,u,v},{gcd,{u,v}}=PolynomialExtendedGCD[poly1,poly2,x];If[FreeQ[gcd,x],u/gcd,1/0]
]


QuolyMod::usage="QuolyMod[quoly,poly,x] gives the \"remainder\" of the rational function quoly when divided by poly.";


QuolyMod[quoly_List,args__]:=QuolyMod[#,args]&/@quoly;QuolyMod[quoly_,poly_,x_]:=Module[{num,den},
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
Together@PolynomialRemainder[InvertMod[den,poly,x]*num,poly,x]
]


SetAttributes[RadicalsUp,Listable];
RadicalsUp[ex_]:=Module[{den=Denominator[ex],num,denc},
num=den*ex;
denc=(den/.{x:Power[_,1/2]:>-x});
If[denc=!=den,Factor[Expand[num*denc]/Expand[den*denc]],ex]
];


NilpotentQ::usage="NilpotentQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is nilpotent.";
NilpotentQ[m_?SquareMatrixQ]:=Module[{x},Collect[CharacteristicPolynomial[m,x],x,Factor]===(-x)^Length@m]
NilpotentQ[_]=False;


DiagonalQ::usage="DiagonalQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is diagonal.";DiagonalQ[A_?SquareMatrixQ]:=MatchQ[Equal@@@Position[A,Except[0],{2},Heads->False],{True..}];
DiagonalQ[_]=False;


PolyQ::usage="PolyQ[expr,x] gives True if expr is a polynomial function of x.\nPolyQ[{a,b,...},x] gives True iff PolyQ[a,x]&&PolyQ[b,x]&&..=True.";
Module[{p},
PolyQ[expr_,x_]:=Catch[p[expr,x];True];

SetAttributes[p,Listable];
p[ex:(_Plus|_Times),x_]:=p[List@@ex,x];
p[Power[ex_,_Integer?Positive],x_]:=p[ex,x];
p[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


RatFuncQ::usage="RatFuncQ[expr,x] gives True if expr is a rational function of x.\nRatFuncQ[{a,b,...},x] gives True iff RatFuncQ[a,x]&&RatFuncQ[b,x]&&..=True.";
Module[{rf},
RatFuncQ[expr_,x_]:=Catch[rf[expr,x];True];

SetAttributes[rf,Listable];
rf[ex:(_Plus|_Times),x_]:=rf[List@@ex,x];
rf[Power[ex_,_Integer],x_]:=rf[ex,x];
rf[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


JFormQ::usage="JFormQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is a Jordan form.";
JFormQ[{{_}}]=True;
JFormQ[A_?SquareMatrixQ]:=Module[
{
d=Diagonal[A],
c1=DeleteDuplicates[Flatten[{Diagonal[A,#]&/@Range[2,Length@A-1],Diagonal[A,#]&/@Range[1-Length@A,-1]}]]==={0}
},
c1&&And@@(d[[#]]===d[[#+1]]&/@Flatten[Position[Diagonal[A,1],Except[0],{1},Heads->False]])
];
JFormQ[_]=False;


FuchsianQ::usage="FuchsianQ[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) has only simple poles in \!\(\*
StyleBox[\"x\", \"TI\"]\).";FuchsianQ[m_,x_]/;RatFuncQ[m,x]:=MatchQ[PolesInfo[m,x],{{_,_?NonPositive}...}]
FuchsianQ[_]=False;


TClosure::usage="TClosure[m_?MatrixQ] calculates transitive closure of the relation given by m.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";


TClosure[m_?SquareMatrixQ]:=tclosure[m,1]


tclosure::usage="tclosure[m_,d:(1|0):1] calculates transitive closure of the relation given by m. If the second argument is 0, the relation is symmetrized.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";
tclosure[m_,d:(1|0):1,p_:Except[0]]:=Module[{paths,edges,newpaths},
paths={#->#&/@Range[Length@m]};(*vertices*)
edges=Complement[Rule@@@Position[m,p,{2},Heads->False],Join@@paths];
If[d===0,edges=DeleteDuplicates[Join[edges,Reverse/@edges]]];
AppendTo[paths,edges];
edges=Dispatch[edges];
While[{}!=(newpaths=Complement[DeleteDuplicates@Flatten[Thread[#1->ReplaceList[#2,edges]]&@@@Last@paths],Join@@paths]),
AppendTo[paths,newpaths]
];
ReplacePart[ConstantArray[0,Take[Dimensions@m,2]],List@@@Flatten[paths]->1]
]


TClosure[ds_?DSystemQ]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[tc===TClosure,
lc=Transpose[Values[ds[[]]],{3,1,2}];
tc=tclosure[lc,1,Except[{0..}]];
HistoryAddExtra[ds,TClosure->tc],
Print[Style["Read TClosure from extras.",Small]]
];
tc
]


TClosure[as_Association]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
lc=Transpose[Values[ds[[]]],{3,1,2}];
tclosure[lc,1,Except[{0..}]]
]


EntangledBlocksIndices::usage="EntangledBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to lower block-triangular form. The partition indicates separate blocks. The order guarantees that dependent blocks appear earlier.";


EntangledBlocksIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{eb},eb=SortBy[Union[Flatten[Position[#,1,{1}]]&/@If[tc,m,TClosure[m]]],{Last@#,Length@#}&];
Table[Complement@@Reverse[Take[eb,i]],{i,Length@eb}]]


EntangledBlocksIndices[ds_?DSystemQ,tc:(False):False]:=Module[{eb},eb=SortBy[Union[Flatten[Position[#,1,{1}]]&/@TClosure[ds]],{Last@#,Length@#}&];Table[Complement@@Reverse[Take[eb,i]],{i,Length@eb}]]


DiagonalBlocksIndices::usage="DiagonalBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to block-diagonal form. The partition indicates separate diagonal blocks.";


DiagonalBlocksIndices[m_]:=GatherBy[MapIndexed[{#2,Position[#,1,{1}]}&,tclosure[m,0]],Last][[All,All,1,1]]


DependentRowIndices::usage="DependentRowIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent rows";


DependentRowIndices[m_?SquareMatrixQ,rows_,tc:(True|False):False]:=Union@Flatten[Position[#,1,{1}]&/@If[tc,m,TClosure[m]][[Flatten[{rows}]]]]


DependentRowIndices[ds_,rows_,tc:(False):False]:=Union@Flatten[Position[#,1,{1}]&/@TClosure[ds][[Flatten[{rows}]]]]


DependentColumnIndices::usage="DependentColumnIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent columns";


DependentColumnIndices[m_?SquareMatrixQ,args__]:=DependentRowIndices[Transpose[m],args]
DependentColumnIndices[ds_,args__]:=DependentRowIndices[Transpose[TClosure[m]],args]


$LibraUseFermat::error="$LibraUseFermat can be set either to False or to True. The latter case requires Fermatica\` to be in the $ContextPath.";
$LibraUseFermat/:Set[$LibraUseFermat,val_]:=If[(val===False)||(val===True&&MemberQ[$ContextPath,"Fermatica`"]),OwnValues[$LibraUseFermat]={HoldPattern[$LibraUseFermat]:>val};val,Message[$LibraUseFermat::error];$LibraUseFermat];


OQuolyMod::usage="OQuolyMod[quoly,poly,x] gives the \"remainder\" of the rational function quoly when divided by poly. First capital 'O' stands for 'optimized'.";


OQuolyMod[quoly_,rule:_Rule|_RuleDelayed]:=OQuolyMod[quoly,rule[[2]],rule[[1]]]
OQuolyMod[quoly_,poly_,x_Symbol]:=If[$LibraUseFermat,
Replace[CheckAbort[FQuolyMod[quoly,poly,x],$Failed],$Failed:>(Print["OQuolyMod: resorting to Mathematica\[Ellipsis]"];QuolyMod[quoly,poly,x])],
QuolyMod[quoly,poly,x]]


FQuolyMod[exs__]:=Monitor[Fermatica`FQuolyMod[exs],Style["Executing Fermatica`FQuolyMod...",Tiny],1]


ODot::usage="ODot[m1,m2,...] is an optimized dot product."


ODot[exs__]:=If[$LibraUseFermat,
Replace[CheckAbort[FDot[exs],$Failed],$Failed:>(Print["ODot: resorting to Mathematica\[Ellipsis]"];Together@Dot[exs])],
Together@Dot[exs]];


FDot[exs__]:=Monitor[Fermatica`FDot[exs],Style["Executing Fermatica`FDot...",Tiny],1]


OInverse::usage="OInverse[m] is an optimized version of Inverse[m] for block-triangular matrices.";


Options[OInverse]={Print->False};


OInverse[m_,opts:OptionsPattern[]]:=Module[{s=TClosure[m],diag,dep,mi=IdentityMatrix[Length@m],stat=""},
(*invert diagonal*)
If[TrueQ@OptionValue[Print],Monitor,#&][
stat="Finding diagonal blocks\[Ellipsis]";
diag=EntangledBlocksIndices[s,True];
(stat="Inverting diagonal elements with indices "<>ToString[#];
mi[[#,#]]=If[$LibraUseFermat,
Replace[CheckAbort[FInverse[#],$Failed],$Failed:>(Print["Inverse: resorting to Mathematica\[Ellipsis]"];Together[Inverse[#]])],
Together[Inverse[#]]]&@m[[#,#]])&/@diag;
(dep=Complement[DependentRowIndices[s,#,True],#];stat="Inverting off-diagonal elements "<>ToString[dep]<>" on rows "<>ToString[#];mi[[#,dep]]=-ODot[mi[[#,#]],ODot[m[[#,dep]],mi[[dep,dep]]]])&/@diag;
,
stat];
Return[mi]
]


FInverse[ex_]:=Monitor[Fermatica`FInverse[ex],Style["Executing Fermatica`FInverse...",Tiny],1]


Unprotect[Series];
Series[expr_,{x_,x0_,n_Integer}]/;FreeQ[expr,x]:=expr+SeriesData[x,x0,{},n+1,n+1,1]
Series[expr_List,{x_,x0_,n_Integer}]:=Map[Series[#,{x,x0,n}]&,expr]
Protect[Series];
todo["NB: Series redefined!"]


SeriesCoefficients::usage="SeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 up to  (x-x0)^n return the list of these terms";


SeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,series,n},
series=Series[A,{x,x0,k}];
n=LeadingOrder[series,{x,x0}];
SeriesCoefficient[series,{x,x0,#}]&/@Range[n,k]
]


LeadingSeries::usage="LeadingSeries[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeries[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[A+SeriesData[x,x0,{},\[Infinity],\[Infinity],1]]];
Series[A,{x,x0,n+k}]
]
LeadingSeries[A_,{x_Symbol,\[Infinity],k_}]:=Module[
{i,n=LeadingOrder[A,{x,\[Infinity]}]},
If[n==\[Infinity],Return[A+SeriesData[x,\[Infinity],{},\[Infinity],\[Infinity],1]]];
Series[A,{x,\[Infinity],n+k}]
]


LeadingSeriesCoefficient::usage="LeadingSeriesCoefficient[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeriesCoefficient[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[0]];
SeriesCoefficient[A,{x,x0,n+k}]
]


LeadingSeriesCoefficients::usage="LeadingSeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion and return the list of these terms";


LeadingSeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}],series},
If[n==\[Infinity],Return[0]];
series=Series[A,{x,x0,n+k}];
SeriesCoefficient[series,{x,x0,#}]&/@Range[n,n+k]
]


LeadingOrder::usage="LeadingOrder[expr,{x,x0}] gives the leading order of expansion in x.\nLeadingOrder[expr,poly,x] returns the leading order of the polynomial poly whic can be factorised for expr.";


(*Modified 18.05.2019*)(*Added 18.05.2019*)LeadingOrder[expr_List,a__]:=Min[LeadingOrder[#,a]&/@expr](*/Added 18.05.2019*)
LeadingOrder[expr_,x_Symbol(*Added 18.05.2019*),opts:OptionsPattern[](*/Added 18.05.2019*)]:=(*Added 18.05.2019*)lorder[expr,{x,0}](*/Added 18.05.2019*)(*(*Deleted 18.05.2019*)Min[lorder[expr,{x,0}]](*/Deleted 18.05.2019*)*)
LeadingOrder[expr_,{x_Symbol,x0_},opts:OptionsPattern[]]:=(*Added 18.05.2019*)lorder[expr,{x,x0}](*/Added 18.05.2019*)(*(*Deleted 18.05.2019*)Min[lorder[expr,{x,x0}]](*/Deleted 18.05.2019*)*)(*/Modified 18.05.2019*)


(*SetAttributes[lorder,Listable]*)
(*lorder[0,x_Symbol]=\[Infinity];
lorder[expr_,x_Symbol]:=Plus@@Cases[Factors[expr],{x^a_.,n_}\[RuleDelayed]a n]*)
(*(*Deleted 18.05.2019*)lorder[expr_List,x_]:=lorder[#,x]&/@expr;(*/Deleted 18.05.2019*)*)
lorder[0,{x_Symbol,x0_}]=\[Infinity];
lorder[expr_,{x_Symbol,x0_}]:=Plus@@Cases[FactorList[expr/.x->x+x0],{x^a_.,n_}:>a n];
lorder[expr_,{x_Symbol,\[Infinity]}]:=Plus@@Cases[FactorList[expr/.x->1/x],{x^a_.,n_}:>a n];
(*lorder[expr_,{x_Symbol,x0_}]:=Series[expr,{x,x0,-20}][[4]];*)
lorder[expr_SeriesData,{x_Symbol,x0_}]/;MatchQ[Take[List@@expr,2],{x,x0}]:=expr[[4]];


LeadingOrder[expr_,poly_,x_Symbol]:=Module[{n,d},
{n,d}=Through[{Numerator,Denominator}[Together@expr]];
lorder[n,poly,x]-lorder[d,poly,x]
]


lorder[poly1_,poly_,x_Symbol]:=Module[{div=poly1,rem,i=0},
While[({div,rem}=PolynomialQuotientRemainder[div,poly,x];rem===0),
i++];
i]


SeriesSolutionData::usage="SeriesSolutionData[M,{x,x0,n}] constructs data for generalized power series solution of the system \[PartialD]U=M\[InvisibleComma]U.\nGeneralized form: SeriesSolutionData[M,{x,y(x),n}].\n    \[FilledSmallCircle] M should be rational.\n    \[FilledSmallCircle] M should be Fuchsian at x=x0.\n    \[FilledSmallCircle] Residue A at x=x0 should be free of resonances.\n    \[FilledSmallCircle] SeriesSolutionData returns data U with the asymptotics (x-x0)^A.\nReturned data has the form of a list with each element having the form {\[Lambda],\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\),s,{\!\(\*SubscriptBox[\(T\), \(1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]T\), \(s\)]\)}&,C[\[Lambda],0..\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\)]}.";
SeriesSolutionData::notrat="Matrix received is not rational in `1`.";
SeriesSolutionData::ppr="Positive Poincare rank at `1`=`2`.";
SeriesSolutionData::res="Resonant eigenvalues at `1`=`2`.";


ssd[M_?SquareMatrixQ,y_,yv_]:=Module[
{pr,A,T,JF,x2A,p,fp,Q,poles,dens,qs,Bs,\[Lambda],tmp,
Rcoefs,rcoefs,n,Rdata,
statusline=""},
Monitor[
If[!RatFuncQ[M,y],Message[SeriesSolutionData::notrat,yv];Return[$Failed]];
If[(pr=PoincareRank[M,{y,0}])>0,Message[SeriesSolutionData::ppr,yv,0];Return[$Failed]];
A=SeriesCoefficient[M,{y,0,-1}];
statusline="Reducing to Jordan form";
{T,JF}=JDecomposition[A];
fp=p[#[[1,1]],Max[Length/@#]-1]&/@GatherBy[DeleteDuplicates[Map[First,Split[Transpose[{Diagonal[JF],Append[Diagonal[JF,1],0]}],#1[[2]]=!=0&],{2}]],First];
PrintTemporary["Leading expansion terms:\n",Sequence@@(Riffle[TraditionalForm[yv^#1 Log[yv]^#2]&@@@fp,","])];
If[MemberQ[Factor[Subtract@@@Subsets[First/@fp,{2}]],_Integer],Message[SeriesSolutionData::res,yv,0];Return[$Failed]];
(*Now we find common denominator Q, Eq(6) of DESS paper*)
statusline="Getting rid  of denominators";
(*poles=DeleteCases[PolesPosition[M,y],\[Infinity]|0];
Q=Times@@((y-#)^(1+PoincareRank[M,{y,#}])&/@poles);*)
Q=1;
While[{}=!=(dens=Denominators[Together[M Q],_?(FreeQ[#,y]&)]),
Q*=PolynomialLCM[Sequence@@dens,y];
];
Q=Numerator@Together[Q/y];
qs=CoefficientList[Q,y];
Bs=Coefficient[Factor[Q(y M-\[Lambda] IdentityMatrix[Length@M])],y,#]&/@Range[0,Length[qs]-1];
statusline="Evaluating matrix exponent.";
x2A=ODot[ODot[T,(Expand[Expand[Simplify[MatrixExp[JF*Log[y]]]p[0,0]]/.{Log[y]->p[0,1],y->p[1,0]}]//.{p[a_,b_]^c_:>p[a*c,b*c],p[a_,b_]*p[c_,d_]:>p[a+c,b+d]})],OInverse[T]];
statusline="Evaluating recurrence coefficients.";
Rcoefs=Function[{\[Alpha],k},Evaluate@MapThread[bjf[#1,#2*IdentityMatrix[Length@M],k+1]&,{MapIndexed[(#/.{\[Lambda]->\[Alpha]+n-First[#2]+1})&,Bs],-qs},1](*Function[n,]*)];
Rdata=Function[{\[Alpha],k},
statusline="Evaluating recurrence coefficients for power: "<>ToString[\[Alpha]];
rcoefs=Rcoefs[\[Alpha],k](*[n]*);
tmp=OInverse[-rcoefs[[1]]];(*may be improved by dedicated calculation of inverse of bjf with 
off-diagonal terms calculated by iterative multiplication by -A^(-1)B*)
{\[Alpha],k,Length@rcoefs-1(*=s from the paper*),Function@@({ODot[tmp,#]&/@Rest[rcoefs]/.n:>Slot[1]}),Flatten[#!*Coefficient[x2A,p[\[Alpha],#]]&/@Range[0,k],1]}
]@@@fp;
Rdata
,statusline]]


(*Shortcuts*)
SeriesSolutionData[M_?SquareMatrixQ,{x_,\[Infinity]}]:=
Module[{z},ssd[-x^2M/.{x->1/z},z,1/x]];
SeriesSolutionData[M_?SquareMatrixQ,{x_,x0_}]/;FreeQ[x0,x]:=
Module[{z},ssd[M/.{x->z+x0},z,x-x0]]; 
SeriesSolutionData[M_?SquareMatrixQ,{x_,y_}]:=
Module[{z,xvar},xvar=x/.First[Solve[z==y,x]];ssd[M D[xvar,z]/.{x->xvar},z,y]];


ConstructSeriesSolution::usage="ConstructSeriesSolution[rdata_,{x_,o_}] makes a series solution out of rdata (see ?SeriesSolutionData for how to get rdata).\n    o \[LongDash] order in x.\nIf f=ConstructSeriesSolution[SeriesSolutionData[M,{x,0}],{x,o}], then one may check the equation by Factor[D[y,x]-M.y].\nOptions:\n    O\[Rule]True|False:False \[LongDash] whether to add O[x]^o\n    Split\[Rule]True|False:False determines whether to split contribution of different fractional powers.\n    Hold->f|False:False -- whether to wrap the leading powers. If f\[NotEqual]False is given, f[lp] is used instead of \!\(\*SuperscriptBox[\(x\), \(lp\)]\).\nSince Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended. If option Split\[Rule]True is used,  ConstructSeriesSolution returns the result as a rectangular matrix n\[Times](n*|S|), with each square n\[Times]n block corresponding to a specific fractional power.";
ConstructSeriesSolution::mixed="Since Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended.";


Options[ConstructSeriesSolution]={O->False,Split->False,Simplify->Factor};


ConstructSeriesSolution[rdata_,{x_,o_}, OptionsPattern[]]:=Module[{c,n,sdata,sf=OptionValue[Simplify],Oo=TrueQ@OptionValue[O],So=TrueQ@OptionValue[Split](*,Ho=If[TrueQ@!OptionValue[Hold],x^#&,OptionValue[Hold]]*)},
If[Oo&&!So,Message[ConstructSeriesSolution::mixed]];
Oo=If[Oo,x^o O[x],0];
sdata=(Function[{lp,llp,M,coefs,init},
c[lp,0]=init;c[lp,n_Integer?Positive]:=(Quiet[Unset[c[n-M-1]]];(*clean up*)
c[lp,n]=sf@Sum[Dot[coefs[n][[m]],c[lp,n-m]],{m,Min[M,n]}]);
x^lp*(Dot[((Log[x]^#/#!)&/@Range[0,llp]),(Partition[#,Length@#/(llp+1)]&[Sum[c[lp,n]*x^n,{n,0,o}]])]+Oo)
]@@@rdata);
If[So,ArrayFlatten[{sdata}],Plus@@sdata]
]


PexpExpansion::usage="PexpExpansion[{M,n},x] gives the perturbative expansion of the \!\(\*FormBox[\(Pexp[\[Integral]dx\\\ M]\),
TraditionalForm]\) in \!\(\*FormBox[\(M\),
TraditionalForm]\) up to the term \!\(\*FormBox[\(\(\[Proportional]\)\*SuperscriptBox[\(M\), \(n\)]\),
TraditionalForm]\) via the iterated integrals \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary. The result is the list of successive terms."


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
Monitor[
res=NestList[Function[pr,i++;t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x]:>II[{#,a},x]})&/@p)],IdentityMatrix[Length@M]*II[{},x],n],
i]
]


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol,x0_]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
Monitor[
res=NestList[Function[pr,i++;t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x,x0]:>II[{#,a},x,x0]})&/@p)],IdentityMatrix[Length@M]*II[{},x,x0],n],
i]
]


InsertionPositions[m_Integer,n_Integer]:=Module[{ss,range},
range=Range[n]-1;
#-range&/@Subsets[Range[m+n],{n}]
]
ShuffleProductNestList[l_,list_List,n_Integer]:=Module[{len=Length@list,k},
Table[Insert[list,l,List/@#]&/@InsertionPositions[len,k],{k,0,n}]
]


todo["InsertionPositions can probably be written in C"];


FactorLeadingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{ls:(l)..,b1:Except[l],bs___},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Prepend[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{(l)..,Except[l],___},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


FactorTrailingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{bs___,b1:Except[l],ls:(l)..},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Append[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{___,Except[l],(l)..},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


SpotCoefficients::usage="SpotCoefficients[Mf,T,\[Epsilon],{x,y(x),o}] tries to find the coefficients in the asymptotic expansion of the initial integrals which are sufficient for fixing boundary conditions. The output is a list with each element being of the form {y(x),i,\[Alpha],k}. It stands for the coefficient \!\(\*SuperscriptBox[\(y\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(ln\), \(k\)]\)y in i-th integral.";
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]/;FreeQ[y,x]:=SpotCoefficients[Mf,T,\[Epsilon],{x,y,o}]
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]:=Module[{rdata,TUr,z,zrule,ii,p,powers,tmp,cs=ConstantArray[0,Length@Mf]},
zrule=First[Solve[z==y,x]];
Monitor[
MapIndexed[(ii=#;rdata=SeriesSolutionData[Factor[Mf[[ii,ii]]],{x,y}];TUr=(Plus@@Partition[#1,Length[ii]]&)/@Map[Collect[Expand[#1 p[0,0]]/. {Log[z]->p[0,1],z->p[1,0]}//. {p[a_,b_]^c_:>p[a c,b c],p[a_,b_] p[c_,d_]:>p[a+c,b+d]},_p,Factor]&,Normal[(T[[ii,ii]]/. zrule).ConstructSeriesSolution[rdata,{z,o},Split->True,O->True]],{2}];powers={};tmp={};MapIndexed[Function[{row,i},Module[{ps=SortBy[Union[Cases[row,_p,All]],First[#/.\[Epsilon]->0]&]},Catch[((tmp=Append[tmp,Factor[Coefficient[row,#1]]];If[MatrixRank[tmp]>=First[i],AppendTo[powers,#1];Throw[0]];tmp=Most[tmp])&)/@ps;
Print["Could not find suitable coefficients for block ",ii," Aborting..."];
Abort[]]]],TUr];cs[[ii]]=MapIndexed[{y,ii[[First[#2]]],Sequence@@#1}&,powers];
)&,EntangledBlocksIndices[TClosure[Mf]+TClosure[T]]],
ii];
cs
]


ToOneDE::usage="ToOneDE[M,x,i] constructs one higher-order differential equation for the i-th master.\nIt returns the list of the coefficients {Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]} in front of the consecutive orders of derivatives, so that the equation has the form Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0.";


ToOneDE[M_,x_,i_:1]:=Module[
{ders,Mk=IdentityMatrix[Length@M]},
ders={Mk[[i]]};
While[MatrixRank[ders]==Length@ders,
PrintTemporary[Length@ders];
(*Add one more row*)
Mk=Factor[D[Mk,x]+Mk.M];
AppendTo[ders,Mk[[i]]];
];
First[NullSpace[Transpose[ders]]]
]


ToCompanionDS::usage="ToCompanionDS[{Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]}] constructs the companion matrix Subscript[M, c] out of the coefficients of differential equation Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0. This matrix enters the right-hand side of the differential system \!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]F\)=Subscript[M, c]F, where F=(f,f',\[Ellipsis],f^(n))^T.";


ToCompanionDS[coefs_List]:=Append[Rest@IdentityMatrix[Length@coefs-1],Factor[Most[coefs]/-Last[coefs]]]


done["Transform: add support for notations."]


Transform::usage="Transform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\).\nTransform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].(\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\)-D[\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]).\nTransform[\!\(\*
StyleBox[\"ds\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\)] transforms the differential system.";


Options[Transform]={Simplify->Factor};


Transform::notinv="The two matrices are not reciprocal to each other. Aborting...";
Transform::range="Something wrong with application range `1`. Aborting...";


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,OptionsPattern[]]:=Module[{ti=OInverse@t},
transform[m,t,ti]
];
Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False},OptionsPattern[]]:=If[checked||Factor[ti.t]===IdentityMatrix[Length@t],
transform[m,t,ti],
Message[Transform::notinv];Abort[]];



transform[m_,t_,ti_]:=ODot[ti,ODot[m,t]];
transform[m_,t_,ti_,x_]:=ODot[ti,ODot[m,t]-D[t,x]];
transform[m_,t_,ti_,x_,{}]:=ODot[ti,ODot[m,t]-D[t,x]];


transform[m_,t_,ti_,x_,notas:{__Rule}]:=Internal`InheritedBlock[{D},SetOptions[D,NonConstants->First/@notas];ODot[ti,ODot[m,t]-(D[t,x]/.First[Solve[0==D[Last/@notas,x],D[First/@notas,x]]])]]


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],notas:_Association|{___Rule}:{}]:=Transform[m,{t,OInverse@t,True},x,i,notas];
Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False},x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],notas:_Association|{___Rule}:{}]:=Module[{mt},If[checked||ODot[ti,t]===IdentityMatrix[Length@t],
mt=transformrange[m,t,ti,x,i,notas/.Association->List];
If[notas=!={},
mt=Fold[OQuolyMod,mt,notas/.Association->List]
];
mt,
Message[Transform::notinv];Abort[]]
];


transformrange[m_,t_,ti_,x_,Span[1,All],notas:{___Rule}:{}]:=transform[m,t,ti,x,notas];
transformrange[m_,t_,ti_,x_,i_,notas:{___Rule}:{}]:=Module[{mt=m,jj,ii,l=Length@m},
ii=Replace[i,{Span[a_Integer,b_Integer]:>Range[Mod[a+l+1,l+1],Mod[b+l+1,l+1]],Span[a_Integer,All]:>Range[Mod[a+l+1,l+1],Length@m]}];
If[Not[MatchQ[ii,{(_Integer?(1<=#<= l&))..}]],Message[Transform::range,i];Abort[]];
mt[[ii,ii]]=transform[m[[ii,ii]],t,ti,x,notas];
jj=Complement[DependentColumnIndices[m,ii],ii];
If[jj=!={},mt[[jj,ii]]=ODot[mt[[jj,ii]],t]];
jj=Complement[DependentRowIndices[m,ii],ii];
If[jj=!={},mt[[ii,jj]]=ODot[ti,mt[[ii,jj]]]];
mt
];


Transform[as_Association,t_,ii:{__Integer}|Span[_,_]:Span[1,All],notas:_Association|{___Rule}:{}]:=Module[{m=as},
(m[#]=Transform[m[#],t,#,ii,notas])&/@Keys[m];
m
]


Transform[ds_?DSystemQ,t_,i:{__Integer}|Span[_,_]:Span[1,All]]:=Module[{m=ds[[]]},
Check[(m[#]=Transform[m[#],t,#,i,Notations[ds]])&/@Keys[m],Return[$Failed]];
HistoryAppend[ds,{m,{Transform,ds,t,i}}];
m
]


ChangeVar::usage="ChangeVar[ds,{rules},{vars}] changes variable in the matrix.";


ChangeVar[m_?SquareMatrixQ,x_->xviay_,y_Symbol]:=Factor[m D[xviay,y]/.x->xviay]


ChangeVar[ds_?DSystemQ,rs1:_Rule|{__Rule},ys1:_Symbol|_List]:=Module[{keys=Keys[ds[[]]],M,rs=Flatten[{rs1}],ys=Flatten[{ys1}],nkeys=Keys[Notations[ds]]},
M=Association@@(Function[y,y->Plus@@((D[#1/.rs,y]ds[#1]/.rs)&/@keys)]/@ys);
Unprotect[ds];
Notations[ds]^=Numerator@Together[Notations[ds]/.rs];
Protect[ds];
HistoryAppend[ds,{M,{ChangeVar,ds,rs,ys}}];
Protect/@ys;
ds[[]]
]


AddNotation::usage="AddNotation[ds,y\[Rule]P(x,y)] adds notation y connected with x via P(x,y)=0.";


AddNotation[ds_?DSystemQ,y_Symbol->p_]:=Module[{keys=Keys[ds[]],M,nots=Notations[ds]},
If[FreeQ[p,y],Message[AddNotation::wrng];Return[$Failed]];
nots[y]=p;
Unprotect[ds];
Notations[ds]^=nots;
Protect[ds];
HistoryAppend[ds,{ds[],{AddNotation,ds,y->p}}];
Protect[y];
ds[[]]
]


A0ToSubspaces::usage="A0ToSubspaces[A0,\[Epsilon]\[Rule]0,Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances with positive gains.\nWhen called with option All\[Rule]True, it returns all subspaces.";


Options[A0ToSubspaces]={All->False};


A0ToSubspaces[A0_?SquareMatrixQ,rules_,side:(Left|Right):Left,OptionsPattern[]]:=Module[{l=Length@A0,jdata,sel=Select},
jdata={Factor[#1]/.rules,##2}&@@@JDecompositionData@A0;
(*Pick suitable evs*)
If[TrueQ[OptionValue[All]],sel=#&];
If[side===Right,
SortBy[sel[jdata,TrueQ[Positive[First@#]]&],-First[#]&][[All,3]],
SortBy[sel[jdata,TrueQ[Negative[First@#]]&],First][[All,2]]
]
]


A0A1ToSubspaces::usage="A0A1ToSubspaces[{A0,A1},Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances.";


A0A1ToSubspaces[{A0_?SquareMatrixQ,A1_?SquareMatrixQ},side:(Left|Right):Left]/;Length@A0==Length@A1:=Module[{l=Length@A1,\[Lambda],ns,A},
A=ArrayFlatten[{{A0,A1-\[Lambda]*IdentityMatrix[l]},{0,A0}}];
If[side===Left,A=Take[#,-l]&/@ker[A],A=Take[#,l]&/@ker[Transpose@A]];
(*Get rid of denominators*)
ns=Collect[Cancel[PolynomialLCM@@Denominator[#]*#],\[Lambda],Factor]&/@Factor@DeleteCases[A,{0..}];
ns=SortBy[DeleteDuplicates[DeleteCases[RowReduce[FixedPointList[D[#,\[Lambda]]&,#]/.\[Lambda]->0],{0..}]&/@ns],Length];
(*If[side===Left,Transpose/@ns,ns]*)ns
]


todo["improve A0A1ToSubspaces \[LongDash] calculate Groebner basis of \!\(\*SubscriptBox[\(u\), \(1\)]\)(\[Lambda]),\[Ellipsis],\!\(\*SubscriptBox[\(u\), \(k\)]\)(\[Lambda])."];


GetSubspaces::usage="GetSubspaces[\!\(\*
StyleBox[\"m\", \"TI\"]\),{x,\!\(\*SubscriptBox[\(x\), \(0\)]\)},\[Epsilon],Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances with positive gains.\nWhen called with option All\[Rule]True, it returns all subspaces."


Options[GetSubspaces]={All->False}


GetSubspaces[m_?DSystemQ,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]
GetSubspaces[m_Association,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]


GetSubspaces[m_?SquareMatrixQ,{x_,x0_},\[Epsilon]_,side:(Left|Right):Left,OptionsPattern[]]:=Module[
{r,s,o,ser,m0,m1,status=""},
Monitor[
status="Evaluating Poincare rank...";
r=PoincareRank[m,{x,x0}];
PrintTemporary["Poincare rank: "<>ToString[r]];
status="Evaluating expansion";
s=2Boole[x0===\[Infinity]]-1;
o=s-r;(*leading order of expansion*)
If[r>0,
If[TrueQ@OptionValue[All],
(*Just return all subspaces*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
Return[A0ToSubspaces[m0,\[Epsilon]->0,side,All->True]],
(*return Barkatou subspaces*)
ser=-s*Series[m,{x,x0,o+1}];
m0=SeriesCoefficient[ser,{x,x0,o}];
m1=SeriesCoefficient[ser,{x,x0,o+1}];
status="Evaluating subspaces";
Return[A0A1ToSubspaces[{m0,m1},side]]
],
(*Fuchsian singularity*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
Return[A0ToSubspaces[m0,\[Epsilon]->0,side,All->OptionValue[All]]]
]
,status
]
]


Projector::usage="Projector[image,coimage] constructs projector with prescribed image and coimage.";


Projector[u_,v_]:=Module[{ut=Transpose@u},Check[ODot[ut,Inverse@Dot[v,ut],v],ConstantArray[0,{Length@First[v],Length@ut}]]]


Balance::usage="A balance transformation matrix. Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)\!\(\*FractionBox[\(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"2\"]\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\[Infinity]}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)\!\(\*FractionBox[\(1\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), and Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\[Infinity],\!\(\*SubscriptBox[\(x\), \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)(\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\))\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\). The constant \!\(\*
StyleBox[\"c\", \"TI\"]\) is defined from the condition \!\(\*SuperscriptBox[
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"], \(2\)]\)=\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\).";


Balance::notprojector="Warning: `1` is not a projector. Returning identity matrix";


Balance[p_,{x_,x1_,\[Infinity]}]:=Module[{cs=Table[Unique[],Evaluate[Sequence@@List/@Dimensions[p]]],pcs,c},
pcs=Plus@@Flatten[cs*p];If[pcs===0,Return[IdentityMatrix@Length@p]];
c=Factor[Plus@@Flatten[cs*ODot[p,p]]/pcs];
If[Not[FreeQ[c,Alternatives@@cs]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];
Return[Factor[IdentityMatrix@Length@p-p/c]+p 1/(x-x1)]
]


Balance[p_,{x_,\[Infinity],x2_}]:=Module[{cs=Table[Unique[],Evaluate[Sequence@@List/@Dimensions[p]]],pcs,c},
pcs=Plus@@Flatten[cs*p];If[pcs===0,Return[IdentityMatrix@Length@p]];
c=Factor[Plus@@Flatten[cs*ODot[p,p]]/pcs];
If[Not[FreeQ[c,Alternatives@@cs]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];
Return[Factor[IdentityMatrix@Length@p-p/c]+p (x-x2)]
]


Balance[p_,{x_,x1_,x2_}]:=Module[{cs=Table[Unique[],Evaluate[Sequence@@List/@Dimensions[p]]],pcs,c},
pcs=Plus@@Flatten[cs*p];If[pcs===0,Return[IdentityMatrix@Length@p]];
c=Factor[Plus@@Flatten[cs*ODot[p,p]]/pcs];
If[Not[FreeQ[c,Alternatives@@cs]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];
Return[Factor[IdentityMatrix@Length@p-p/c]+p (x-x2)/(x-x1)]
]


VisBalancing::usage="VisBalancing[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is a visual tool for the balancing.";


VisBalancing[ds_,{x_Symbol,poles_},\[Epsilon]_Symbol:Indeterminate]:=VisBalancing[ds[x],x,\[Epsilon],poles]


VisBalancing[ds_?DSystemQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[ds[x],x,\[Epsilon],poles];


VisBalancing[as_Association,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[as[x],x,\[Epsilon],poles];


VisBalancing[matr_?SquareMatrixQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=Module[
(*
Basic idea: first, find JDecompositionData for all points of the matrix.
Then construct a graphics control
*)
{ttt,
n=Length@matr,
m=matr,
polesData,
indices,index,
prevu,prevv,
psetu,psetv,
clickedu,clickedv,
buttons=Grid[{{"Wait"}}],
us,vs,x1,x2,
lu,lv,
gram,goodBalance,colorMark,
statusline="Ready",balance,
transformation,
updateInteface,
apply,
validate
},
transformation=IdentityMatrix[n];
(*Calculate poles*)
updateInteface=(
(*forming polesData and indices*)
polesData=If[poles===All,PolesInfo[m,x],DeleteCases[{#,PoincareRank[m,{x,#}]}&/@poles,{_,_?Negative}]];
polesData=
({#1,#2,JDecompositionData@If[#1=!=\[Infinity],SeriesCoefficient[m,{x,#1,-1-#2}],-SeriesCoefficient[m,{x,#1,1-#2}]],If[#2>0,Prepend[#,"M"]&/@Transpose[{(*Transpose/@*)Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Left],Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Right]}],{}]}&@@@polesData);
indices={};
Do[
Do[
AppendTo[indices,{i1,i2,{i3},i3==1||prevu(*"allowed to press?" flag*),prevu=Unique["p"](*"pressed?" flag*),i3==1||prevv,prevv=Unique["p"]}],{i2,Length@polesData[[i1,3]]},{i3,Length@polesData[[i1,3,i2,-1]]}
];
Do[
AppendTo[indices,{i1,Length@polesData[[i1,3]]+i2,All,True,Unique["p"],True,Unique["p"]}],{i2,Length@polesData[[i1,4]]}
]
,{i1,Length@polesData}];
polesData={#1,#2,Join[#3,#4]}&@@@polesData;
(*/forming polesData and indices*)
(*functions to set variables*)
psetu=Function[v,(v=#)&]/@indices[[All,5]];psetv=Function[v,(v=#)&]/@indices[[All,7]];
(*
write 
psetu[[i]][True] and psetv[[i]][True] *)(*
for the naive effect of 
indices[[i,5]]=True and indices[[i,7]]=True 
*)
(*/functions to set variables*)
(*forming interface*)
buttons=Grid[{
{
Grid[ArrayFlatten[{{
PadRight[Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedu[#1,#2,#3],Enabled->Dynamic[#4],Appearance->Dynamic[If[#5,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
],
{If[#2>0,Style,#&][Row[{"   ",x,"=",#1,", pr=",#2,"   "}],Bold]}&@@@polesData[[All,{1,2}]],
PadLeft[Reverse/@Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedv[#1,#2,#3],Enabled->Dynamic[#6],Appearance->Dynamic[If[#7,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
]
}}],Spacings->0,ItemSize->All,Alignment->Center]
},{
Button["Apply balance transformation",apply[],Enabled->Dynamic[goodBalance],Background->Dynamic[colorMark]]
},
{
Button["Paste overall transformation",DialogReturn[transformation]]
},
{
Dynamic[statusline]
}
},Alignment->Center];
(*/forming interface*)
(*unsetting buttons*)
Through[psetu[False]];
Through[psetv[False]];
(*/unsetting buttons*)
validate[];
)&;
apply=(
(*apply transformation*)
balance=Balance[Projector[(*Transpose@*)us,vs],{x,x1,x2}];
statusline="balance constructed";
PrintTemporary[statusline];
m=Transform[m,balance,x];
statusline="transformation applied";
PrintTemporary[statusline];
(**)
transformation=ODot[transformation,balance];
statusline="overall transformation calculated";
PrintTemporary[statusline];
updateInteface[];
)&;
validate=(
(*pick right and left vectors*)
us=vs={};
(
If[#5,us=Join[us,polesData[[#1,3,#2,2,#3]]];x1=polesData[[#1,1]]];If[#7,vs=Join[vs,polesData[[#1,3,#2,3,#3]]];x2=polesData[[#1,1]]])&@@@indices;
gram=Outer[ODot,us,vs,1];
lu=Length@us;lv=Length@vs;
goodBalance=(lu+lv>0&&lu==lv&&lv==MatrixRank[gram]);
colorMark=If[lu==0||lv==0||MatrixRank[gram]==lu,If[goodBalance,Green,Automatic],Red];
statusline=ToString[lu]<>"-dimensional u-space and "<>ToString[lv]<>"-dimensional v-space";
)&;

clickedu=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,5]],
psetu[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetu[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,__} ,{1}]];
psetu[[index]][True];
];
validate[];
)&;
clickedv=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,7]],
psetv[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetv[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,__},{1}]];
psetv[[index]][True];
];
validate[];
)&;
updateInteface[];
DialogInput[Dynamic[buttons(*Refresh[buttons,UpdateInterval\[Rule]1]*)]]
]


todo["VisBalancing: block simultaneus pressing buttons for nonzero Poincare rank singularities"]
todo["VisBalancing: for simple poles allow same-line pressing on left and right"]


FactorOut::usage="FactorOut[m,x,\[Epsilon],\[Mu]] returns a transformation which reduces m to a factorized form.";


FactorOut::notfuchsian="Not Fuchsian matrix...";
FactorOut::notnormalized="Eigenvalues of the matrix residues are not normalized...";
Options[FactorOut]={DependentRowIndices->Automatic,Solve->True};


FactorOut[ds_?DSystemQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[ds[x],x,\[Epsilon],\[Mu],opts];
FactorOut[as_Association,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[as[x],x,\[Epsilon],\[Mu],opts];


FactorOut[m_?SquareMatrixQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=Module[
{n=Length@m,mres,t,vars,eqs,sol,ms},
If[!FuchsianQ[m,x],Message[FactorOut::notfuchsian];Return[$Failed]];ms=Replace[OptionValue[DependentRowIndices],Automatic->TClosure[m]];
mres=LeadingSeriesCoefficient[m/\[Epsilon],{x,#1,0}]&@@@PolesInfo[m,x];
FactorDependence[mres,\[Epsilon],\[Mu],Sequence@@FilterRules[#->OptionValue[#]&@@@Options[FactorOut],Options[FactorDependence]]]
]


todo["rewrite FactorOut in the spirit of SimplifyFuchsian"];


FactorDependence::usage="FactorDependence[{m1,m2,\[Ellipsis]},\[Epsilon],\[Mu]] returns a transformation which reduces m1,m2,... to \[Epsilon]\[LongDash]independent matrices.";


Options[FactorDependence]={DependentRowIndices->Automatic,Solve->True};
FactorDependence[m:{__?SquareMatrixQ},\[Epsilon]_,\[Mu]_,OptionsPattern[]]:=Module[
{n=Length[First@m],t,vars,eqs,sol,ms},
ms=Replace[OptionValue[DependentRowIndices],Automatic->tclosure[Transpose[m,{3,1,2}],1,Except[{0..}]]];
(*insert here check for normalization*)
t=ConstantArray[0,{n,n}];
vars=(t[[##]]=Unique["t"])&@@@Flatten[Outer[List,{#},DependentRowIndices[ms,{#}]]&/@Range[n],2];
eqs=SortBy[Flatten[(Dot[#,t]-Dot[t,#/.\[Epsilon]->\[Mu]])&/@m],ByteCount];If[!OptionValue[Solve],Print["Returning a pair {eqs,t}. To find the transformation one should solve eqs\[Equal]0 with respect to Variables[t] and substitute the solution to t."];Return[{eqs,t}]];
Quiet[sol=GaussSolve[eqs,vars]];
t/.sol/.MapIndexed[#->C@@#2&,Complement[vars,First/@sol]]
]


todo[" implement FactorOut and FactorDependence using Fermat and TGaussSolve"];


BlockTriangularToFuchsian::usage="BlockTriangularToFuchsian[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gets rid of multiple poles in off-diagonal elements.\nBlockTriangularToFuchsian[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)] gets rid of multiple poles in off-diagonal elements for points \!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\) only. Each \!\(\*
StyleBox[SubscriptBox[\"p\", \"i\"], \"TI\"]\) is either a point \!\(\*
StyleBox[\"p\", \"TI\"]\) or a pair {\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"r\", \"TI\"]\)}, where \!\(\*
StyleBox[\"r\", \"TI\"]\) is a Poincare rank.";


Options[BlockTriangularToFuchsian]={
Simplify->False(*whether to simplify simple poles*)
(*,Check\[Rule]True(*whether to check if diagonal blocks are fuchsian*)*)
};


BlockTriangularToFuchsian[ds_?DSystemQ,x_,p:(_List|All):All,opts:OptionsPattern[]]:=
BlockTriangularToFuchsian[ds[x],x,p,opts];


BlockTriangularToFuchsian[as_Association,x_,p:(_List|All):All,opts:OptionsPattern[]]:=
BlockTriangularToFuchsian[as[x],x,p,opts];


BlockTriangularToFuchsian::blocks="Diagonal blocks are not Fuchsian...";
BlockTriangularToFuchsian[matr_,x_,p:(_List|All):All,OptionsPattern[]]:=Module[
{
n=Length@matr,order,
m=matr,mt,i1,i2,
ind1,ind2,t,o,vars,sol,
transform,c,
poles,oc=Boole[Not[TrueQ@OptionValue[Simplify]]],
blocks=EntangledBlocksIndices[matr]
},
(*Modified 18.05.2019*)poles=Reverse@DeleteCases[Replace[p,{All:>PolesInfo[matr,x],_:>Replace[p,{z_List:>z,z_:>{z,PoincareRank[matr,{x,z}]}},{1}]}],{_,_?Negative}](*/Modified 18.05.2019*);
transform=IdentityMatrix[n];
If[poles=={},Return[transform]];
(*(*Deleted 09.02.2018*)If[OptionValue[Check],If[!And@@(FuchsianQ[m[[#,#]],x]&/@blocks),Message[BlockTriangularToFuchsian::blocks]];Return[IdentityMatrix[n]]];(*/Deleted 09.02.2018*)*)
Function[{x0},
(*Cycle over blocks.*)
Monitor[
Do[
(*First, generate matrix*)
i2="?";
c=ConstantArray[0,{n,n}];
ind1=Flatten[blocks[[i1]]];ind2=Flatten[blocks[[1;;(i1-1)]]];
vars=Table[Unique["c"],{Length@ind1},{Length@ind2}];
c[[ind1,ind2]]=vars;
vars=Flatten@vars;
(*matrix generated*)
order=PoincareRank[m[[ind1,ind2]],{x,x0}];
(*Now cycle over pole order*)
Unset[i2];
Do[
If[x0=!=\[Infinity],
t=IdentityMatrix[n]+c/(x-x0)^i2;o=-1,
t=IdentityMatrix[n]+c*(x)^i2;o=1];
mt=Transform[m,t,x];(*TODO: here Fermat should not be used*)
Quiet[Check[sol=GaussSolve[If[i2>0,SortBy,#1&][Flatten[SeriesCoefficient[mt[[ind1,ind2]],{x,x0,o-i2}]],ByteCount],vars],If[i2>0,Print["Problem"]];Continue[],{GaussSolve::inconsistent}],{GaussSolve::inconsistent}];
m=Factor[mt/.sol/.Thread[Flatten@c->0]];
transform=ODot[transform,(t/.sol/.Thread[Flatten@c->0])];
,{i2,order,oc,-1}]
,{i1,2,Length@blocks}],
Row[{x0,":",i1,"\[LeftArrow]",i2}]]
]/@First/@poles;
Return[transform];
]


todo["BlockTriangularToFuchsian, option Simplify\[Rule]True seems to be broken"];


todo["BlockTriangularToFuchsian, treat Notations."];


BTSolve::usage="BTSolve[{A,B,C}] returns matrix D which is the solution of the equation D+AD-DC+B=0.";


BTSolve[{A_?SquareMatrixQ,B_?MatrixQ,C_?SquareMatrixQ}]:=Module[{n=Length@A,m=Length@C,T},
If[Dimensions[B]=!={n,m},Abort[]];
T=IdentityMatrix[n*m]+ArrayFlatten[Outer[Times,A,IdentityMatrix[m]]-Outer[Times,IdentityMatrix[n],Transpose@C]];
(*Return[Partition[LinearSolve[T,-Flatten@B],m]]*)
Return[Check[Partition[LinearSolve[T,-Flatten@B],m],Indeterminate*B,{LinearSolve::nosol}]]
]


Denominators::usage="Denominators[\!\(\*
StyleBox[\"m\", \"TI\"]\)|\!\(\*
StyleBox[\"ds\", \"TI\"]\)] tries to define denominators in the system.";


Denominators[m_List,excl_:_?NumericQ]:=DeleteCases[Union@@((First/@FactorList[#])&/@Denominator/@Flatten[m]),excl]
Denominators[ex_,excl_:_?NumericQ]:=DeleteCases[First/@FactorList[Denominator@ex],excl]


Denominators[ds_?DSystemQ]:=Module[{dens},
dens=Denominators/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[dens===Denominators,
dens=Denominators[Values[History[ds][[HistoryIndex[ds],1]]],_?(FreeQ[#,Alternatives@@Variables[ds]]&)];
HistoryAddExtra[ds,Denominators->dens],
Print[Style["Read Denominators from extras.",Small]]
];
dens
]


Denominators[as_Assiciation]:=Denominators[Values[History[as][[HistoryIndex[as],1]]],_?(FreeQ[#,Alternatives@@Variables[as]]&)]


Denominators[ds_?DSystemQ,excl_]:=Denominators[Values[History[ds][[HistoryIndex[ds],1]]],excl]


DenominatorOrder::usage="DenominatorOrder[m|ds,den] tries to define the power of the denominator. Negative values correspond to numerators.";


DenominatorOrder[0,den_]:=-\[Infinity];
DenominatorOrder[ex_,den_]:=Plus@@Cases[FactorList[Denominator@ex],{den,n_}:>n];
DenominatorOrder[m_List,den_]:=Max[DenominatorOrder[#,den]&/@Flatten[m]];


DenominatorOrder[ds_?DSystemQ,den_]:=DenominatorOrder[Values[History[ds][[HistoryIndex[ds],1]]],den]


PolesPosition::usage="PolesPosition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] tries to determine all singular points of the matrix \!\(\*
StyleBox[\"m\", \"TI\"]\).";


PolesPosition[m_List,x_Symbol]:=Module[{xf,t,mr},
xf=x/.#&/@Union@Flatten[Solve[#==0,x]&/@Denominators[{m},_?(FreeQ[#,x]&)]];
mr=Factor[m/t^2/.x->1/t];
If[Quiet[Check[mr/.t->0;False,True,Power::infy]],Sort[Append[xf,\[Infinity]]],Sort[xf]]
]


PolesPosition[ds_Association,x_Symbol]:=PolesPosition[ds[x],x]
PolesPosition[ds_?DSystemQ,x_Symbol]:=PolesPosition[ds[x],x]


PoincareRank::usage="PoincareRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)}] gives the Poincare rank \!\(\*
StyleBox[\"r\", \"TI\"]\) of the singular point \!\(\*
StyleBox[\"x\", \"TI\"]\)=\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\) of \!\(\*
StyleBox[\"m\", \"TI\"]\). When \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)\[NotEqual]\[Infinity] the Poincare rank is the pole order minus 1 (by convention, we put \!\(\*
StyleBox[\"r\", \"TI\"]\)=-1 for regular point). For \!\(\*SubscriptBox[\(x\), \(0\)]\)=\[Infinity] the Poincare rank is 1 minus the leading series order.";


PoincareRank[m_List,{x_Symbol,x0_}]:=Max[-1,2*Boole[x0===\[Infinity]]-1-LeadingOrder[m,{x,x0}]]


PoincareRank[ds_Association,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]
PoincareRank[ds_?DSystemQ,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


PolesInfo[ds_Association]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]
PolesInfo[ds_?DSystemQ]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]


PolesInfo::usage="PolesInfo[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of pairs {\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\) is the position of the pole, and \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\) is its Poincare rank.";


PolesInfo[m_List,x_Symbol]:=Module[{xs,n},
xs=PolesPosition[m,x];
{#,PoincareRank[m,{x,#}]}&/@xs
]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


FactorPlus::usage="FactorPlus[expr] factors expr iff it has head \"Plus\"";


SetAttributes[FactorPlus,Listable];


FactorPlus[expr_Plus]:=Factor[expr];
FactorPlus[expr_]:=expr;


FactorListPlus::usage="FactorListPlus[expr] factors expr iff it has head \"Plus\" and gives a list of the factors, together with their exponents.";


FactorListPlus[expr_Plus]:=FactorList[expr];
FactorListPlus[expr_]:=Factors[expr];


Factors::usage="Factors[expr] returns the list of expr factors not trying to factorize it.";


Factors[expr_]:=Replace[Replace[{expr},Times->Sequence,{2},Heads->True],{x_^n_Integer:>{x,n},x_:>{x,1}},{1}]


ker[m_?MatrixQ]:=Module[{cs,l=Length@First@m (*# of cols*),cs1,eqs,sol},
cs=Table[Unique["c"],{l}];
eqs=Dot[m,cs];
sol=GaussSolve[eqs,cs];(*always should be a solution*)
cs1=Complement[cs,First/@sol];
If[cs1==={},
Return[{0&/@cs}],
Return[Transpose@Outer[Coefficient,cs/.sol,cs1]]
]
]


im=ker@*ker@*Transpose;


bjf::usage="bjf[\!\(\*
StyleBox[\"A\", \"TI\"]\),\!\(\*
StyleBox[\"B\", \"TI\"]\),\!\(\*
StyleBox[\"k\", \"TI\"]\)] constructs block matrix of the form ({
 {A, B, 0},
 {0, A, B},
 {0, 0, A}
}) where \!\(\*
StyleBox[\"A\", \"TI\"]\) is repeated \!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)times. In particular, blockMatrix[\[Lambda],1,\!\(\*
StyleBox[\"k\", \"TI\"]\)] gives \!\(\*
StyleBox[\"k\", \"TI\"]\)*\!\(\*
StyleBox[\"k\", \"TI\"]\) Jordan cell.";
bjf[a_,b_,k_Integer]:=Module[{ap,bp},ArrayFlatten[IdentityMatrix[k]*ap+Rest[Transpose[IdentityMatrix[{k,k+1}]]]*bp/.{ap->a,bp->b}]];


End[];


EndPackage[]


If[($LibraUseFermat=MemberQ[$ContextPath,"Fermatica`"]),Print["Using Fermatica for matrix operations!"]];


If[$LibraTODO,CellPrint[Cell["todo:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@Libra`Private`todolist;
CellPrint[Cell["done:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[Checkmark] "<>#,{"Text",Small}]]&/@Libra`Private`donelist];
