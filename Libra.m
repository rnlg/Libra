(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Libra`"]


$LibraHomeDirectory=DirectoryName[$InputFileName];


$LibraUseFermat=False;
$LibraVersion="1.1beta";
$LibraInputFileName=$InputFileName;


NewDSystem;


History;HistoryIndex;Undo;Redo;HistoryRecall;HistoryForesee;
HistoryAppend;HistoryAddExtra;HistoryDeleteExtra;HistoryConsolidate;OverallTransformation;
HistoryBurn;


Notations;AddNotation;DeleteNotation;
RuleToNotation;NotationToRule


SubsystemsIndices;
LargestSubsystemsIndices;
EntangledBlocksIndices;
DependentRowIndices;
DependentColumnIndices;
BlocksHierarchyIndices;
OffDiagonalBlocksIndices;DiagonalBlocksIndices;
ArrayCoefficientRules;
CheckMerge;
RelevantIndices;


PickBasis;PickBasisIndices;


ODot;OInverse;ODet;OKer;


DiffMod;


Transform;ChangeVar;


TClosure;


PolesPosition;PoincareRank;PolesInfo;


Denominators;PolyPoincareRank;DenominatorsInfo;


DiagonalQ;
NilpotentQ;
FuchsianQ;
EFormQ;
JFormQ;


JDecomposition;JDecompositionData;


JDTowers;JDSpace;JDData;JDecompose;


RatFuncQ;PolyQ;


Factors;FactorPlus;FactorListPlus;


LeadingOrder;


SeriesCoefficients;LeadingSeries;LeadingSeriesCoefficient;LeadingSeriesCoefficients;


DSystemQ;


Balance;VisBalancing;
VisTransformation;


(*A0ToSubspaces;*)A0A1ToSubspaces;GetSubspaces;Projector;


FactorOut;FactorDependence;


ReduceFactors;


GaussSolve;


BlockTriangularToFuchsian;


FuchsifyBlock;FuchsifyDependent;Fuchsify;FuchsifyDependentBlocks;


ToOneDE;ToCompanionDS;


BTSolve;


RadicalsUp;


HistoryCheck;HistoryChop;


PexpExpansion;
II;Protect[II];
II::usage="II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x] denotes iterated integral, \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary (with convention II[{},x]=1). II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)] specifies \!\(\*SubscriptBox[\(x\), \(0\)]\). By definition, II[{\!\(\*SubscriptBox[\(x\), \(0\)]\),\[Ellipsis],\!\(\*SubscriptBox[\(x\), \(0\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)]=Log[x-\!\(\*SubscriptBox[\(x\), \(0\)]\)\!\(\*SuperscriptBox[\(]\), \(n\)]\)/n!."


SeriesSolutionData;ConstructSeriesSolution;


SpotCoefficients;GetLcs;GetL;


FactorLeadingLetter;FactorTrailingLetter;


EValues;ESpace;


 OMatrixExp;


InvertMod;QuolyMod;OQuolyMod;
ExtendedQuolyMod;
ModNotation=Libra`Private`obsolete[OQuolyMod,"ModNotation[\[Ellipsis]]"->"OQuolyMod[\[Ellipsis]]"]
(*PolyLeadingTerm;*)


PolyLeadingOrder;PolyKer;PolyPickBasis;PolyMatrixRank;PolyInverse;PolyEValues;PolyESpace;PolyProjector;PolySeriesRules;PolySeriesCoefficient;PolyJDTowers;PolyJDSpace;PolyJDData;


LeadingOrderMod;KerMod;PickBasisMod;MatrixRankMod;InverseMod;EValuesMod;ESpaceMod;ProjectorMod;SeriesRulesMod;SeriesCoefficientMod;JDTowersMod;JDSpaceMod;JDDataMod;


$LibraNotations;


NotationsBlock;


Rookie;


Begin["`Private`"]


System`GetFactor::usage="GetFactor[\!\(\*
StyleBox[\"ex\", \"TI\"]\),\!\(\*
StyleBox[\"patt\", \"TI\"]\)] returns a product of factors in \!\(\*
StyleBox[\"ex\", \"TI\"]\), which match \!\(\*
StyleBox[\"patt\", \"TI\"]\). E.g., GetFactor[\!\(\*
StyleBox[\"ex\", \"TI\"]\),_?NumericQ] returns numeric factor."
System`GetFactor[ex_List,pat_]:=System`GetFactor[#,pat]&/@ex;
System`GetFactor[ex_,pat_]:=If[ex===0,1,Times@@Cases[Power@@@FactorList[ex],pat,{1}]]


System`GetSimilarFactor::usage="GetSimilarFactor[{\!\(\*
StyleBox[\"ex1\", \"TI\"]\),\!\(\*
StyleBox[\"ex2\", \"TI\"]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)},\!\(\*
StyleBox[\"patt\", \"TI\"]\)] returns \"common\" factors of \!\(\*
StyleBox[\"ex1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ex2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\), which match \!\(\*
StyleBox[\"patt\", \"TI\"]\). E.g., GetSimilarFactors[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"ex1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"ex2\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),_?NumericQ] returns \"common\" numeric factor.";
System`GetSimilarFactor[ex_List,patt_]:=If[#==={},1,PolynomialGCD@@Numerator[#]/PolynomialGCD@@Denominator[#]]&[GetFactor[DeleteCases[ex,0],patt]]


ArrayCoefficientRules::usage:="ArrayCoefficientRules[\!\(\*
StyleBox[\"array\", \"TI\"]\),{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] does the same as CoefficientRules[\!\(\*
StyleBox[\"array\", \"TI\"]\),{\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"1\", \"TR\"]]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], 
StyleBox[\"2\", \"TR\"]]\),\!\(\*
StyleBox[\"\[Ellipsis]\", \"TR\"]\)}] but not that stupid in threading through lists.";


ArrayCoefficientRules[M_?ArrayQ,xs_,order_:"Lexicographic"]:=Module[{cr=CoefficientRules[M,xs],depth=ArrayDepth[M],keys},keys=First/@CoefficientRules[Plus@@(Times@@(xs^#)&/@DeleteDuplicates@Reap[Map[Sow@*First,cr,{depth+1}]][[2,1]]),xs,order];
Function[key,key->Map[key/.#/.key->0&,cr,{depth}]]/@keys
]
ArrayCoefficientRules[M_,xs_]:=CoefficientRules[M,xs]


System`GenCoefficientRules::usage="GenCoefficientRules[expr,vars] does the same as CoefficientRules[expr,vars], but applies also to noninteger powers.";


System`GenCoefficient::usage="GenCoefficient[expr,vars, pows] returns coefficient in front of the Times@@(vars^pows).";


System`GenCoefficientRules[expr_,var_]:=System`GenCoefficientRules[expr,{var}];
System`GenCoefficientRules[expr_List,vars_]:=System`GenCoefficientRules[#,vars]&/@expr;
System`GenCoefficientRules[expr_,vars_List]:=Module[
{ps=Table[Unique[],{Length@vars}],expanded,tov,v},
expanded=Expand[expr*Times@@(vars^ps)];
tov=DeleteDuplicates[Cases[expanded,(_.)(Times@@(vars^(Pattern[#,Blank[]]&/@ps))):>Evaluate[Times@@(vars^ps)->v@@ps],All]];
Thread[Last/@tov ->Last/@CoefficientRules[expanded/.tov,Last/@tov]]/.v->List/.Thread[ps->0]
];
System`GenCoefficient[expr_,var_,pow_]:=System`GenCoefficient[expr,{var},{pow}];
System`GenCoefficient[expr_,vars_List,pows_List]:=Module[{ps=Table[Unique[],{Length@vars}],expanded,v},
expanded=Expand[expr*Times@@(vars^ps)];
Coefficient[expanded/.Times@@(vars^Expand[ps+pows]):>v,v]
]


System`PartitionByLengths::usage="PartitionByLengths[list,lengths] splits list into chunks of the given leghts.\nExample:PartitionByLengths[{a,b,c,d,e,f},{3,1,2}] \[LongRightArrow] {{a,b,c},{d},{e,f}}";


System`PartitionByLengths[a_List,b_List]:=Module[{es=Accumulate[b],bs},
bs=Prepend[Most@es+1,1];
Take[a,#]&/@Transpose[{bs,es}]
]


System`ShuffleProduct::usage="ShuffleProduct[l1,l2] implements the shuffle product, e.g., ShuffleProduct[{a,b},{c,d}] \[LongRightArrow] {{a,b,c,d},{a,c,b,d},{a,c,d,b},{c,a,b,d},{c,a,d,b},{c,d,a,b}}.";


System`ShuffleProduct[a_List,b_List]:=Module[{chrs=Join[a,b],nums},nums=Range[Length[chrs]];Join@(Permute[chrs,#])&/@(Join[#,Complement[nums,#]]&/@Subsets[nums,{Length[a]}])]


System`StuffleProduct::usage="StuffleProduct[l1,l2] implements the stuffle product, e.g., StuffleProduct[{a,b},{c,d}] \[LongRightArrow]{{a,b,c,d},{a,b+c,d},{a,c,b,d},{a,c,b+d},{a+c,b,d},{a+c,b+d},{a,c,d,b},{a+c,d,b},{c,a,b,d},{c,a,b+d},{c,a,d,b},{c,a+d,b},{c,d,a,b}}.\nTo replace '+' in the above expression with function f, use the option Function\[Rule]f. E.g. StuffleProduct[{a,b},{c,d},Function\[Rule]f] \[LongRightArrow]{{a,b,c,d},{a,f[b,c],d},{a,c,b,d},{a,c,f[b,d]},{f[a,c],b,d},{f[a,c],f[b,d]},{a,c,d,b},{f[a,c],d,b},{c,a,b,d},{c,a,f[b,d]},{c,a,d,b},{c,f[a,d],b},{c,d,a,b}}.";


Options[System`StuffleProduct]={Function->Plus}


System`StuffleProduct[alist_List,blist_List,OptionsPattern[]]:=Module[{res,ar=Range[Length@alist],br=-Reverse@Range[Length@blist],p,s,l},
res=ShuffleProduct[ar,br];
res=Flatten[Outer[l,Sequence@@(List/@#//.{pre___,{a:Alternatives@@ar},{b:Alternatives@@br},post___}:>{pre,{s[a,b],p[a,b]},post})]&/@res]/.{s->Sequence,l->List}/.Thread[Join[ar,br]->Join[alist,blist]]/.p->OptionValue[Function]
]


System`TransposeYoungTableau::usage="TransposeYoungTableau[{\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(2\)]\),\[Ellipsis]}] transposes list of lists of non-increasing lengths.";
System`TransposeYoungTableau[yt_List]:=Module[{l=Length@First[yt],sq},Replace[Transpose[PadRight[#,l,sq]&/@yt],sq:>Sequence[],{2}]]


System`TransposePadRight::usage="TransposePadRight[{\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(2\)]\),\[Ellipsis]},\!\(\*
StyleBox[\"x\", \"TI\"]\)] transposes list of lists appending some of them with \!\(\*
StyleBox[\"x\", \"TI\"]\) if necessary.";
System`TransposePadRight[yt_List,x_]:=Module[{l=Max[Length/@yt],sq},Replace[Transpose[PadRight[#,l,sq]&/@yt],sq:>x,{2}]]


SetAttributes[CStaticMonitor,{HoldAll}];
CStaticMonitor[code_,msg_,delay_:0]:=If[$Notebooks,
Monitor[code,msg,delay],
WriteString["stdout","["<>ToString[msg,InputForm]];(WriteString["stdout","]\n"];#)&[code]
];


SetAttributes[CMonitor,{HoldAll}];
CMonitor[code_,mon_,delay_:0,msg_String:""]:=If[$Notebooks,
Monitor[code,mon,delay],
If[msg=!="",WriteString["stdout","["<>msg]];(If[msg=!="",WriteString["stdout","]\n"]];#)&[code]
];


CPrint[ex__]:=If[$Notebooks,Print[ex],WriteString["stdout",#]&/@{ex,"\n"}];
CPrintTemporary[ex__]:=If[$Notebooks,PrintTemporary[ex],WriteString["stdout",#]&/@{ex,"\n"}];


CWrite[msg_String,write_:True]:=If[!$Notebooks&&TrueQ[write],WriteString["stdout",msg]];


SetAttributes[CProgressPrint,HoldFirst];
(*
p --- variable containing progress indicated so far,
i --- current progress,
l --- target (100%)
*)
CProgressPrint[p_Symbol,i_,l_]:=Module[{step=Which[l-p>=6660,10^3,l-p>1660,5 10^2,l-p>=660,10^2,l-p>=160,5 10,l-p>= 60,10,l-p>=10,5,True,1],n},
If[Not[TrueQ[p>=0]],CWrite["["<>ToString[l]<>"|"];p=0;];
If[TrueQ[i>=p+step],
n=Quotient[ i-p,step];
p+=n*step;
CWrite["."<>ToString[p]];
];
If[i>=l,CWrite["]\n"]]
];


CPrint["\n******************** ",Style["Libra v"<>ToString[$LibraVersion],{Bold}]," ********************\nLibra (\:2696) is a package for the manipulation with differential systems.\n\[Copyright] 2018-, Roman N. Lee, Budker Institute of Nuclear Physics.\nRead from: "<>$InputFileName<>" (CRC32: "<>ToString[FileHash[$InputFileName,"CRC32"]]<>")"];


todolist={};
donelist={};
todo[s_String]:=AppendTo[todolist,s];
done[s_String]:=AppendTo[donelist,s];


todo["OffDiagonalBlocksIndices[_?DSystemQ]"]


PolyLeadingOrder[m_,poly_,x_,a___]:=Libra`Private`obsolete[LeadingOrderMod[m,x->poly,a],"PolyLeadingOrder[m,poly,x,\[Ellipsis]]"->"LeadingOrderMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyKer[m_,poly_,x_,a___]:=Libra`Private`obsolete[KerMod[m,x->poly,a],"PolyKer[m,poly,x,\[Ellipsis]]"->"KerMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyPickBasis[vs_,poly_,x_,a___]:=Libra`Private`obsolete[PickBasisMod[vs,x->poly,a],"PolyPickBasis[vs,poly,x,\[Ellipsis]]"->"PickBasisMod[vs,x\[Rule]poly,\[Ellipsis]]"];


PolyMatrixRank[m_,poly_,x_,a___]:=Libra`Private`obsolete[MatrixRankMod[m,x->poly,a],"PolyMatrixRank[m,poly,x,\[Ellipsis]]"->"MatrixRankMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyInverse[m_,poly_,x_,a___]:=Libra`Private`obsolete[InverseMod[m,x->poly,a],"PolyInverse[m,poly,x,\[Ellipsis]]"->"InverseMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyEValues[m_,poly_,x_,a___]:=Libra`Private`obsolete[EValuesMod[m,x->poly,a],"PolyEValues[m,poly,x,\[Ellipsis]]"->"EValuesMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyESpace[m_,poly_,x_,a___]:=Libra`Private`obsolete[ESpaceMod[m,x->poly,a],"PolyESpace[m,poly,x,\[Ellipsis]]"->"ESpaceMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyProjector[us_,vs_,poly_,x_,a___]:=Libra`Private`obsolete[ProjectorMod[us,vs,x->poly,a],"PolyProjector[us,vs,poly,x,\[Ellipsis]]"->"ProjectorMod[us,vs,x\[Rule]poly,\[Ellipsis]]"];


PolySeriesRules[m_,{x_,poly_,o_},a___]:=Libra`Private`obsolete[SeriesRulesMod[m,{x->poly,o},a],"PolySeriesRules[m,{x,poly,o},\[Ellipsis]]"->"SeriesRulesMod[m,{x\[Rule]poly,o},\[Ellipsis]]"];


PolySeriesCoefficient[m_,{x_,poly_,o_},a___]:=Libra`Private`obsolete[SeriesCoefficientMod[m,{x->poly,o},a],"PolySeriesCoefficient[m,{x,poly,o},\[Ellipsis]]"->"SeriesCoefficientMod[m,{x\[Rule]poly,o},\[Ellipsis]]"];


PolyJDTowers[m_,poly_,x_,a___]:=Libra`Private`obsolete[JDTowersMod[m,x->poly,a],"PolyJDTowers[m,poly,x,\[Ellipsis]]"->"JDTowersMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyJDSpace[m_,poly_,x_,a___]:=Libra`Private`obsolete[JDSpaceMod[m,x->poly,a],"PolyJDSpace[m,poly,x,\[Ellipsis]]"->"JDSpaceMod[m,x\[Rule]poly,\[Ellipsis]]"];


PolyJDData[m_,poly_,x_,a___]:=Libra`Private`obsolete[JDDataMod[m,x->poly,a],"PolyJDData[m,poly,x,\[Ellipsis]]"->"JDDataMod[m,x\[Rule]poly,\[Ellipsis]]"];


todo["History: adding labels may be usefull"];


History::usage="History[ds] is the central object. It is a list with the elements of the following form:
{M,\"Operation\",extra1\[Rule]\[Ellipsis],\[Ellipsis]}";


HistoryIndex::usage="HistoryIndex[ds] is the current position in the History[ds]";


History::first="Undo can not be done. Too close to the beginning.";


History::last="Redo can not be done. Already at the end.";


History::nothing="History change not required.";


History::lbl1="No label \"`1`\" in the history.";
History::lbl2="Label \"`1`\" is ahead. Use Redo to rewind.";
History::lbl3="Label \"`1`\" is behind. Use Undo to rewind.";


HistoryAppend::usage="HistoryAppend[ds,{M,{func,arg1,\[Ellipsis]},extra1\[Rule]\[Ellipsis],\[Ellipsis]}] adds the most recent entry to the history.";


Options[HistoryAppend]={HistoryChop->False,Print->True};


HistoryAppend::chop="Did not change history to avoid overwriting forward entries. Use HistoryChop[`1`] first or execute SetOptions[HistoryAppend,HistoryChop\[Rule]True]."


HistoryAppend[ds_Symbol?DSystemQ,event:{_Association,_List,___},OptionsPattern[]]:=If[
TrueQ[OptionValue[HistoryChop]||Length[History[ds]]<=HistoryIndex[ds]],
unprotect[ds,History[ds]^=Append[Take[History[ds],HistoryIndex[ds]],event];HistoryIndex[ds]^=HistoryIndex[ds]+1];If[OptionValue[Print],CPrint[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]],
Message[HistoryAppend::chop,ds]];


HistoryAddExtra::usage="HistoryAddExtra[ds_Symbol,extra1\[Rule]\[Ellipsis],\[Ellipsis]] adds some optional information to the current history event.";


Options[HistoryAddExtra]={Print->True};


HistoryAddExtra[ds_Symbol?DSystemQ,{rules__Rule},OptionsPattern[]]:=(
unprotect[ds,History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->Join[DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@First/@{rules}->_],{rules}]]];
If[OptionValue[Print],CPrint[Style["Added extra(s) "<>StringRiffle[ToString/@First/@{rules},","]<>" to current history entry.",Small]]];)


HistoryDeleteExtra::usage="HistoryDeleteExtra[ds_Symbol,extra1,\[Ellipsis]] removes optional information from the current history event.";


Options[HistoryDeleteExtra]={Print->True};


HistoryDeleteExtra[ds_Symbol?DSystemQ,{extras___},OptionsPattern[]]:=(
unprotect[ds,History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@extras->_]]];
If[OptionValue[Print],CPrint[Style["Deleted extra(s) "<>StringRiffle[ToString/@extras,","]<>" from current history entry.",Small]]])


HistoryAddLabel::usage="HistoryAddLabel[ds,label] add a label to the history."


HistoryAddLabel[ds_?DSystemQ,label_String]:=HistoryAddExtra[ds,{Label->label},Print->False];


HistoryLabels[ds_?DSystemQ]:=Cases[History[ds][[All,3;;]],(Label->label_):>label]


Options[Undo]={HistoryChop->False};


Undo[ds_?DSystemQ,n_Integer:1,OptionsPattern[]]:=If[HistoryIndex[ds]>n,
unprotect[ds,HistoryIndex[ds]^=If[n>=0,HistoryIndex[ds]-n,-n];CPrint[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]];
If[OptionValue[HistoryChop],HistoryChop[ds]],Message[History::first]];


Undo[ds_?DSystemQ,All,opts:OptionsPattern[]]:=Undo[ds,-1,opts]


Redo[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]<=Length@History[ds]-n,
unprotect[ds,
HistoryIndex[ds]^=If[n>=0,HistoryIndex[ds]+n,Length@History[ds]+n+1];CPrint[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]],Message[History::last]];


Redo[ds_?DSystemQ,All]:=Redo[ds,-1]


Undo[ds_?DSystemQ,label_String,OptionsPattern[]]:=Module[{hi=HistoryIndex[ds],i},
i=First/@Position[History[ds][[All,3;;]],Label->label];
If[i==={},Message[History::lbl1,label];Return[]];i=First[i];
If[i>hi,
Message[History::lbl2,label],
unprotect[ds,HistoryIndex[ds]^=i;CPrint[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]];
]
]


Redo[ds_?DSystemQ,label_String,OptionsPattern[]]:=Module[{hi=HistoryIndex[ds],i},
i=First/@Position[History[ds][[All,3;;]],Label->label];
If[i==={},Message[History::lbl1,label];Return[]];i=First[i];
If[i<hi,
Message[History::lbl3,label],
unprotect[ds,HistoryIndex[ds]^=i;CPrint[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]];
]
]


HistoryRecall[ds_?DSystemQ,n_Integer:1,OptionsPattern[]]:=If[HistoryIndex[ds]>n,
History[ds][[If[n>=0,HistoryIndex[ds]-n,-n],1]],Message[History::first]];


HistoryForesee[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]<=Length@History[ds]-n,
History[ds][[If[n>=0,HistoryIndex[ds]+n,Length@History[ds]+n+1],1]],Message[History::last]];


HistoryChop::usage="HistoryChop[ds_] chops off forward entries in history. Use before applying HistoryConsolidate.";


HistoryChop[ds_?DSystemQ]:=(unprotect[ds,History[ds]^=Take[History[ds],HistoryIndex[ds]]];HistoryIndex[ds])


HistoryConsolidate::usage="HistoryConsolidate[ds] consolidates history.\n\
HistoryConsolidate is superceeded by OverallTransformation. The latter returns not only the transformation matrix, but also change of variables and introduced notations.\n\
NB: HistoryConsolidate[ds] is now OverallTransformation[ds][Transform].";


Options[HistoryConsolidate]={Inverse->False,Fermatica`UseFermat->False,Transform->None,Monitor->True};


HistoryConsolidate[ds_?DSystemQ,opts:OptionsPattern[]]:=OverallTransformation[ds,opts][Transform];


todo["HistoryConsolidate: make the procedure more flexible to allow for replacing parts of the history, both index- and labels-based. (labels probably via HistoryAddExtra)"];


todo["Think about better strategy of option UseFermat"];


OverallTransformation::usage="OverallTransformation[ds] calculates the overall transformation of the system: the transformation matrix, variables change, and introduced notations. It returns the association with entries Transform (for transformation matrix), ChangeVar (for variables change), and Notations (for introduced notations).\n\
NB: Option UseFermat can be True, False, or  \"\!\(\*
StyleBox[\"abc\",\nFontSlant->\"Italic\"]\)\", where \!\(\*
StyleBox[\"abc\",\nFontSlant->\"Italic\"]\) is three-digit binary number, \!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"b\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\) instructs to use Fermat for OInverse, ODot, and OQuoluMod, respectively.";


OverallTransformation::err="Unexpected entry {`1`,\[Ellipsis]} in history is met at position `2`. Aborting";
OverallTransformation::map="Function `1` was mapped onto T instead of M.";


Options[OverallTransformation]={Inverse->False,Fermatica`UseFermat->False,Transform->None,Monitor->True,QuolyMod->True};


todo["OverallTransformation with Inverse\[Rule]True option should apply QuolyMod."];


OverallTransformation[ds_?DSystemQ,OptionsPattern[]]:=Module[{to,T=IdentityMatrix[Length@ds],Ti=IdentityMatrix[Length@ds],i,ii,t,start,end,val,old,new,subs,inv=OptionValue[Inverse],fflags=Replace[IntegerDigits[Replace[OptionValue[Fermatica`UseFermat],{False|None->0,True|All->7,f_String:>FromDigits[f,2]}],2,3],{1->True,0->False},{1}],
monitor=OptionValue[Monitor]},
Switch[to=OptionValue[Transform],
_?SquareMatrixQ,Print["Starting from nontrivial T\[Ellipsis]"];If[inv,Ti=OInverse[T=to,Fermatica`UseFermat->fflags[[1]]]],
{_?SquareMatrixQ,_?SquareMatrixQ},Print["Starting from nontrivial T,Ti\[Ellipsis]"];{T,Ti}=to,
_,T=Ti=IdentityMatrix[Length@ds](*Unevaluated[Sequence[]]*)];
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[Take[History[ds],HistoryIndex[ds]],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
old=new=subs=Keys[val];
end=HistoryIndex[ds];
If[monitor,
CWrite["\n["<>ToString[end-start]<>"|"];CMonitor,#&][Do[
CWrite[".",monitor];
Replace[History[ds][[i,2]],{
{Transform,ds,tt_?SquareMatrixQ}:>(T=ODot[T,tt,Fermatica`UseFermat->fflags[[2]]];If[inv,Ti=ODot[OInverse[tt,Fermatica`UseFermat->fflags[[1]]],Ti,Fermatica`UseFermat->fflags[[2]]]]),
{Transform,ds,{tt_?SquareMatrixQ,tti_?SquareMatrixQ,Optional[(True|False),False]}}:>(
T=ODot[T,tt,Fermatica`UseFermat->fflags[[2]]];If[inv,Ti=ODot[tti,Ti,Fermatica`UseFermat->fflags[[2]]]]),
{Transform,ds,tt_?SquareMatrixQ,ii_}:>(T[[All,ii]]=ODot[T[[All,ii]],tt,Fermatica`UseFermat->fflags[[2]]];If[inv,Ti[[ii]]=ODot[OInverse[tt,Fermatica`UseFermat->fflags[[1]]],Ti[[ii]],Fermatica`UseFermat->fflags[[2]]]]),
{Transform,ds,{tt_?SquareMatrixQ,tti_?SquareMatrixQ,Optional[(True|False),False]},ii_}:>(T[[All,ii]]=ODot[T[[All,ii]],tt,Fermatica`UseFermat->fflags[[2]]];If[inv,Ti[[ii]]=ODot[tti,Ti[[ii]],Fermatica`UseFermat->fflags[[2]]]]),
{ChangeVar,ds,tt_,nw_,___}:>(T=Factor[T/.tt];If[inv,Ti=Factor[Ti/.tt]];subs=Factor[subs/.tt];new=nw),
{Factor,ds}:>(T=Factor[T];If[inv,Ti=Factor[Ti]]),
{Simplify,ds,tt___}:>(T=Simplify[T,tt];If[inv,Ti=Simplify[Ti,tt]];subs=Simplify[subs,tt]),
{Map,f_,ds,tt___}:>(Message[OverallTransformation::map,f];T=Map[f,T,tt];If[inv,Ti=Map[f,Ti,tt]];),
{MapAt,f_,ds,tt___}:>(Message[OverallTransformation::map,f];T=MapAt[f,T,tt];If[inv,Ti=MapAt[f,Ti,tt]]),
{AddNotation,ds,tt_}:>Null,
{f_,__}:>(Message[OverallTransformation::err,f,i];Abort[])
}
],
{i,start+1,end}];
CWrite["]",monitor];,
Overlay[{ProgressIndicator[i,{start,end}],Style["OT: "<>ToString[i-start]<>"/"<>ToString[end-start],Tiny]},Alignment->Center]];
(*T=First[{T,IdentityMatrix[Length@ds]}];Ti=First[{Ti,IdentityMatrix[Length@ds]}];*)
If[OptionValue[QuolyMod],
i=1;end=Length@Notations[ds];If[inv,end=2*end];
CMonitor[
T=Fold[OQuolyMod[i++;#,#2,Fermatica`UseFermat->fflags[[3]]]&,T,Notations[ds]];
If[inv,Ti=Fold[OQuolyMod[i++;#,#2,Fermatica`UseFermat->fflags[[3]]]&,Ti,Notations[ds]]];,
Overlay[{ProgressIndicator[i,{0,end}],Style["OT: Modding notations...",Tiny]},Alignment->Center],1
]
];
<|Transform->If[inv,{T,Ti},T],ChangeVar->{Thread[old->subs],new},Notations->Notations[ds],In->val,Out->ds[]|>
]


HistoryCheck::usage="HistoryCheck[ds_] checks history consistency. It simply redoes all transformations and checks whether the same result is obtained.";


HistoryCheck::inconsistent="History[`1`] is inconsistent at index `2`.";
HistoryCheck[des_]:=Module[
{m,i,hi=HistoryIndex[des],mn,action},
CWrite["\n["<>ToString[hi]<>"|"];
CMonitor[
Do[
CWrite["."];
mn=History[des][[i,1]];
action=History[des][[i,2]]/.des->m;
#1[##2]&@@action;
(*Print[m];Print[mn];*)
If[!TrueQ@(Union[Keys[mn]]===Union[Keys[m[]]]&&(And@@(MatchQ[Factor[mn[#]-m[#]],{{0...}...}]&/@Keys[mn]))),Message[HistoryCheck::inconsistent,des,i];Return[$Failed]];
,{i,hi}],
Overlay[{ProgressIndicator[i,{1,hi}],Style["HC: "<>ToString[i]<>"/"<>ToString[hi],Tiny]},Alignment->Center]
];
CWrite["]"];
CPrint["History is consistent!"];
]


HistoryBurn::err="Can not burn!";


HistoryBurn::usage="HistoryBurn[ds] "


HistoryBurn[ds_?DSystemQ]:=Module[{T=IdentityMatrix[Length@ds],i,t,start,end,val},
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[History[ds],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
end=HistoryIndex[ds];
If[val=!=History[ds][[1,1]],Message[HistoryBurn::err];Return[$Failed]];
unprotect[ds,
History[ds]^=Prepend[History[ds][[start+1;;end]],History[ds][[1]]];
HistoryIndex[ds]^=Length@History[ds]];
]


todo["rethink how HistoryBurn should work"];


NewDSystem::usage="NewDSystem[ds,{x->Mx, y->My,\[Ellipsis]}] defines a new differential system associated with the variable ds.";
NewDSystem::size="Size of the systems mismatch.";
NewDSystem::error="Something went wrong. Aborting...";


Options[NewDSystem]={Print->True};


done["Think of maybe using List over Association for Notations. Easier to copy then."];


NewDSystem[ds_,def_Rule,opts:OptionsPattern[]]:=NewDSystem[ds,{def},opts]
NewDSystem[ds_Symbol,defs_Association,opts:OptionsPattern[]]:=NewDSystem[ds,defs/.Association->List,opts]
NewDSystem[ds_Symbol,defs:{(_Symbol->_?SquareMatrixQ)..},opts:OptionsPattern[]]:=Module[{l},
Quiet[Unprotect[ds];Clear[ds]];(*in case ds was defined earlier*)
Check[
History[ds]^={};HistoryIndex[ds]^=0;
DSystemQ[ds]^=True;
(*Modified 17.07.2019*)(*(*Deleted 17.07.2019*)Notations[ds]^=Association[]No(*/Deleted 17.07.2019*)*)
Notations[ds]^={};
(*/Modified 17.07.2019*)
(*will be used in arguments patterns*)l=Length/@Last/@defs;
If[!(SameQ@@l),Message[NewDSystem::size]];
Length[ds]^=First@l;
HistoryAppend[ds,{Association[defs],{NewDSystem,ds,Association[defs]}},Print->OptionValue[Print]];
(*ToExpression[#<>"$M:=History["<>#<>"][[HistoryIndex["<>#<>"],1]];Protect["<>#<>"$M]"]&[SymbolName[ds]]*),
Message[NewDSystem::error];Abort[];
];
unprotect[ds,redefineOperations[ds]];
If[TrueQ@OptionValue[Print],CPrint["Successfully created differential system for "<>ToString@Length@ds<>" functions of "<>StringRiffle[ToString/@First/@defs,","]<>"."];
(*Print["Next, you might want to find denominators appearing. See ?Denominators."];*)];
ds::usage="Differential system for "<>ToString@Length@ds<>" functions of "<>StringJoin@@Riffle[ToString/@First/@defs,","]<>".";

]


Notations::usage="Notations[ds] is a list of notations used.\n\
Notations[ds,{ii,jj}] list of notations met in ds[[ii,jj]]\n\
Notations[ds,ii] is a shortcut for Notations[ds,{ii,ii}].";


Notations[ds_?DSystemQ]:={};


Notations[ds_?DSystemQ,ii:{__Integer}|_Span]:=Notations[ds,{ii,ii}]
Notations[ds_?DSystemQ,{ii:{__Integer}|_Span,jj:{__Integer}|_Span}]:=Function[ss,Select[Notations[ds],Not[FreeQ[ss,First[#]]]&]][ds[[ii,jj]]];


redefineOperations[ds_Symbol]:=Module[{t1,i,keys,l},
(*(#[ds,opts___]^:=Function[ds$M,t1=#[ds$M,opts];If[t1===ds$M,Message[History::nothing],HistoryAppend[ds,{t1,{#,ds,opts}}];t1]][ds[]];)&/@{Factor,Simplify,FullSimplify,Apart,Together};*)
Function[fun,fun[ds,opts___]^:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
CWrite["\n["<>ToString[l]<>"|"];
CMonitor[(t1[#]=Map[((i++;CWrite["."];#)&@fun[#,opts])&,t1[#],{2}])&/@keys,
ProgressIndicator[i,{0,l}],1];
CWrite["]"];
HistoryAppend[ds,{t1,{fun,ds,opts}}]);]/@{Factor,Simplify,FullSimplify,Apart,Together};
Variables[ds]^:=Keys[History[ds][[HistoryIndex[ds],1]]];
Protect/@Variables[ds];
ds[x_]:=(History[ds][[HistoryIndex[ds],1]])[x];
ds[]:=ds[[]];
ds/:Part[ds,a___]:=Map[Part[#,a]&,History[ds][[HistoryIndex[ds],1]]];
ds/:Map[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
CWrite["\n["<>ToString[l]<>"|"];
CMonitor[(t1[#]=Map[(i++;CWrite["."];#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}],1];
CWrite["]"];
HistoryAppend[ds,{t1,{Map[f,#1,##2]&,ds,pars}}]);
ds/:MapAt[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
CWrite["\n["<>ToString[l]<>"|"];
CMonitor[(t1[#]=MapAt[(i++;CWrite["."];#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}],1];
CWrite["]"];
HistoryAppend[ds,{t1,{MapAt[f,#1,##2]&,ds,pars}}])
]


DSystemQ::usage="DSystemQ[ds] returns True if ds is a differential system.";
DSystemQ[_]=False;


$LibraNotations::usage="$LibraNotations represents global notations of Libra. They are the list of the rules \!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) which should be understood as the statement that \!\(\*
StyleBox[\"x\", \"TI\"]\) is a root of the polynomial \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).\nUsually, $LibraNotations is set to {_\[Rule]0}. It can be temporarily prepended via NotationsBlock[notations,\[Ellipsis]].\n$LibraNotations is supposed to provide modding polynomial in the functions *Mod[ex,\!\(\*
StyleBox[\"x\", \"TI\"]\)] effectively making them shortcuts for *Mod[ex,\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)]."
$LibraNotations={_->0};


SetAttributes[NotationsBlock,{HoldRest}]


NotationsBlock[notations_List,expr_]:=Internal`InheritedBlock[{$LibraNotations},
$LibraNotations=Join[notations,$LibraNotations];
expr
]


InvertMod::usage="InvertMod[\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(1\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives the polynomial \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), such that \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(1\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)= 1 mod \!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


InvertMod[poly1_,poly2_,x_Symbol]:=InvertMod[poly1,x-> poly2]


InvertMod[poly1_,x_Symbol->0]:=1/poly1;


InvertMod[poly1_,x_Symbol->poly2_]:=Module[{gcd,u,v},{gcd,{u,v}}=PolynomialExtendedGCD[poly1,poly2,x];If[FreeQ[gcd,x],u/gcd,1/0]
]


InvertMod[a:(_Integer|_Rational),p_?PrimeQ]:=Module[{gcd,u,v},
{gcd,{u,v}}=ExtendedGCD[a,p];

If[gcd==1,u,1/0]]


InvertMod[poly1_,x_Symbol]:=InvertMod[poly1,x->(x/.$LibraNotations)]


QuolyMod::usage="QuolyMod[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives the \"remainder\" \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) of the rational function Q(x) when divided by polynomial P(x). Therefore, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)=\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)+ \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\[CenterDot]\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


QuolyMod[quoly_,poly:Except[_Rule|_List],x_Symbol]:=QuolyMod[quoly,x->poly];


QuolyMod[quoly_List,args__]:=QuolyMod[#,args]&/@quoly;
QuolyMod[quoly_,list_List]:=Fold[QuolyMod,quoly,list];


QuolyMod[quoly_,x_Symbol->0]:=quoly;


QuolyMod[quoly_,x_Symbol->poly_]:=Module[{num,den},
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
Together@PolynomialRemainder[InvertMod[den,poly,x]*num,poly,x]
]


QuolyMod[a:(_Integer|_Rational),p_?PrimeQ]:=Module[{num,den},
{num,den}=Through[{Numerator,Denominator}@a];
Mod[InvertMod[den,p]*num,p]
]


QuolyMod[quoly_,x_Symbol]:=QuolyMod[quoly,x->(x/.$LibraNotations)]


ExtendedQuolyMod::usage="ExtendedQuolyMod[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives the pair {\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)}, where \!\(\*
StyleBox[\"k\", \"TI\"]\) is the \"leading order\" and \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the \"remainder\". Therefore, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)(\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


ExtendedQuolyMod::wrongargs="Something wrong with the arguments of ExtendedQuolyMod.";


ExtendedQuolyMod[quoly_List,args__]:=ExtendedQuolyMod[#,args]&/@quoly;


ExtendedQuolyMod[quoly_,poly_,x_]:=ExtendedQuolyMod[quoly,x->poly];


ExtendedQuolyMod[quoly_,x_Symbol->0]:={0,quoly}


ExtendedQuolyMod[quoly_,x_Symbol->poly_]:=Module[{num,num1,den,den1,rmndr,k=0},
If[FreeQ[poly,x],Return[{\[Infinity],quoly}]];
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
If[PossibleZeroQ[num],Return[\[Infinity]]];
While[True,
{den1,rmndr}=PolynomialQuotientRemainder[den,poly,x];
If[rmndr=!=0,Break[]];
den=den1;k--;
];
While[True,
{num1,rmndr}=PolynomialQuotientRemainder[num,poly,x];
If[rmndr=!=0,Break[]];
num=num1;k++;
];
{k,QuolyMod[num/den,x->poly]}
]


ExtendedQuolyMod[a:(_Integer|_Rational),p_?PrimeQ]:=Module[{num,num1,den,den1,rmndr,k=0},
If[a==0,Return[\[Infinity]]];
{num,den}=Through[{Numerator,Denominator}@a];
While[True,
{den1,rmndr}=Mod[den,p];
If[rmndr=!=0,Break[]];
den=den1;k--;
];
While[True,
{num1,rmndr}=Mod[num,p];
If[rmndr=!=0,Break[]];
num=num1;k++;
];
{k,QuolyMod[num/den,p]}
]


ExtendedQuolyMod[quoly_,x_Symbol]:=ExtendedQuolyMod[quoly,x->(x/.$LibraNotations)]


LeadingOrderMod::usage="LeadingOrderMod[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives the \"leading order\"  \!\(\*
StyleBox[\"k\", \"TI\"]\) such that, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where both the numerator and denominator of \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) are mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[LeadingOrderMod]={Check->False,Parallelize->False};
LeadingOrderMod::wrongargs="Something wrong with the arguments of LeadingOrderMod.";


LeadingOrderMod[ds_?DSystemQ,x_Symbol->poly_,opts:OptionsPattern[]]:=LeadingOrderMod[ds[x],x->poly,opts]
LeadingOrderMod[ds_?DSystemQ,x_Symbol,opts:OptionsPattern[]]:=LeadingOrderMod[ds[x],x,opts]


LeadingOrderMod[quoly_List,args__,opts:OptionsPattern[]]:=If[OptionValue[Parallelize],
DistributeDefinitions[LeadingOrderMod];
Min[ParallelMap[LeadingOrderMod[#,args,opts]&,quoly,{ArrayDepth[quoly]}]],
Min[Map[LeadingOrderMod[#,args,opts]&,quoly,{ArrayDepth[quoly]}]]
];


LeadingOrderMod::indet="LeadingOrderMod returned Indeterminate";


LeadingOrderMod[quoly_,x_->0,OptionsPattern[]]:=(Message[LeadingOrderMod::indet];Indeterminate)


LeadingOrderMod[quoly_,x_->ix_,OptionsPattern[]]/;x*ix===1:=LeadingOrder[quoly,{x,\[Infinity]}];


LeadingOrderMod[quoly_,x_->poly_,OptionsPattern[]]:=Module[{num,den,rmndr,k=0},
If[FreeQ[poly,x],Return[\[Infinity]]];
If[OptionValue[Check]&&!( RatFuncQ[quoly,x]&&PolyQ[poly,x]),Message[LeadingOrderMod::wrongargs];Abort[]];
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
If[PossibleZeroQ[num],Return[\[Infinity]]];
While[True,
{den,rmndr}=PolynomialQuotientRemainder[den,poly,x];
If[!PossibleZeroQ[rmndr],Break[]];
k--;
];
While[True,
{num,rmndr}=PolynomialQuotientRemainder[num,poly,x];
If[!PossibleZeroQ[rmndr],Break[]];
k++;
];
k
]


LeadingOrderMod[quoly_,x_,opts:OptionsPattern[]]:=LeadingOrderMod[quoly,x->(x/.$LibraNotations),opts]


todo["Redefine PolyLeadingTerm for matrices."];


SetAttributes[RadicalsUp,Listable];
RadicalsUp[ex_]:=Module[{den=Denominator[ex],num,denc},
num=den*ex;
denc=(den/.{x:Power[_,1/2]:>-x});
If[denc=!=den,Factor[Expand[num*denc]/Expand[den*denc]],ex]
];


PickBasis::usage="PickBasis[{v1,v2,...}] constructs basis in linear span of vectors v1,v2,\[Ellipsis]. Basically, it removes all dependent vectors from the given list.";


PickBasis[vectors:{__List}]:=Module[{r=0,basis={},rrbasis={}},
Scan[(If[MatrixRank[AppendTo[basis,#]]>r,r++,basis=Most[basis]])&,vectors];basis
]


PickBasisIndices::usage="PickBasisIndices[{v1,v2,...}] constructs basis in linear span of vectors v1,v2,\[Ellipsis]. Basically, it removes all dependent vectors from the given list.";


PickBasisIndices[vectors:{__List}]:=Module[{r=0,basis={},inds={}},
MapIndexed[(If[MatrixRank[AppendTo[basis,#]]>r,r++;AppendTo[inds,First[#2]],basis=Most[basis]])&,vectors];inds
]


PickBasisMod::usage="PickBasisMod[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] picks a basis out of \!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\) vectors in the field \!\(\*
StyleBox[\"\[DoubleStruckCapitalQ]\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\) where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is an irreducible polynomial. The order does not change and the left-most positions are preferable.\nPickBasisMod[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] means that \!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\) does not need QuolyMod beforehand."


PickBasisMod[evs_,x_Symbol-> poly_,mod:(True|False):True]:=Module[{basis={},basis1},
Scan[(basis1=Append[basis,#];If[polyKer[Transpose@basis1,poly,x,mod]==={},basis=basis1])&,evs];
basis
]


PickBasisMod[evs_,x_Symbol,mod:(True|False):True]:=PickBasisMod[evs,x->(x/.$LibraNotations),mod]


KerMod::usage="KerMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives a list of nullvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} such that each \!\(\*
StyleBox[\"u\", \"TI\"]\) satisfies \!\(\*
StyleBox[\"mu\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\)).\nKerMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";


KerMod[m_?MatrixQ,x_Symbol->poly_,mod:(True|False):True]:=PickBasisMod[SortBy[polyKer[m,poly,x,mod],Total[Exponent[#,x]]&],x->poly,False]


KerMod[m_?MatrixQ,x_Symbol,mod:(True|False):True]:=KerMod[m,x->(x/.$LibraNotations),mod]


polyKer[m_,poly_,x_,mod:(True|False):True]:=Module[{k=Exponent[poly,x],n=Dimensions[m][[2]],id,mr,xm,evs},
If[mod,mr=QuolyMod[m,x->poly],mr=m];
mr=id[Coefficient[mr,x,#]]&/@Range[0,k-1];
xm=CoefficientList[poly,x];(*action of x as a matrix from the right*)
xm=Append[Rest[IdentityMatrix[k]],-Most[xm]/Last[xm]];
evs=Factor[(x^Range[0,k-1]).Partition[#,n]]&/@OKer[ArrayFlatten[Transpose@NestList[Dot[#1,xm]&,mr,k-1]/.id->Identity]]
]


MatrixRankMod::usage="MatrixRankMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives a matrix rank of \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nMatrixRankMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";


MatrixRankMod[m_,x_Symbol->0,mod:(True|False):True]:=MatrixRank[m]


MatrixRankMod[m_?MatrixQ,x_Symbol->poly_,mod:(True|False):True]:=Length@First@m-Length[KerMod[m,x->poly]]


MatrixRankMod[m_?MatrixQ,x_Symbol,mod:(True|False):True]:=MatrixRankMod[m,x->(x/.$LibraNotations),mod]


InverseMod::usage="InverseMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives the inverse of \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nInverseMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";


InverseMod[m_?SquareMatrixQ,x_Symbol->0,mod:(True|False):True]:=OInverse[m]


InverseMod[m_?SquareMatrixQ,x_Symbol->poly_,mod:(True|False):True]:=Module[{m1},If[mod,m1=QuolyMod[m,x->poly],m1=m];m1=QuolyMod[OInverse[m1],x->poly]]


InverseMod[m_?SquareMatrixQ,x_Symbol,mod:(True|False):True]:=InverseMod[m,x->(x/.$LibraNotations),mod]


EValues::usage="EValues[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list of the eigenvalues of the square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). Supposed to be faster than native Eigenvalues.";


Options[EValues]={Fermatica`UseFermat->False};


EValues[m_,OptionsPattern[]]:=Module[
{chpoly,a},
chpoly=Factor@ODet[a*IdentityMatrix[Length@m]-m,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
Replace[a,#]&/@Flatten[Replace[Factors@chpoly,{_?(FreeQ[#,a]&):>Sequence[],{p_,n_}:>ConstantArray[Solve[p==0,a],n]},{1}]]
]


EValuesMod::usage="EValuesMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] gives a list of the eigenvalues of the square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in the field \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\) where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is an irreducible polynomial. An eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) is defined as a root of \!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"\[Lambda]P\", \"TI\"]\)\!\(\*
StyleBox[\"'\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\)) provided that this root is independent of \!\(\*
StyleBox[\"x\", \"TI\"]\).";
EValuesMod::error="Can not determine eigenvalues. Aborting...";


EValuesMod[m_,x_Symbol->0]:=EValues[m]


EValuesMod[m_,x_Symbol->poly_]:=Module[
{chpoly,a},
chpoly=Factor@QuolyMod[(*Modified 08.06.2019*)
(*(*Deleted 08.06.2019*)CharacteristicPolynomial[m,a]/.a\[Rule]a D[poly,x](*/Deleted 08.06.2019*)*)
ODet[a*D[poly,x]*IdentityMatrix[Length@m]-m](*/Modified 08.06.2019*),x->poly];
Replace[a,#]&/@Flatten[Replace[Factors@chpoly,{_?(FreeQ[#,a]&):>Sequence[],{p_?(FreeQ[#,x]&),n_}:>ConstantArray[Solve[p==0,a],n],_:>(Message[EValuesMod::error];Abort[])},{1}]]
]


EValuesMod[m_,p_?PrimeQ]:=Module[
{chpoly,a},
chpoly=Factor[ODet[a*IdentityMatrix[Length@m]-m],Modulus->p];
Replace[a,#]&/@Flatten[Replace[Factors@chpoly,{_?(FreeQ[#,a]&):>Sequence[],{f_,n_}:>ConstantArray[Solve[f==0,a,Modulus->p],n]},{1}]]
]


EValuesMod[m_,x_Symbol]:=EValuesMod[m,x->(x/.$LibraNotations)]


ESpace::usage="ESpace[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)] gives a list of the eigenvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} corresponding to the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\). Last argument can also be a list of eigenvalues, All, or omitted (=All)."


ESpace[m_?SquareMatrixQ,\[Lambda]_]:=OKer[m-\[Lambda] IdentityMatrix[Length@m]]


ESpace[m_?SquareMatrixQ,\[Lambda]s_List]:=Join@@(ESpace[m,#]&/@\[Lambda]s)


ESpace[m_?SquareMatrixQ,All]:=Join@@(ESpace[m,#]&/@DeleteDuplicates[EValues[m]])
ESpace[m_?SquareMatrixQ]:=ESpace[m,All]


ESpaceMod::usage="ESpaceMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)] gives a list of the eigenvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} corresponding to the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\). Each \!\(\*
StyleBox[\"u\", \"TI\"]\) is such that (\!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"\[Lambda]P\", \"TI\"]\)\!\(\*
StyleBox[\"'\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"u\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\)). Last argument can also be a list of eigenvalues, All, or omitted (=All).";


ESpaceMod[m_?SquareMatrixQ,x_Symbol->poly_,\[Lambda]_]:=KerMod[m-\[Lambda] IdentityMatrix[Length@m] D[poly,x],x->poly]


ESpaceMod[m_?SquareMatrixQ,x_Symbol->poly_,\[Lambda]s_List]:=Join@@(ESpaceMod[m,x->poly,#]&/@\[Lambda]s)


ESpaceMod[m_?SquareMatrixQ,x_Symbol->poly_,All]:=Join@@(ESpaceMod[m,x->poly,#]&/@DeleteDuplicates[EValuesMod[m,x->poly]])
ESpaceMod[m_?SquareMatrixQ,x_Symbol->poly_]:=ESpaceMod[m,x->poly,All]


ESpaceMod[m_?SquareMatrixQ,x_Symbol,a___]:=ESpaceMod[m,x->(x/.$LibraNotations),a]


done["ESpaceMod: remove linearly dependent vectors."]
done["ESpaceMod: allow for a list of \[Lambda]s."]


Projector::usage="Projector[\!\(\*
StyleBox[\"ulist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"vlist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] constructs a projector \!\(\*
StyleBox[\"P\", \"TI\"]\) with prescribed image and coimage.";


Options[Projector]={Fermatica`UseFermat->False}


Projector[u_,v_,OptionsPattern[]]:=Module[{ut=Transpose@u,of=Fermatica`UseFermat,ovf=OptionValue[Fermatica`UseFermat]},
Check[
ODot[ut,OInverse[ODot[v,ut,of->ovf],of->ovf],v,of->ovf],
ConstantArray[0,{Length@First[v],Length@ut}]]
]


ProjectorMod::usage="ProjectorMod[\!\(\*
StyleBox[\"ulist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"vlist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] constructs a projector \!\(\*
StyleBox[\"P\", \"TI\"]\) with prescribed image and coimage with entries in \!\(\*
StyleBox[\"\[DoubleStruckCapitalQ]\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nNote that if one of \!\(\*
StyleBox[\"ulist\", \"TI\"]\) or \!\(\*
StyleBox[\"vlist\", \"TI\"]\) is independent of \!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"P\", \"TI\"]\) is also a projector in the usual sense.";


ProjectorMod::error="Can not construct projector.";


ProjectorMod[u_List,v_List,x_Symbol->poly_]:=Module[{md,ut=Transpose[u]},
Check[md=InverseMod[ODot[v,ut],x->poly],Message[ProjectorMod::error];Return[ConstantArray[0,{Length@First[v],Length@ut}]]];
OQuolyMod[ODot[ut,md,v],poly,x]
]


JDTowers::usage="JDTowers[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives the towers {\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(2\)]\),\[Ellipsis]}with each tower \!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], 
StyleBox[\"k\", \"TI\"]]\) being a list of generalized eigenvectors corresponding to one Jordan cell. JDTowers[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)] does the same for the Jordan cells with eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\).";


Options[JDTowers]={Fermatica`UseFermat->False};


JDTowers[r_,opts:OptionsPattern[]]:=Flatten[JDTowers[r,#,opts]&/@DeleteDuplicates@EValues[r],1];
JDTowers[r_,All,opts:OptionsPattern[]]:=Flatten[JDTowers[r,#,opts]&/@DeleteDuplicates@EValues[r],1];
JDTowers[r_?SquareMatrixQ,evs_List,opts:OptionsPattern[]]:=Flatten[JDTowers[r,#,opts]&/@evs,1];
JDTowers[r_?SquareMatrixQ,ev:Except[_Rule],opts:OptionsPattern[]]:=Module[{vecs,vecs1,vecs2,l=Length[r],m,k=0,ns,plist={},rlist,evs},
If[patternQ[ev],
Return[JDTowers[r,Cases[DeleteDuplicates@EValues[r,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],ev],opts]]
];m=r-IdentityMatrix[l]*ev;
vecs=OKer[m,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
While[Length[vecs]>k,
AppendTo[plist,Length[vecs]-k];
k=Length@vecs;
vecs1=If[(ns=OKer[vecs,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]])==={},IdentityMatrix[l],SortBy[OKer[ODot[ns,m,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],ByteCount]];
Scan[(vecs2=Append[vecs,#];If[MatrixRank[vecs2]===Length[vecs2],vecs=vecs2;])&,vecs1]
];
If[plist==={},Return[{}]];
rlist=PartitionByLengths[vecs,plist];
Do[rlist[[i]]=Join[ODot[rlist[[i+1]],Transpose@m,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],rlist[[i]]],{i,Length@rlist-1,1,-1}];
rlist=PartitionByLengths[PickBasis[Flatten[rlist,1]],plist];
TransposeYoungTableau[rlist]
]


JDSpace::usage="JDSpace[\!\(\*
StyleBox[\"...\", \"TI\"]\)] is simply a shortcut for Flatten[JDTowers[\!\(\*
StyleBox[\"...\", \"TI\"]\)],1]. See ?JDTowers. Note that \!\(\*
StyleBox[\"t\", \"TI\"]\)=Transpose@JDSpace[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives the transformation to Jordan form.";


Options[JDSpace]={Fermatica`UseFermat->False};


JDSpace[r_?SquareMatrixQ,a___]:=Flatten[JDTowers[r,a],1]


JDTowersMod[r_?SquareMatrixQ,x_Symbol->poly_]:=Flatten[JDTowersMod[r,x->poly,#]&/@DeleteDuplicates@EValuesMod[r,x->poly],1];


JDTowersMod[r_?SquareMatrixQ,x_Symbol->poly_,All]:=Flatten[JDTowersMod[r,x->poly,#]&/@DeleteDuplicates@EValuesMod[r,x->poly],1];


JDTowersMod[r_?SquareMatrixQ,x_Symbol->poly_,evs_List]:=Flatten[JDTowersMod[r,x->poly,#]&/@evs,1];


JDTowersMod[r_?SquareMatrixQ,x_Symbol->poly_,ev_]:=Module[{vecs,vecs1,vecs2,l=Length[r],m,k=0,ns,plist={},rlist},
If[patternQ[ev],
Return[JDTowersMod[r,Cases[DeleteDuplicates@EValuesMod[r,x->poly],ev]]]
];
m=OQuolyMod[r,poly,x]-IdentityMatrix[l]*ev*D[poly,x];
vecs=KerMod[m,x->poly];
While[Length[vecs]>k,
AppendTo[plist,Length[vecs]-k];
k=Length@vecs;
vecs1=If[(ns=KerMod[vecs,x->poly])==={},IdentityMatrix[l],SortBy[KerMod[ODot[ns,m],x->poly],ByteCount]];
Scan[(vecs2=Append[vecs,#];If[MatrixRankMod[vecs2,x->poly]===Length[vecs2],vecs=vecs2;])&,vecs1]
];
If[plist==={},Return[{}]];
rlist=PartitionByLengths[vecs,plist];
Do[rlist[[i]]=Join[OQuolyMod[ODot[rlist[[i+1]],Transpose@m],poly,x],rlist[[i]]],{i,Length@rlist-1,1,-1}];
rlist=PartitionByLengths[PickBasisMod[Flatten[rlist,1],x->poly],plist];
TransposeYoungTableau[rlist]
]


JDTowersMod[r_?SquareMatrixQ,x_Symbol,a___]:=JDTowersMod[r,x->(x/.$LibraNotations),a]


todo["Write JDTowersMod::usage"];


JDSpaceMod[r_?SquareMatrixQ,a___]:=Flatten[JDTowersMod[r,a],1]


todo["Test JDSpaceMod"];


todo["Write JDSpaceMod::usage"];


JDData::usage="JDData[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives data for the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result has a form {{\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\),\!\(\*
StyleBox[\"ulist\", \"TI\"]\),\!\(\*
StyleBox[\"vlist\", \"TI\"]\)},...} where each element corresponds to Jordan cell with the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) , \!\(\*
StyleBox[\"ulist\", \"TI\"]\) being a Jordan chain vectors, starting from the eigenvectors, and \!\(\*
StyleBox[\"vlist\", \"TI\"]\) being the same for transposed matrix. Note that dual bases are \!\(\*
StyleBox[\"ulist\", \"TI\"]\) and Reverse[\!\(\*
StyleBox[\"vlist\", \"TI\"]\)].";


Options[JDData]={Fermatica`UseFermat->False};


JDData[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
evs=DeleteDuplicates@EValues[m],
us,
vs
},
us=JDTowers[m,#,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]&/@evs;
evs=Flatten[MapThread[ConstantArray,{evs,Length/@us}],1];
us=Flatten[us,1];
vs=Factor[Reverse/@PartitionByLengths[OInverse[Transpose[Flatten[us,1]],Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],Length/@us]];
Transpose[{evs,us,vs}]
]


JDecompose::usage="JDec[\!\(\*
StyleBox[\"m\", \"TI\"]\)] yields the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result is a list {\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"J\", \"TI\"]\)} where \!\(\*
StyleBox[\"t\", \"TI\"]\) is a similarity matrix and \!\(\*
StyleBox[\"J\", \"TI\"]\) is the Jordan canonical form of \!\(\*
StyleBox[\"m\", \"TI\"]\).";


JDecompose[m_?SquareMatrixQ]:=Module[{
evs=DeleteDuplicates@EValues[m],
jblist,id,
uslist
},
{jblist,uslist}=Transpose[Flatten[Function[ev,{bjf[ev,1,Length@#],#}&/@JDTowers[m,ev]]/@evs,1]];
{Transpose@Flatten[uslist,1],ArrayFlatten[DiagonalMatrix[id/@jblist]/.id->Identity]}
]


JDDataMod[m_?SquareMatrixQ,x_Symbol->poly_]:=Module[{
evs=DeleteDuplicates@EValuesMod[m,x->poly],
us,
vs
},
us=JDTowersMod[m,x->poly,#]&/@evs;
evs=Flatten[MapThread[ConstantArray,{evs,Length/@us}],1];
us=Flatten[us,1];
vs=Factor[Reverse/@PartitionByLengths[InverseMod[Transpose[Flatten[us,1]],x->poly],Length/@us]];
Transpose[{evs,us,vs}]
]


JDecomposition::usage="JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\)] yields the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result is a list {\!\(\*
StyleBox[\"b\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)} where \!\(\*
StyleBox[\"b\", \"TI\"]\) is a similarity matrix and \!\(\*
StyleBox[\"n\", \"TI\"]\) is the Jordan canonical form of \!\(\*
StyleBox[\"m\", \"TI\"]\). JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"l\", \"TI\"]\)] does the same, except that it puts \!\(\*
StyleBox[\"l\", \"TI\"]\) above diagonal instead of 1.";


JDecomposition[m_?SquareMatrixQ]:=Module[
{s,d,a,b,p,jc,n=Length@m},
Check[{s,a}=JordanDecomposition[m],Return[$Failed]];
s=Factor@s;
a=Simplify@Transform[m,s];
If[!JFormQ[a],Return[$Failed]];
(*Ugly hack to deal with Mathematica's bugs related to JordanDecomposition*)
d=DiagonalMatrix[FoldList[If[#2===0,1,#1/#2]&,1,Diagonal[a,1]]];s=ODot[s,d];a=Simplify@Transform[a,d];
{s,a}
]


JDecompositionData::usage="JDecompositionData[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives data for the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result has a form {{\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\),\!\(\*
StyleBox[\"ulist\", \"TI\"]\),\!\(\*
StyleBox[\"vlist\", \"TI\"]\)},...} where each element corresponds to Jordan cell with the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) , \!\(\*
StyleBox[\"ulist\", \"TI\"]\) being a Jordan chain vectors, starting from the eigenvectors, and \!\(\*
StyleBox[\"vlist\", \"TI\"]\) being the same for transposed matrix. Note that dual bases are \!\(\*
StyleBox[\"ulist\", \"TI\"]\) and Reverse[\!\(\*
StyleBox[\"vlist\", \"TI\"]\)].";


JDecompositionData[m_]:=Module[{
n=Length@m,
t,j,
inds,
sizes,
evals,
us,vs
},
{t,j}=JDecomposition[m];
inds=Flatten[{0,Position[Diagonal[j,1],0,{1}],n}];
sizes=Differences[inds];
Assert[n===Plus@@sizes];
evals=j[[#,#]]&/@Rest[inds];
us=PartitionByLengths[Transpose[t],sizes];
vs=Factor[Reverse/@PartitionByLengths[Inverse[t],sizes]];
(*Outer[ODot,Flatten[vs,1],Flatten[us,1],1](*supposed to be identity matrix*)*)
Transpose[{evals,us,vs}]
]


GaussSolve::usage="GaussSolve[eqs,vars] implements gauss method of the solution of linear equations. Option Continue\[Rule]True|False defines how the procedure proceeds when hitting the equation that can not be satisfied (like 1\[Equal]0). With Continue\[Rule]True such equation is simply neglected, and with Continue\[Rule]False the procedure immediately returns $Failed (i.e., no solution).";


GaussSolve::inconsistent="Inconsistent equation encountered.";


Options[GaussSolve]={Continue->True,Monitor->True};


GaussSolve[eqs_,vs_,OptionsPattern[]]:=Module[{sol1,res,ip=-1,i=0,l=Length@eqs,sf,vars=vs,cnt=TrueQ[OptionValue[Continue]],
monitor=OptionValue[Monitor]},
sf=Collect[#,vars,Together]&;
If[monitor,CMonitor,#&][
res=Catch[Fold[
(i++;If[monitor,CProgressPrint[ip,i,l]];Quiet[Check[
{sol1}=Quiet[Solve[0==sf[#2/.#1],vars],{Solve::svars}],
sol1={};If[cnt,Message[GaussSolve::inconsistent],Throw[$Failed]],
{Set::shape}],{Set::shape}];vars=DeleteCases[vars,Alternatives@@(First/@sol1)];Join[(#1->sf[#2/.sol1])&@@@#1,sol1])&,{},eqs]],
Overlay[{ProgressIndicator[i,{0,l}],"GS: "<>ToString[i]<>"/"<>ToString[l]},Alignment->Center],1];
res
]


todo["Implement GaussSolve for matrices. Or at least better version of NullSpace."]


NilpotentQ::usage="NilpotentQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is nilpotent.";
NilpotentQ[m_?SquareMatrixQ]:=Module[{x},Collect[CharacteristicPolynomial[m,x],x,Factor]===(-x)^Length@m]
NilpotentQ[_]=False;


DiagonalQ::usage="DiagonalQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is diagonal.";DiagonalQ[A_?SquareMatrixQ]:=MatchQ[Equal@@@Position[A,Except[0],{2},Heads->False],{True..}];
DiagonalQ[_]=False;


PolyQ::usage="PolyQ[expr,x] gives True if expr is a polynomial function of x.\nPolyQ[{a,b,...},x] gives True iff PolyQ[a,x]&&PolyQ[b,x]&&..=True.";
Module[{p},
PolyQ[expr_,x_]:=Catch[p[expr,x];True];

SetAttributes[p,Listable];
p[ex:(_Plus|_Times),x_]:=p[List@@ex,x];
p[Power[ex_,_Integer?Positive],x_]:=p[ex,x];
p[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


RatFuncQ::usage="RatFuncQ[expr,x] gives True if expr is a rational function of x.\nRatFuncQ[{a,b,...},x] gives True iff RatFuncQ[a,x]&&RatFuncQ[b,x]&&..=True.";
RatFuncQ[ds_?DSystemQ,x_]:=RatFuncQ[ds[x],x]
Module[{rf},
RatFuncQ[expr_,x_]:=Catch[rf[expr,x];True];

SetAttributes[rf,Listable];
rf[ex:(_Plus|_Times),x_]:=rf[List@@ex,x];
rf[Power[ex_,_Integer],x_]:=rf[ex,x];
rf[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


JFormQ::usage="JFormQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is a Jordan form.";
JFormQ[{{_}}]=True;
JFormQ[A_?SquareMatrixQ]:=Module[
{
d=Diagonal[A],
c1=DeleteDuplicates[Flatten[{Diagonal[A,#]&/@Range[2,Length@A-1],Diagonal[A,#]&/@Range[1-Length@A,-1]}]]==={0}
},
c1&&And@@(d[[#]]===d[[#+1]]&/@Flatten[Position[Diagonal[A,1],Except[0],{1},Heads->False]])
];
JFormQ[_]=False;


FuchsianQ::usage="FuchsianQ[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) has only simple poles in \!\(\*
StyleBox[\"x\", \"TI\"]\).\nNB: FuchsianQ may work incorrectly if there are notations.";


FuchsianQ[m_,x_]/;RatFuncQ[m,x]:=MatchQ[DenominatorsInfo[m,x],{{_,_?NonPositive}...}]


FuchsianQ[_]=False;


EFormQ::usage="EFormQ[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"\[Epsilon]\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is linear in \!\(\*
StyleBox[\"\[Epsilon]\", \"TI\"]\).";
EFormQ[ds_?DSystemQ,\[Epsilon]_]:=And@@(FreeQ[Factor[ds[#]/\[Epsilon]],\[Epsilon]]&/@Variables[ds])
EFormQ[m_,\[Epsilon]_]:=FreeQ[Factor[m/\[Epsilon]],\[Epsilon]]


TClosure::usage="TClosure[m_?MatrixQ] calculates transitive closure of the relation given by m.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";


Options[TClosure]={Print->False};


TClosure[m_?SquareMatrixQ,OptionsPattern[]]:=tclosure[m,1]


tclosure::usage="tclosure[m_,d:(1|0):1] calculates transitive closure of the relation given by m. If the second argument is 0, the relation is symmetrized.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";
tclosure[m_,d:(1|0):1,p_:Except[0]]:=Module[{paths,edges,newpaths},
paths={#->#&/@Range[Length@m]};(*vertices*)
edges=Complement[Rule@@@Position[m,p,{2},Heads->False],Join@@paths];
If[d===0,edges=DeleteDuplicates[Join[edges,Reverse/@edges]]];
AppendTo[paths,edges];
edges=Dispatch[edges];
While[{}!=(newpaths=Complement[DeleteDuplicates@Flatten[Thread[#1->ReplaceList[#2,edges]]&@@@Last@paths],Join@@paths]),
AppendTo[paths,newpaths]
];
ReplacePart[ConstantArray[0,Take[Dimensions@m,2]],List@@@Flatten[paths]->1]
]


TClosure[ds_?DSystemQ,OptionsPattern[]]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[tc===TClosure,
lc=Transpose[Values[ds[[]]],{3,1,2}];
tc=tclosure[lc,1,Except[{0..}]];
HistoryAddExtra[ds,{TClosure->tc},Print->OptionValue[Print]],If[OptionValue[Print],CPrint[Style["Read TClosure from extras.",Small]]]
];
tc
]


TClosure[as_Association]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
lc=Transpose[Values[ds[[]]],{3,1,2}];
tclosure[lc,1,Except[{0..}]]
]


SubsystemsIndices::usage="SubsystemsIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} with each element being the list of indices for the valid subsystem."


SubsystemsIndices[m_?SquareMatrixQ,tc:(True|False):False]:=SortBy[DeleteDuplicates[Flatten[Position[#,1,{1}]]&/@If[tc,m,TClosure[m]]],{Last@#,Length@#}&]


SubsystemsIndices[ds_?DSystemQ,tc:(False):False]:=SubsystemsIndices[TClosure[ds],True]


LargestSubsystemsIndices::usage="LargestSubsystemsIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} with each element being the list of indices for the valid largest subsystem."


LargestSubsystemsIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{ss=Reverse@SortBy[SubsystemsIndices[m,tc],Length],left=Range[Length@m],left1,res={}},
Do[If[left=!=(left1=Complement[left,ss[[i]]]),left=left1;PrependTo[res,ss[[i]]]],{i,Length@ss}];
res
]


LargestSubsystemsIndices[ds_?DSystemQ,tc:(False):False]:=LargestSubsystemsIndices[TClosure[ds],True]


EntangledBlocksIndices::usage="EntangledBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to lower block-triangular form. The partition indicates separate blocks. The order guarantees that dependent blocks appear earlier.";


EntangledBlocksIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{ss},
ss=SubsystemsIndices[m,tc];
Table[Complement@@Reverse[Take[ss,i]],{i,Length@ss}]]


EntangledBlocksIndices[ds_?DSystemQ,tc:(False):False]:=EntangledBlocksIndices[TClosure[ds],True]


OffDiagonalBlocksIndices::usage="OffDiagonalBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list of pairs {{{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}},\[Ellipsis]} such that each pair corresponds to the indices of the off-diagonal block. The order should be good for treating blocks with BlockTriangularToFuchsian.";


Options[OffDiagonalBlocksIndices]={Flatten->True,Sort->Row};
OffDiagonalBlocksIndices::sort="Option Sort\[Rule]`1` is not allowed. Using Sort\[Rule]Row.";


OffDiagonalBlocksIndices[m_?SquareMatrixQ,tc:(True|False):False,OptionsPattern[]]:=Module[{ss,eb,res},
ss=SubsystemsIndices[m,tc];
eb=Table[Complement@@Reverse[Take[ss,i]],{i,Length@ss}];
Switch[OptionValue[Sort],
Diagonal,
res=Table[If[SubsetQ[ss[[i]],eb[[i-j]]],eb[[{i,i-j}]],Unevaluated[Sequence[]]],{j,Length@ss},{i,j+1,Length@ss}],
Row,
res=Table[If[SubsetQ[ss[[i]],eb[[j]]],eb[[{i,j}]],Unevaluated[Sequence[]]],{i,Length@ss},{j,i-1,1,-1}],
_,
Message[OffDiagonalBlocksIndices::sort];res=Table[If[SubsetQ[ss[[i]],eb[[j]]],eb[[{i,j}]],Unevaluated[Sequence[]]],{i,Length@ss},{j,i-1,1,-1}]
]; 
If[OptionValue[Flatten],Flatten[res,1],res]
]


OffDiagonalBlocksIndices[ds_?DSystemQ,tc:(False):False,opts:OptionsPattern[]]:=OffDiagonalBlocksIndices[TClosure[ds],True,opts]


DiagonalBlocksIndices::usage="DiagonalBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to block-diagonal form. The partition indicates separate diagonal blocks.";


DiagonalBlocksIndices[m_]:=GatherBy[MapIndexed[{#2,Position[#,1,{1}]}&,tclosure[m,0]],Last][[All,All,1,1]]


DependentRowIndices::usage="DependentRowIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent rows";


DependentRowIndices[m_?SquareMatrixQ,rows_,tc:(True|False):False]:=Union@Flatten[Position[#,1,{1}]&/@If[tc,m,TClosure[m]][[Flatten[{rows}]]]]


DependentRowIndices[ds_?DSystemQ,rows_,tc:(False):False]:=DependentRowIndices[TClosure[ds],rows,True]


DependentColumnIndices::usage="DependentColumnIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent columns";


DependentColumnIndices[m_?SquareMatrixQ,args__]:=DependentRowIndices[Transpose[m],args]


DependentColumnIndices[ds_?DSystemQ,rows_,tc:(False):False]:=DependentColumnIndices[TClosure[ds],rows,True]


BlocksHierarchyIndices::usage="BlocksHierarchyIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"indices\", \"TI\"]\)] gives a hierarchy of blocks depending on \!\(\*
StyleBox[\"indices\", \"TI\"]\). it has the form of list {0\[Rule]{\!\(\*
StyleBox[\"block01\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"block02\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"...\", \"TI\"]\)},1\[Rule]{\!\(\*
StyleBox[\"block11\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"block12\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"...\", \"TI\"]\)},\[Ellipsis]}. \"0\" corresponds to the highest blocks, \"1\" \[LongDash] to the block immediately below the highest ones, etc.";


Options[BlocksHierarchyIndices]={DependentRowIndices->True};


BlocksHierarchyIndices[m_?SquareMatrixQ,span:({__Integer}|_Span):Span[1,All],tc:(True|False):False,OptionsPattern[]]:=Module[{cl,minds,blocks,levels,lb,i,j,high=spantolist[span,Length@m]},
If[tc,cl=m,cl=TClosure[m]];
If[OptionValue[DependentRowIndices],minds=DependentRowIndices[cl,high,True],minds=high];(*indices in the original matrix Thread[Range[Length@minds]\[Rule]minds] gives the rules*);
cl=cl[[minds,minds]](*tclosure of submatrix*);
blocks=EntangledBlocksIndices[cl];
lb=Length@blocks;
levels=ConstantArray[0,lb];
(cl=cl[[#,#]])&[First/@blocks];(*block-wise closure, should be lower-triangular*)
Do[If[cl[[i,j]]===1,levels[[j]]=Max[levels[[j]],levels[[i]]+1]],{i,lb,1,-1},{j,i-1}];
SortBy[GroupBy[Transpose[{levels,Replace[blocks,Thread[Range[Length@minds]->minds],{2}]}],First->Last]/.Association->List,First]
]


BlocksHierarchyIndices[ds_?DSystemQ,span_,tc:(False):False]:=BlocksHierarchyIndices[TClosure[ds],span,True]


CheckMerge::usage="CheckMerge[{\!\(\*SubscriptBox[
StyleBox[\"M\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"rg\", \"TI\"], \(1\)]\)},{\!\(\*SubscriptBox[
StyleBox[\"M\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"rg\", \"TI\"], \(2\)]\)},\[Ellipsis],\!\(\*
StyleBox[\"s\", \"TI\"]\):Automatic] merges submatrices \!\(\*SubscriptBox[
StyleBox[\"M\", \"TI\"], \(k\)]\) into one provided they do not contradict each other.  The range \!\(\*SubscriptBox[
StyleBox[\"rg\", \"TI\"], \(k\)]\) defines indices of the submatrix \!\(\*SubscriptBox[
StyleBox[\"M\", \"TI\"], \(k\)]\) in the resulting matrix, and \!\(\*
StyleBox[\"s\", \"TI\"]\) defines the size of the overall matrix.\n\
The range \!\(\*
StyleBox[\"rg\", \"TI\"]\) can be either of the form used to indicate parts (e.g., {1,3,4} or 2;;-1), or a pair of expressions of the same form (\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"3\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"4\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"3\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"5\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"3\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"4\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"3\", \"TI\"]\)\!\(\*
StyleBox[\";;\", \"TI\"]\)\!\(\*
StyleBox[\"5\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)\!\(\*
StyleBox[\";;\", \"TI\"]\)\!\(\*
StyleBox[\"5\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"3\", \"TI\"]\)\!\(\*
StyleBox[\";;\", \"TI\"]\)\!\(\*
StyleBox[\"5\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)).\n\
The size \!\(\*
StyleBox[\"s\", \"TI\"]\) can be either Automatic, or \!\(\*
StyleBox[\"nrc\", \"TI\"]\), or \!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[\"nr\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"nc\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)";


Options[CheckMerge]={Undefined->0,Check->SameQ};
CheckMerge::dim="Can not calculate the size of the resulting matrix.";
CheckMerge::dims="Dimensions of some matrices do not match the embedding ranges.";
CheckMerge::check="Submatrices are inconsistent.";
CheckMerge[parts:({_?MatrixQ,{___Integer}|_Span|{{___Integer}|_Span,{___Integer}|_Span}}..),s:(Automatic|_Integer|{_Integer,_Integer}):Automatic,OptionsPattern[]]:=Module[
{Mlist,rlist,dims,Mres,check=OptionValue[Check]},
{Mlist,rlist}=Transpose[{parts}];
rlist=Replace[rlist,rl:{___Integer}|_Span:>{rl,rl},{1}];
If[s===Automatic,
(*We can define dimensions of the resulting matrix only if there are no spans with arguments being negative integers or All*)
If[
FreeQ[rlist,Span[_,All|_?Negative]|Span[_?Negative,_]],
dims=Max[Last/@#]&/@Transpose[rlist],Message[CheckMerge::dim];Return[$Failed]]
,
dims=Replace[s,{n_Integer:>{n,n}}]
];
rlist=Replace[Transpose[{#,dims}],{{Span[a_Integer,b_Integer],l_}:>Range[Mod[a+l+1,l+1],Mod[b+l+1,l+1]],{Span[a_Integer,All],l_}:>Range[Mod[a+l+1,l+1],l],{list_,l_}:>list},{1}]&/@rlist;
(*Check the consistency of Subscript[M, k] and Subscript[r, k]*)
If[Dimensions/@Mlist=!=Map[Length,rlist,{2}],Message[CheckMerge::dims];Return[$Failed]];
Mres=ConstantArray[Undefined,dims];
Mres=Catch[
MapThread[(Mres[[Sequence@@#1]]=MapThread[If[check[#1,#2]||#1===Undefined,#2,Throw[$Failed]]&,{Mres[[Sequence@@#1]],#2},2];)&,{rlist,Mlist}];
Replace[Mres,Undefined->OptionValue[Undefined],{2}]
]
]


RelevantIndices::usage="Given a transformation \!\(\*
StyleBox[\"t\", \"TI\"]\), RelevantIndices[\!\(\*
StyleBox[\"t\", \"TI\"]\)] gives a list of indices where \!\(\*
StyleBox[\"t\", \"TI\"]\) differs from identity matrix."


RelevantIndices[t_?SquareMatrixQ]:=Flatten[Union[Position[#,Except[{0..}],{1},Heads->False],Position[Transpose@#,Except[{0..}],{1},Heads->False]]&[t-IdentityMatrix[Length@t]]]


$LibraUseFermat::error="$LibraUseFermat can be set either to False or to True. The latter case requires Fermatica\` to be in the $ContextPath.";
$LibraUseFermat/:Set[$LibraUseFermat,val_]:=If[(val===False)||(val===True&&MemberQ[$ContextPath,"Fermatica`"]),OwnValues[$LibraUseFermat]={HoldPattern[$LibraUseFermat]:>val};val,Message[$LibraUseFermat::error];$LibraUseFermat];


OQuolyMod::usage="OQuolyMod[quoly,poly,x] gives the \"remainder\" of the rational function quoly when divided by poly. First capital 'O' stands for 'optimized'.";


Options[OQuolyMod]={Fermatica`UseFermat->False};


OQuolyMod[quoly_,poly:Except[_Rule|{___Rule}],x_Symbol,opts:OptionsPattern[]]:=OQuolyMod[quoly,x->poly,opts]


OQuolyMod[quoly_,list_List,opts:OptionsPattern[]]:=Fold[OQuolyMod[#1,#2,opts]&,quoly,list];
OQuolyMod[quoly_,x_Symbol->poly_,OptionsPattern[]]:=If[$LibraUseFermat&&OptionValue[Fermatica`UseFermat],
Replace[CheckAbort[Fermatica`FQuolyMod[quoly,x->poly],$Failed],$Failed:>(CPrint["OQuolyMod: resorting to Mathematica\[Ellipsis]"];QuolyMod[quoly,x->poly])],
QuolyMod[quoly,x->poly]]


done["Make better version of QuolyMod to deal with several successive moddings wrt to different polynomials and variables."];


ODot::usage="ODot[m1,m2,...] is an optimized dot product."


Options[ODot]={Fermatica`UseFermat->False,Simplify->Together};


ODot[exs__,OptionsPattern[]]:=If[$LibraUseFermat&&OptionValue[Fermatica`UseFermat],
Replace[CheckAbort[Fermatica`FDot[exs],$Failed],$Failed:>(CPrint["ODot: resorting to Mathematica\[Ellipsis]"];ODot[exs,Fermatica`UseFermat->False,Simplify->Together])],
If[TrueQ[Not[OptionValue[Simplify]]],Identity,OptionValue[Simplify]]@Dot[exs]];


ODet::usage="ODet[m1] is an optimized version of Det."


Options[ODet]={Fermatica`UseFermat->False};


ODet[m_?SquareMatrixQ,OptionsPattern[]]:=If[$LibraUseFermat&&OptionValue[Fermatica`UseFermat],
Replace[CheckAbort[Fermatica`FDet[m],$Failed],$Failed:>(CPrint["ODet: resorting to Mathematica\[Ellipsis]"];Det[m])],
Det[m]];


OKer::usage="OKer[m1] is an optimized version of NullSpace."


Options[OKer]={Fermatica`UseFermat->False};


OKer[m_?MatrixQ,OptionsPattern[]]:=
Replace[If[$LibraUseFermat&&OptionValue[Fermatica`UseFermat],
CheckAbort[Fermatica`FKer[m],CPrint["ODet: resorting to Mathematica\[Ellipsis]"];ker[m]],
ker[m]],
{{0..}}->{}];


OInverse::usage="OInverse[m] is an optimized version of Inverse[m] for block-triangular matrices.";


Options[OInverse]={Print->False,Fermatica`UseFermat->False};


OInverse[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{s=TClosure[m],print=TrueQ@OptionValue[Print],diag,dep,mi=IdentityMatrix[Length@m],stat=""},
(*invert diagonal*)
If[$LibraUseFermat&&OptionValue[Fermatica`UseFermat],Return[Fermatica`FInverse[m]]];
If[print,CMonitor,#&][
stat="Finding diagonal blocks\[Ellipsis]";
If[print,CWrite["\n"];CWrite[stat]];
diag=EntangledBlocksIndices[s,True];
(stat="Inverting diagonal elements with indices "<>ToString[#];
If[print,CWrite["\n"];CWrite[stat]];
mi[[#,#]]=Together[Inverse[#]]&@m[[#,#]])&/@diag;
(dep=Complement[DependentRowIndices[s,#,True],#];stat="Inverting off-diagonal elements "<>ToString[dep]<>" on rows "<>ToString[#];
If[print,CWrite["\n"];CWrite[stat]];
mi[[#,dep]]=-ODot[mi[[#,#]],m[[#,dep]],mi[[dep,dep]],Fermatica`UseFermat->False])&/@diag;
,
stat];
Return[mi]
]


OMatrixExp::usage="OMatrixExp[A] gives the matrix exponent using resolvent. Should be faster for block-triangular matrices than MatrixExp[A].";


Options[OMatrixExp]={Fermatica`UseFermat->False,EValues->Automatic};


OMatrixExp[A_,OptionsPattern[]]:=Module[{n=Length@A,resolvent,a,statusline="",evs,resexp},
CMonitor[
statusline="Calculating eigenvalues...";
evs=DeleteDuplicates@Replace[OptionValue[EValues],Automatic:>EValues[A]];
statusline="Calculating resolvent...";
resolvent=OInverse[IdentityMatrix[n]*a-A,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
resexp=Exp[a]*resolvent;
statusline="Calculating residues...";
Plus@@((statusline="Calculating residue at "<>ToString[#];SeriesCoefficient[resexp,{a,#,-1}])&/@evs)
,
statusline]
]


Unprotect[Series];
Series[expr_,{x_,x0_,n_Integer}]/;FreeQ[expr,x]:= expr+SeriesData[x,x0,{},n+1,n+1,1];
Series[expr_List,{x_,x0_,n_Integer}]:=Map[Series[#,{x,x0,n}]&,expr]
Protect[Series];
todo["NB: Series redefined!"]


SeriesCoefficients::usage="SeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 up to  (x-x0)^n return the list of these terms";


SeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,series,n},
series=Series[A,{x,x0,k}];
n=LeadingOrder[series,{x,x0}];
SeriesCoefficient[series,{x,x0,#}]&/@Range[n,k]
]


LeadingSeries::usage="LeadingSeries[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeries[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[A+SeriesData[x,x0,{},\[Infinity],\[Infinity],1]]];
Series[A,{x,x0,n+k}]
]
LeadingSeries[A_,{x_Symbol,\[Infinity],k_}]:=Module[
{i,n=LeadingOrder[A,{x,\[Infinity]}]},
If[n==\[Infinity],Return[A+SeriesData[x,\[Infinity],{},\[Infinity],\[Infinity],1]]];
Series[A,{x,\[Infinity],n+k}]
]


LeadingSeriesCoefficient::usage="LeadingSeriesCoefficient[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeriesCoefficient[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[0]];
SeriesCoefficient[A,{x,x0,n+k}]
]


LeadingSeriesCoefficients::usage="LeadingSeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion and return the list of these terms";


LeadingSeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}],series},
If[n==\[Infinity],Return[0]];
series=Series[A,{x,x0,n+k}];
series=SeriesCoefficient[series,{x,x0,#}]&/@Range[n,n+k];
series
]


LeadingOrder::usage="LeadingOrder[expr,{x,x0}] gives the leading order of expansion in x.\nLeadingOrder[expr,poly,x] returns the leading order of the polynomial poly whic can be factorised for expr.";


(*Deleted 11.06.2019*)(*Modified 18.05.2019*)(*Added 18.05.2019*)LeadingOrder[expr_List,a__]:=Min[LeadingOrder[#,a]&/@expr](*/Added 18.05.2019*)
LeadingOrder[expr_,{x_Symbol,x0_},opts:OptionsPattern[]]:=(*Added 18.05.2019*)lorder[expr,{x,x0}](*/Added 18.05.2019*)(*(*Deleted 18.05.2019*)Min[lorder[expr,{x,x0}]](*/Deleted 18.05.2019*)*)(*/Modified 18.05.2019*)


lorder[0,{x_Symbol,x0_}]=\[Infinity];
lorder[expr_,{x_Symbol,x0_}]:=lorder[expr/.{x->x0+1/x},{x,\[Infinity]}];
lorder[expr_,{x_Symbol,\[Infinity]}]:=Exponent[Denominator[#],x]-Exponent[Numerator[#],x]&[Together[expr]];
lorder[expr_SeriesData,{x_Symbol,x0_}]/;MatchQ[Take[List@@expr,2],{x,x0}]:=expr[[4]];


SeriesRulesMod::usage="SeriesRulesMod[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)}] gives a list of the form {{\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"k\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)}\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[
RowBox[{\"k\", \"+\", \"1\"}], \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\[Ellipsis],{\!\(\*
StyleBox[\"n\", \"TI\"]\)}\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)}, such that each \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a polynomial with deg(\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\))<deg(\!\(\*
StyleBox[\"p\", \"TI\"]\)) and LeadingOrderMod[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*SubsuperscriptBox[\(\[Sum]\), 
StyleBox[
RowBox[{\"i\", \"=\", \"k\"}], \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[
StyleBox[\"p\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)]>\!\(\*
StyleBox[\"n\", \"TI\"]\)."


SeriesRulesMod[ex_,{x_->den_,o_}]:=Module[{lo,tmp,rem,res={}},
If[!(RatFuncQ[ex,x]||PolyQ[den,x]),Return[$Failed]];
lo=LeadingOrderMod[ex,x->den];
If[o<lo,Return[{{o}->0*ex}]];
tmp=Together[ex/den^lo];
Do[
rem=QuolyMod[tmp,x->den];
AppendTo[res,rem];
tmp=Together[(tmp-rem)/den];
If[tmp===0,res=PadRight[res,o-lo+1];Break[]]
,{i,lo,o}];
Thread[List/@(lo-1+Range[Length@res])->(res)]
]


SeriesRulesMod[ex_,{x_,o_}]:=SeriesRulesMod[ex,{x->(x/.$LibraNotations),o}]


SeriesCoefficientMod::usage="SeriesCoefficientMod[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\)\[Rule]\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)}] gives the coefficient \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) in the expansion \!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\[Sum]\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[
StyleBox[\"p\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)."


SeriesCoefficientMod[ex_,{x_->den_,o_}]:=Replace[Cases[SeriesRulesMod[ex,{x->den,o}],({o}->c_):>c,1,1],{{c_}:>c,{}->Indeterminate}]


SeriesCoefficientMod[ex_,{x_,o_}]:=SeriesCoefficientMod[ex,{x->(x/.$LibraNotations),o}]


SeriesSolutionData::usage="SeriesSolutionData[M,{x,x0}] constructs data for generalized power series solution of the system \[PartialD]U=M\[InvisibleComma]U.\nGeneralized form: SeriesSolutionData[M,{x,y(x),n}].\n    \[FilledSmallCircle] M should be rational.\n    \[FilledSmallCircle] M should be Fuchsian at x=x0.\n    \[FilledSmallCircle] Residue A at x=x0 should be free of resonances.\n    \[FilledSmallCircle] SeriesSolutionData returns data U with the asymptotics (x-x0)^A.\nReturned data has the form of a list with each element having the form {\[Lambda],\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\),s,{\!\(\*SubscriptBox[\(T\), \(1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]T\), \(s\)]\)}&,C[\[Lambda],0..\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\)]}.\n\
NB: Option UseFermat can be either True, False or three-digit binary number \"\!\(\*
StyleBox[\"abc\",\nFontSlant->\"Italic\"]\)\", with \!\(\*
StyleBox[\"a\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"b\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"c\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"1\",\nFontSlant->\"Italic\"]\) corresponding to using Fermat at the calculation of resolvent (with OInverse), in OInverse and ODot, respectively.";
SeriesSolutionData::notrat="Matrix received is not rational in `1`.";
SeriesSolutionData::ppr="Positive Poincare rank at `1`=`2`.";
SeriesSolutionData::res="Resonant eigenvalues at `1`=`2`.";


Options[SeriesSolutionData]={Monitor->True,Fermatica`UseFermat->False}


(*Shortcuts*)
SeriesSolutionData[M_?SquareMatrixQ,{x_,\[Infinity]},OptionsPattern[]]:=
Module[{z},ssd[-x^2M/.{x->1/z},z,1/x,OptionValue[Fermatica`UseFermat],OptionValue[Monitor]]];
SeriesSolutionData[M_?SquareMatrixQ,{x_,x0_},OptionsPattern[]]/;FreeQ[x0,x]:=
Module[{z},ssd[M/.{x->z+x0},z,x-x0,OptionValue[Fermatica`UseFermat],OptionValue[Monitor]]]; 
SeriesSolutionData[M_?SquareMatrixQ,{x_,y_},OptionsPattern[]]:=
Module[{z,xvar},xvar=x/.First[Solve[z==y,x]];ssd[M D[xvar,z]/.{x->xvar},z,y,OptionValue[Fermatica`UseFermat],OptionValue[Monitor]]];


(*fermat --- binary number for using Fermat in several instances.*)
ssd[M_?SquareMatrixQ,y_,yv_,fermat:(_String|_Integer|False|None|True|All):False,mon:(True|False):True]:=Module[
{pr,A,res,T,JF,y2A,p,evs,fp,Q,poles,dens,qs,Bs,\[Lambda],tmp,
Rcoefs,rcoefs,n,Rdata,ly,
statusline="",secondline="",fflags=Replace[IntegerDigits[Replace[fermat,{False|None->0,True|All->7,f_String:>FromDigits[f,2]}],2,3],{1->True,0->False},{1}]},
CMonitor[
CWrite[statusline="Finding matrix residue..."];CWrite["\n"];
If[!RatFuncQ[M,y],Message[SeriesSolutionData::notrat,yv];Return[$Failed]];
If[(pr=PoincareRank[M,{y,0}])>0,Message[SeriesSolutionData::ppr,yv,0];Return[$Failed]];
A=SeriesCoefficient[M,{y,0,-1}];
res=OInverse[\[Lambda]*IdentityMatrix[Length@A]-A,Fermatica`UseFermat->fflags[[1]]];(*resolvent*)
CWrite[statusline="Finding leading expansion terms..."];CWrite["\n"];
evs=DeleteDuplicates@EValues[A];
If[MemberQ[Factor[Subtract@@@Subsets[evs,{2}]],_Integer],Message[SeriesSolutionData::res,yv,0];Return[$Failed]];
fp={#1,-LeadingOrder[res,{\[Lambda],#}]-1}&/@evs;
If[mon,secondline="\nLeading terms: "<>StringReplace[StringRiffle[ToString[yv^#1 Log[yv]^#2,InputForm]&@@@fp,","]," "->""]];
CWrite[statusline="Evaluating matrix exponent..."];CWrite["\n"];(*y2A stands for y^A*)
y2A=Plus@@(Function[a,statusline="Evaluating matrix exponent: calculating residue at "<>ToString[a];
Map[Plus@@MapIndexed[p[a,First@#2-1]*#1&,CoefficientList[#,ly]]&,SeriesCoefficient[res*Exp[(\[Lambda]-a)*ly],{\[Lambda],a,-1}],{2}]]/@evs);(*Now we find common denominator Q, Eq(6) of DESS paper*)
CWrite[statusline="Getting rid  of denominators..."];CWrite["\n"];
(*poles=DeleteCases[PolesPosition[M,y],\[Infinity]|0];
Q=Times@@((y-#)^(1+PoincareRank[M,{y,#}])&/@poles);*)
Q=1;
While[{}=!=(dens=Denominators[Together[M Q],y]),
Q*=PolynomialLCM[Sequence@@dens,y];
];
Q=Numerator@Together[Q/y];
qs=CoefficientList[Q,y];
Bs=Coefficient[Factor[Q(y M-\[Lambda] IdentityMatrix[Length@M])],y,#]&/@Range[0,Length[qs]-1];
CWrite[statusline="Evaluating recurrence coefficients..."];CWrite["\n"];
Rcoefs=Function[{\[Alpha],k},Evaluate@MapThread[bjf[#1,#2*IdentityMatrix[Length@M],k+1]&,{MapIndexed[(#/.{\[Lambda]->\[Alpha]+n-First[#2]+1})&,Bs],-qs},1](*Function[n,]*)];
Rdata=Function[{\[Alpha],k},CWrite[statusline="Evaluating recurrence coefficients for power "<>ToString[\[Alpha]]<>"..."];CWrite["\n"];
rcoefs=Rcoefs[\[Alpha],k](*[n]*);
tmp=OInverse[-rcoefs[[1]],Fermatica`UseFermat->fflags[[2]]];(*may be improved by dedicated calculation of inverse of bjf with 
off-diagonal terms calculated by iterative multiplication by -A^(-1)B*)
{\[Alpha],k,Length@rcoefs-1(*=s from the paper*),Function@@({ODot[tmp,#,Fermatica`UseFermat->fflags[[3]]]&/@Rest[rcoefs]/.n:>Slot[1]}),Flatten[#!*Coefficient[y2A,p[\[Alpha],#]]&/@Range[0,k],1]}
]@@@fp
,statusline<>secondline,1];
Rdata]


ConstructSeriesSolution::usage="ConstructSeriesSolution[rdata_,{x_,o_}] makes a series solution out of rdata (see ?SeriesSolutionData for how to get rdata).\n    o \[LongDash] order in x.\nIf f=ConstructSeriesSolution[SeriesSolutionData[M,{x,0}],{x,o}], then one may check the equation by Factor[D[y,x]-M.y].\nOptions:\n    O\[Rule]y|True|False:False \[LongDash] whether to add O[x]^o\n    Split\[Rule]True|False:False determines whether to split contribution of different fractional powers. \n    Hold->f|False:False -- whether to wrap the leading powers. If f\[NotEqual]False is given, f[lp] is used instead of \!\(\*SuperscriptBox[\(x\), \(lp\)]\).\nSince Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended. Instead, if Split\[Rule]False, use O\[Rule]y to replace fractional power of x with those of y. If option Split\[Rule]True is used,  ConstructSeriesSolution returns the result as a rectangular matrix n\[Times](n*|S|), with each square n\[Times]n block corresponding to a specific fractional power.";
ConstructSeriesSolution::mixed="Since Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended.";


Options[ConstructSeriesSolution]={O->False,Split->False,Simplify->Factor};


ConstructSeriesSolution[rdata_,{x_,o_}, OptionsPattern[]]:=Module[{zero,c,n,sdata,sf=OptionValue[Simplify],remainder,Oo=OptionValue[O],Orule,So=TrueQ@OptionValue[Split],z},
If[TrueQ@Oo&&!So,Message[ConstructSeriesSolution::mixed]];
Orule=Replace[Oo,{True|False->{z->x},y_:>{z->y}}];
remainder=If[TrueQ@Not[Oo],0,x^o O[x]];
sdata=(Function[{lp,llp,M,coefs,init},
zero=0*init;(*\[DoubleLongLeftArrow] this is to avoid strange behaviour for empty series*)
c[lp,0]=init;c[lp,n_Integer?Positive]:=(Quiet[Unset[c[n-M-1]]];(*clean up*)
c[lp,n]=sf@Sum[Dot[coefs[n][[m]],c[lp,n-m]],{m,Min[M,n]}]);
z^lp*(Dot[((Log[x]^#/#!)&/@Range[0,llp]),(Partition[#,Length@#/(llp+1)]&[zero+Sum[c[lp,n]*x^n,{n,0,o}]])]+remainder)
]@@@rdata)/.Orule;
If[So,ArrayFlatten[{sdata}],Plus@@sdata]
]


PexpExpansion::usage="PexpExpansion[{M,n},x] gives the perturbative expansion of the \!\(\*FormBox[\(Pexp[\[Integral]dx\\\ M]\),
TraditionalForm]\) in \!\(\*FormBox[\(M\),
TraditionalForm]\) up to the term \!\(\*FormBox[\(\(\[Proportional]\)\*SuperscriptBox[\(M\), \(n\)]\),
TraditionalForm]\) via the iterated integrals \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary. The result is the list of successive terms."


Options[PexpExpansion]={Split->True};


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol,OptionsPattern[]]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
CMonitor[
res=NestList[Function[pr,i++;CWrite["."];t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x]:>II[{#,a},x]})&/@p)],IdentityMatrix[Length@M]*II[{},x],n],
i,0,"Pexp"];
If[TrueQ[!OptionValue[Split]],res=Plus@@res];
res
]


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol,x0:Except[_Rule],OptionsPattern[]]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
CMonitor[
res=NestList[Function[pr,i++;
CWrite["."];t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x,x0]:>II[{#,a},x,x0]})&/@p)],IdentityMatrix[Length@M]*II[{},x,x0],n],
i,0,"Pexp"]
]


InsertionPositions[m_Integer,n_Integer]:=Module[{ss,range},
range=Range[n]-1;
#-range&/@Subsets[Range[m+n],{n}]
]
ShuffleProductNestList[l_,list_List,n_Integer]:=Module[{len=Length@list,k},
Table[Insert[list,l,List/@#]&/@InsertionPositions[len,k],{k,0,n}]
]


todo["InsertionPositions can probably be written in C"];


FactorLeadingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{ls:(l)..,b1:Except[l],bs___},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Prepend[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{(l)..,Except[l],___},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


FactorTrailingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{bs___,b1:Except[l],ls:(l)..},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Append[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{___,Except[l],(l)..},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


GetL::usage="GetL[M,T,{x,y(x)},cs] calculates the adapter for coefficients cs.";


todo["GetL: make UseFermat optional, not obligatory."];


GetL[M_?SquareMatrixQ,T_?SquareMatrixQ,{x_,y_},cs:{{_,_,0}..}]:=Module[
{sdata,lps,mp,Uscs,Tscs,Li,i=0,l},
(*Assumption on input 
1. each cs has zeroth third element (power of log)
2. M has no *)
sdata=SeriesSolutionData[M,{x,y}];lps=sdata[[All,1]];
mp={#1,#2,LeadingOrderMod[T[[#1]],x->y]}&@@@cs;
mp=First[Cases[Function[lp,{#1,lp,Expand[#2-lp],#3}]/@lps,{_,_,_Integer,_}]]&@@@mp;
i=0;l=Length[sdata];
CMonitor[Uscs=Function[{lp,llp,Mm,coefs,init},
Module[{c,o},
o=Max[Cases[mp,{_,lp,lo_,lot_}:>lo-lot]];
c[lp,0]=init;c[lp,n_Integer?Positive]:=(Quiet[Unset[c[n-Mm-1]]];(*clean up*)
c[lp,n]=Together@Sum[Fermatica`FDotBig[coefs[n][[m]],c[lp,n-m]],{m,Min[Mm,n]}]);
Table[i+=1/(o+1);c[lp,n],{n,0,o}]
]]@@@sdata,
Overlay[{ProgressIndicator[i,{0,l}],"U"},Alignment->Center]];
i=0;l=Length[mp];
CMonitor[
Tscs=Function[{k,lp,lo,lot},i++;{Position[lps,lp,{1}][[1,1]],Table[SeriesCoefficientMod[T[[k]],{x->y,n}],{n,lot,lo}]}]@@@mp,
Overlay[{ProgressIndicator[i,{0,l}],"T"},Alignment->Center]];
i=0;
CMonitor[Li=Function[{fpindex,Trow},i++;
Factor[Plus@@MapThread[Dot,{Trow,Reverse[Uscs[[fpindex]][[;;Length[Trow],;;l]]]}]]]@@@Tscs;,Overlay[{ProgressIndicator[i,{0,l}],"Li"},Alignment->Center]];
Fermatica`FInverse[Li]
]


GetLcs::usage="GetLcs[Mf,T,{x,y(x)}] returns {L,cs} pair.";
GetLcs::err="Matrix is not rational or not normalized Fuchsian at the expansion point.";


Options[GetLcs]={Fermatica`UseFermat->False }; 


GetLcs[ds_?DSystemQ,T_?SquareMatrixQ,{x_,at_,extra_Integer:0},target:("Lcs"|"cs"):"Lcs",opts:OptionsPattern[]]:=GetLcs[ds[x],T,{x,at,extra},target,opts]


GetLcs[Mf_?SquareMatrixQ,T_?SquareMatrixQ,{x_,at_,extra_Integer:0},target:("Lcs"|"cs"):"Lcs",OptionsPattern[]]:=Module[{inds,offset=0,cs,len,
pb=0,fflags=Replace[IntegerDigits[Replace[OptionValue[Fermatica`UseFermat],{False|None->0,True|All->63,f_String:>FromDigits[f,2]}],2,6],{1->True,0->False},{1}]},
Which[
target==="Lcs",
getlcs[Mf,T,{x,at,extra},fflags,True],

target==="cs",
len=Length@Mf;
CMonitor[Flatten[Function[ii,(cs=MapAt[ii[[#]]&,getlcs[Mf[[ii,ii]],T[[ii,ii]],{x,at,extra},fflags,False],{All,1}];pb+=Length@ii;cs)]/@EntangledBlocksIndices[TClosure[Mf]+TClosure[T]],1],
Overlay[{ProgressIndicator[pb,{0,len}],"cs:"<>ToString[pb]<>"/"<>ToString[len]},Alignment->Center],1]
]
];


getlcs[Mf_,T_,{x_,at_,extra_Integer},fflags_,Lf:(True|False)(*\[DoubleLongLeftArrow] whether to return L*)]:=Module[ 
{n=Length@Mf,mf, 
t,tlo,tcl,listdot,id,mcl,
x2z,z2x,z,A,sdata,r(*multiplicity*),
zero,c,cl,cs={},Li={},
t1,t2,t3,
ebi,bi,k,l,
i,j,sort,status=""
},
ebi=EntangledBlocksIndices[Mf];
If[FreeQ[at,x],x2z=x->at+z,{x2z}=First[Solve[at==z,x]]];
{z2x}=First[Solve[Equal@@x2z,z]];
t=T/.x2z;
Check[sdata=SeriesSolutionData[Mf,{x,Last[z2x]},Fermatica`UseFermat->FromDigits[Boole[fflags[[;;3]]],2]],Message[GetLcs::err];Return[$Failed]];
tlo=LeadingOrder[t,{z,0}];
tcl[]={};tcl[n_]:=Module[{known=tcl[],l},
l=Length[known];If[n>l,known=Join[known,SeriesCoefficient[t,{z,0,#}]&/@(Range[l,n-1]+tlo)];tcl[]=known];
Take[known,n]
];(* <-- tcl is a lazy infinite list of series coefficients, starting from the leading one*)
listdot[list1_,list2_]:=Inner[ODot[First@#1,First@#2,Fermatica`UseFermat->fflags[[4]]]&,id/@list1,id/@Reverse[list2]];
CMonitor[
Function[{lp,llp,M,coefs,init},
(*multiplicity is the rank of init*)
status="Working on fractionality "<>ToString[lp]<>"...";
r=MatrixRank[init];
zero=0*init;(*\[DoubleLongLeftArrow] this is to avoid problems with M=0 below*)
(*cl --- list of expansion coefficients*)
cl[]={init};
cl[n_]:=Module[{known=cl[],l,k},
l=Length[known];
Do[known=Append[known,Together[zero+Sum[ODot[coefs[k][[m]],known[[-m]],Fermatica`UseFermat->fflags[[5]]],{m,Min[Length[known],M]}]]],{k,l,n-1}];
cl[]=known;
Take[known,n]
];
(*here we have to pick both suitable cs and the rows of L^(-1), and preferably do it in the most economic way*)
i=0;
mcl={};
j=-1;
While[j<extra,
If[mcl=!={}&&MatrixRank[ArrayFlatten[List/@mcl]]>=r,j++];
i++;
mcl=Append[mcl,listdot[Libra`Private`bjf[#,0,llp+1]&/@tcl[i],cl[i]]];
];
(* we prepend each row with  logpower,index, power*)
mcl=SortBy[Flatten[MapIndexed[Function[{row,i},{k,l}=QuotientRemainder[Last[i]-1,n];
{bi}=FirstPosition[ebi,_?(MemberQ[#,l+1]&),$Failed,{1}];{{bi,k,First@i-1+tlo,l},row}(*{Insert[QuotientRemainder[Last[i]-1,n],First@i-1+tlo,2],row}*)],mcl,{2}],1],First];
t1=PickBasisIndices[Last/@mcl];
cs=Join[cs,{#4+1,#3+lp,#2}&@@@mcl[[t1,1]]];
Li=Join[Li,mcl[[t1,2]]]
(*cs=Join[cs,{#3+1,#2+lp,#1}&@@@mcl[[t1,1]]];
Li=Join[Li,mcl[[t1,2]]];*)
]@@@sdata,
status,1];
sort=Ordering[cs];
If[Lf,
{OInverse[Li[[sort]],Fermatica`UseFermat->fflags[[6]]],cs[[sort]]},
cs[[sort]]]
]


SpotCoefficients::usage="SpotCoefficients[Mf,T,\[Epsilon],{x,y(x),o}] tries to find the coefficients in the asymptotic expansion of the initial integrals which are sufficient for fixing boundary conditions. The output is a list with each element being of the form {y(x),i,\[Alpha],k}. It stands for the coefficient \!\(\*SuperscriptBox[\(y\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(ln\), \(k\)]\)y in i-th integral.";
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]/;FreeQ[y,x]:=SpotCoefficients[Mf,T,\[Epsilon],{x,x-y,o}]
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]:=Module[{rdata,TUr,z,zrule,ii,p,powers,tmp,cs=ConstantArray[0,Length@Mf]},
zrule=First[Solve[z==y,x]];
CMonitor[
MapIndexed[(ii=#;CWrite[ToString[ii]];
rdata=SeriesSolutionData[Factor[Mf[[ii,ii]]],{x,y}];TUr=(Plus@@Partition[#1,Length[ii]]&)/@Map[Collect[Expand[#1 p[0,0]]/. {Log[z]->p[0,1],z->p[1,0]}//. {p[a_,b_]^c_:>p[a c,b c],p[a_,b_] p[c_,d_]:>p[a+c,b+d]},_p,Factor]&,Normal[(T[[ii,ii]]/. zrule).ConstructSeriesSolution[rdata,{z,o},Split->True,O->True]],{2}];powers={};tmp={};MapIndexed[Function[{row,i},Module[{ps=SortBy[Union[Cases[row,_p,All]],First[#/.\[Epsilon]->0]&]},Catch[((tmp=Append[tmp,Factor[Coefficient[row,#1]]];If[MatrixRank[tmp]>=First[i],AppendTo[powers,#1];Throw[0]];tmp=Most[tmp])&)/@ps;
CPrint["Could not find suitable coefficients for block ",ii," Aborting..."];
Abort[]]]],TUr];cs[[ii]]=MapIndexed[{y,ii[[First[#2]]],Sequence@@#1}&,powers];
)&,EntangledBlocksIndices[TClosure[Mf]+TClosure[T]]],
ii];
cs
]


DiffMod::usage="DiffMod[ex,x,{y\[Rule]p(x,y),z\[Rule]q(x,z),...}] differentiates with respect to x taking into account the notations {y\[Rule]p(x,y),z\[Rule]q(x,z),...}."


DiffMod[ex_,x_Symbol,notas:{__Rule}]:=Internal`InheritedBlock[{D},
SetOptions[D,NonConstants->First/@notas];
OQuolyMod[D[ex,x]/.First[Solve[0==D[Last/@notas,x],D[First/@notas,x]]],notas]]
DiffMod[ex_,x_Symbol,nota_Rule]:=DiffMod[ex,x,{nota}]
DiffMod[ex_,x_Symbol,{}]:=D[ex,x];
DiffMod[ex_,x_Symbol]:=D[ex,x];


ToOneDE::usage="ToOneDE[M,x,i] constructs one higher-order differential equation for the i-th master.\nIt returns the list of the coefficients {Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]} in front of the consecutive orders of derivatives, so that the equation has the form Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0.";


ToOneDE[M_,x_,i_:1]:=Module[
{ders,Mk=IdentityMatrix[Length@M]},
ders={Mk[[i]]};
While[MatrixRank[ders]==Length@ders,
PrintTemporary[Length@ders];
(*Add one more row*)
Mk=Factor[D[Mk,x]+Mk.M];
AppendTo[ders,Mk[[i]]];
];
First[OKer[Transpose[ders]]]
]


ToCompanionDS::usage="ToCompanionDS[{Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]}] constructs the companion matrix Subscript[M, c] out of the coefficients of differential equation Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0. This matrix enters the right-hand side of the differential system \!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]F\)=Subscript[M, c]F, where F=(f,f',\[Ellipsis],f^(n))^T.";


ToCompanionDS[coefs_List]:=Append[Rest@IdentityMatrix[Length@coefs-1],Factor[Most[coefs]/-Last[coefs]]]


done["Transform: add support for notations."]


Transform::usage="Transform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\).\nTransform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].(\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\)-D[\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]).\nTransform[\!\(\*
StyleBox[\"ds\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\)] transforms the differential system.";


Options[Transform]={Simplify->Factor,Print->True,Fermatica`UseFermat->False};


Transform::notinv="The two matrices are not reciprocal to each other. Aborting...";
Transform::range="Something wrong with application range `1`. Aborting...";


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,opts:OptionsPattern[]]:=(*Modified 15.02.2020*)Module[{t1,ti1,i1,y},
i1=RelevantIndices[t];
Which[i1==={},m,
Length@i1==Length@t,
ti1=OInverse[t,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
transform[m,t,ti1,OptionValue[Fermatica`UseFermat]] ,
True,
t1=t[[i1,i1]];
ti1=OInverse[t1,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
transformrange[m,t1,ti1,y,i1,OptionValue[Fermatica`UseFermat]]
](*/Modified 15.02.2020*)
];


Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False}]:=
(*Modified 15.02.2020*)Module[{t1,ti1,i1,y},
If[checked||ODot[ti,t,Simplify->Factor]===IdentityMatrix[Length@t],
i1=RelevantIndices[t];
Which[i1==={},m,
Length@i1==Length@t,
transform[m,t,ti,OptionValue[Fermatica`UseFermat]] ,
True,
t1=t[[i1,i1]];ti1=ti[[i1,i1]];
transformrange[m,t1,ti1,y,i1,OptionValue[Fermatica`UseFermat]]
],(*/Modified 15.02.2020*)
Message[Transform::notinv];Abort[]]
]; 



transform[m_,t_,ti_,fermat:True|False]:=ODot[ti,ODot[m,t,Fermatica`UseFermat->fermat],Fermatica`UseFermat->fermat];
transform[m_,t_,ti_,x_,fermat:True|False]:=ODot[ti,ODot[m,t,Fermatica`UseFermat->fermat]-D[t,x],Fermatica`UseFermat->fermat];
transform[m_,t_,ti_,x_,{},fermat:True|False]:=ODot[ti,ODot[m,t,Fermatica`UseFermat->fermat]-D[t,x],Fermatica`UseFermat->fermat];


transform[m_,t_,ti_,x_,notas:{__Rule},fermat:True|False]:=(*Module[{tmp1,tmp2},*)Internal`InheritedBlock[{D},
SetOptions[D,NonConstants->First/@notas];OQuolyMod[ODot[ti,ODot[m,t,Fermatica`UseFermat->fermat]-(D[t,x]/.First[Solve[0==D[Last/@notas,x],D[First/@notas,x]]]),Fermatica`UseFermat->fermat],notas,Fermatica`UseFermat->fermat]
](*]*)


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,{x_Symbol,notas:_Association|{___Rule}:{}}|x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],opts:OptionsPattern[]]:=
(*Modified 15.02.2020*)
Module[{t1,i1,pt=Null},
(*The idea is that RelevantIndices is cheap, but it often happens that the transformation matrix is nontrivial only in small block*)
i1=RelevantIndices[t];
If[0<Length@i1<Length[t]&&OptionValue[Print],pt=PrintTemporary[Style["Transforming reduced size: "<>ToString[Length@i1]<>"/"<>ToString[Length[t]]<>".",Tiny]]];
If[i1==={},Return[m]];
t1=t[[i1,i1]];
i1=spantolist[i,Length@m][[i1]];(Quiet[NotebookDelete[pt]];#)&@Transform[m,{t1,OInverse[t1,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],True},{x,notas},i1,opts]
(*/Modified 15.02.2020*)
];


Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False},{x_Symbol,notations:_Association|{___Rule}:{}}|x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],OptionsPattern[]]:=Module[{mt,t1,ti1,i1,pt,notas},
If[{notations}==={},notas={},notas=notations];
If[checked||OQuolyMod[ODot[ti,t,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],notas,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]===IdentityMatrix[Length@t],
(*Modified 15.02.2020*)
(*The idea is that RelevantIndices is cheap, but it often happens that the transformation matrix is nontrivial only in small block*)
i1=RelevantIndices[t];
If[i1==={},Return[m]];
If[Length@i1<Length[t],pt=PrintTemporary[Style["Transforming reduced size: "<>ToString[Length@i1]<>"/"<>ToString[Length[t]]<>".",Tiny]]];
t1=t[[i1,i1]];ti1=ti[[i1,i1]];
i1=spantolist[i,Length@m][[i1]];
(Quiet[NotebookDelete[pt]];#)&@transformrange[m,t1,ti1,x,i1,notas/.Association->List,OptionValue[Fermatica`UseFermat]]
(*/Modified 15.02.2020*),
Message[Transform::notinv];Abort[]]
];


done["HistoryChop\[Rule]True option in Undo"]


transformrange[m_,t_,ti_,x_,Span[1,All],notas:{___Rule}:{},fermat:True|False]:=transform[m,t,ti,x,notas,fermat];
transformrange[m_,t_,ti_,x_,i_,notas:{___Rule}:{},fermat:True|False]:=Module[{mt=m,jj,ii,l=Length@m},
(*Modified 15.02.2020*)
ii=spantolist[i,l];
(*/Modified 15.02.2020*)
If[Not[MatchQ[ii,{(_Integer?(1<=#<= l&))..}]],Message[Transform::range,i];Abort[]];
If[DeleteDuplicates[ii]=!=ii,Message[Transform::range,i];Abort[]];
mt[[ii,ii]]=transform[m[[ii,ii]],t,ti,x,notas,fermat];
jj=Complement[DependentColumnIndices[m,ii],ii];
If[jj=!={},mt[[jj,ii]]=OQuolyMod[ODot[mt[[jj,ii]],t,Fermatica`UseFermat->fermat],notas,Fermatica`UseFermat->fermat]];
jj=Complement[DependentRowIndices[m,ii],ii];
If[jj=!={},mt[[ii,jj]]=OQuolyMod[ODot[ti,mt[[ii,jj]],Fermatica`UseFermat->fermat],notas,Fermatica`UseFermat->fermat]];
mt
];


Transform[ds_?DSystemQ,t_,i:{__Integer}|Span[_,_]:Span[1,All],opts:OptionsPattern[]]:=Module[{m=ds[[]]},
(m[#]=Transform[m[#],t,{#,Notations[ds]},i,opts])&/@Keys[m];
HistoryAppend[ds,{m,{Transform,ds,t,i}},Sequence@@FilterRules[{opts},Options[HistoryAppend]]];
m
]


done["Transform[ds,{T,Ti}]: add QuolyMod the the check that T.Ti=IdentityMatrix"];


ChangeVar::usage="ChangeVar[ds,{rules},{vars}] changes variable in the matrix.";


ChangeVar[m_?SquareMatrixQ,x_->xviay_,y_Symbol]:=Factor[m D[xviay,y]/.x->xviay]


Options[ChangeVar]={Print->True}


ChangeVar[ds_?DSystemQ,rs1:_Rule|{__Rule},ys1:_Symbol|_List,OptionsPattern[]]:=Module[{keys=Keys[ds[[]]],M,rs=Flatten[{rs1}],ys=Flatten[{ys1}],nkeys=First/@(Notations[ds]/.Association->List)},
M=Association@@(Function[y,y->Plus@@((D[#1/.rs,y]ds[#1]/.rs)&/@keys)]/@ys);
unprotect[ds,Notations[ds]^=Numerator@Together[Notations[ds]/.rs]];
HistoryAppend[ds,{M,{ChangeVar,ds,rs,ys}},Print->OptionValue[Print]];
Protect[ys]
]


todo["ChangeVar: insert check if new variable coincides with some notation."]


todo["Make a tool, like UnchangeVar, which turns variable to notation."]


AddNotation::usage="AddNotation[ds,y\[Rule]p(x,y)] adds notation y connected with x via p(x,y)=0.\n\
AddNotation[ds,{y\[Rule]p(x,y),z\[Rule]q(x,z),...}] adds several notations.";
AddNotation::wrng="Notation `1` can not be defined by `2`==0. Aborting...";
AddNotation::exists="Notation `2` exists. If you really want to modify notation, use first DeleteNotation[`1`,`2`]. Aborting...";


Options[AddNotation]={HistoryAppend->True}


AddNotation[ds_?DSystemQ,rules:{__Rule},OptionsPattern[]]:=Module[{tmp,keys=Keys[ds[]],M,nots=(Notations[ds]/.Association->List)},
tmp=FreeQ[#2,#1]&@@@rules;
If[Or@@tmp,Message[AddNotation::wrng,#1,#2]&@@@Pick[rules,tmp];Abort[]];
tmp=MatchQ[#,Alternatives@@(First/@rules)->_]&/@nots;
If[Or@@tmp,Message[AddNotation::exists,#1,#2]&@@@Pick[rules,tmp];Abort[]];
nots=Join[nots,rules];
Protect/@First/@rules;
unprotect[ds,Notations[ds]^=nots];
(*HistoryAppend is necessary for HistoryCheck.*)
If[TrueQ@OptionValue[HistoryAppend],HistoryAppend[ds,{ds[],{AddNotation,ds,rules}}]];
First/@rules
];
AddNotation[ds_?DSystemQ,rule_Rule,opts:OptionsPattern[]]:=AddNotation[ds,{rule},opts];


DeleteNotation::usage="DeleteNotation[ds,y] deletes notation y from Notations[ds] list and returns the deleted notation.\n\
DeleteNotation[ds,{y,z,\[Ellipsis]}] deletes several notations.";
DeleteNotation::warn="NB: DeleteNotation may result in history inconsistencies. Use it only if you really know what you do.";


DeleteNotation[ds_?DSystemQ,notations:{__Symbol}]:=(Quiet[Flatten[DeleteNotation[ds,#]&/@notations,1],{DeleteNotation::warn}];Message[DeleteNotation::warn]);
DeleteNotation[ds_?DSystemQ,y_Symbol]:=Module[{keys=Keys[ds[]],M,nots=(Notations[ds]/.Association->List),del},
Message[DeleteNotation::warn];
del=Cases[nots,HoldPattern[y->_]];
If[del==={},Return[{}]];
nots=DeleteCases[nots,y->_];
unprotect[ds,Notations[ds]^=nots];
Unprotect[y];
Return[del];
]


RuleToNotation::usage="RuleToNotation[\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)] gives a rule \!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the numerator of \!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


RuleToNotation::error="The function `1` is not rational.";


RuleToNotation[x_->q_,y_]:=Module[{p},
If[RatFuncQ[q,y],
p=Numerator@Together[q-x];Return[y->p],
Message[RuleToNotation::error,q];
Return[$Failed]
]
]


NotationToRule::usage="NotationToRule[\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)] gives a rule \!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the solution of \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\) wrt \!\(\*
StyleBox[\"x\", \"TI\"]\).";


NotationToRule::error="The equation `1`=0 is not sutable for introducing notation.";


NotationToRule[y_->p_,x_]:=Module[{rule},
If[PolyQ[p,x|y]&&Exponent[p,x]==1,
{{rule}}=Solve[p==0,x];Return[rule],
Message[NotationToRule::error,p];
Return[$Failed]
]
]


A0A1ToSubspaces::usage="A0A1ToSubspaces[{A0,A1},Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances.";


A0A1ToSubspaces[{A0_,A1_},Left]:=A0A1ToSubspaces[{A0,A1}]
A0A1ToSubspaces[{A0_,A1_},Right]:=A0A1ToSubspaces[-Transpose/@{A0,A1}]


A0A1ToSubspaces[{A0_?SquareMatrixQ,A1_?SquareMatrixQ}]/;Length@A0==Length@A1:=Module[
{l=Length[A1],\[Lambda],ns,A},
A=ArrayFlatten[{{A0,A1-\[Lambda]*IdentityMatrix[l]},{0,A0}}];
A=Take[#,-l]&/@OKer[A];
(*Get rid of denominators*)
ns=Collect[Cancel[PolynomialLCM@@Denominator[#]*#],\[Lambda],Factor]&/@Factor@DeleteCases[A,{0..}];
ns=SortBy[DeleteDuplicates[DeleteCases[PickBasis[FixedPointList[D[#,\[Lambda]]&,#]/.\[Lambda]->0],{0..}]&/@ns,(SameQ[#1,#2]||Length[#1]==Length[#2]==MatrixRank[Join[#1,#2]])&],Length];
ns
]


todo["improve A0A1ToSubspaces \[LongDash] calculate Groebner basis of \!\(\*SubscriptBox[\(u\), \(1\)]\)(\[Lambda]),\[Ellipsis],\!\(\*SubscriptBox[\(u\), \(k\)]\)(\[Lambda])."];


A0A1ToSubspacesMod::usage="A0A1ToSubspacesMod[{A0,A1},x\[Rule]poly, Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances.";


A0A1ToSubspacesMod[{A0_,A1_},x_->poly_,Left]:=A0A1ToSubspaces[{A0,A1},x->poly]
A0A1ToSubspaces[{A0_,A1_},x_->poly_,Right]:=A0A1ToSubspaces[-Transpose/@{A0,A1},x->poly]


A0A1ToSubspacesMod[{A0_?SquareMatrixQ,A1_?SquareMatrixQ},x_->poly_]/;Length@A0==Length@A1:=Module[{l=Length[A1],\[Lambda],ns,A},
A=ArrayFlatten[{{A0,A1-\[Lambda]*IdentityMatrix[l] D[poly,x]},{0,A0}}];
A=Take[#,-l]&/@KerMod[A,x->poly];
(*Get rid of denominators*)
ns=Collect[Cancel[PolynomialLCM@@Denominator[#]*#],\[Lambda],Factor]&/@Factor@DeleteCases[A,{0..}];
ns=SortBy[DeleteDuplicates[DeleteCases[PickBasisMod[FixedPointList[D[#,\[Lambda]]&,#]/.\[Lambda]->0,x->poly],{0..}]&/@ns,(SameQ[#1,#2]||Length[#1]==Length[#2]==MatrixRankMod[Join[#1,#2],x->poly])&],Length];
(*If[side===Left,Transpose/@ns,ns]*)ns
]


GetSubspaces::usage="GetSubspaces[\!\(\*
StyleBox[\"m\", \"TI\"]\),{x,\!\(\*SubscriptBox[\(x\), \(0\)]\)},\[Epsilon],Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances with positive gains.\nWhen called with option All\[Rule]True, it returns all subspaces."


Options[GetSubspaces]={All->False,Fermatica`UseFermat->False};


GetSubspaces[m_?DSystemQ,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]
GetSubspaces[m_Association,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]


GetSubspaces[m_?SquareMatrixQ,{x_,x0_},\[Epsilon]_,Left,opts:OptionsPattern[]]:=GetSubspaces[m,{x,x0},\[Epsilon],opts]
GetSubspaces[m_?SquareMatrixQ,{x_,x0_},\[Epsilon]_,Right,opts:OptionsPattern[]]:=GetSubspaces[-Transpose@m,{x,x0},\[Epsilon],opts]


GetSubspaces[m_?SquareMatrixQ,{x_,x0_},\[Epsilon]_,OptionsPattern[]]:=Module[
{r,s,o,ser,m0,m1,status=""},
CMonitor[
status="Evaluating Poincare rank...";
CWrite["\n"<>status];
r=PoincareRank[m,{x,x0}];
status="Evaluating expansion";
s=2Boole[x0===\[Infinity]]-1;
o=s-r;(*leading order of expansion*)
If[r>0,
If[TrueQ@OptionValue[All],
(*Just return all subspaces*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[JDTowers[m0,All,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]],
ser=-s*Series[m,{x,x0,o+1}];
m0=SeriesCoefficient[ser,{x,x0,o}];
m1=SeriesCoefficient[ser,{x,x0,o+1}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[A0A1ToSubspaces[{m0,m1}]]
],
(*Fuchsian singularity*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[JDTowers[m0,If[TrueQ@OptionValue[All],All,_?(Negative[#+1/2/.\[Epsilon]->0]&)],Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]]]
,status,1
]
]


Balance::usage="A balance transformation matrix. Balance[\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*FractionBox[\(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"2\"]\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), Balance[\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\[Infinity]}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*FractionBox[\(1\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), and Balance[\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\[Infinity],\!\(\*SubscriptBox[\(x\), \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+(\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\))\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\).";


Balance::notprojector="Warning: `1` is not a projector. Returning identity matrix";


Balance[p_,{x_,x1_,\[Infinity]},c_:1]:=IdentityMatrix@Length@p-p+p c/(x-x1);


Balance[p_,{x_,\[Infinity],x2_},c_:1]:=IdentityMatrix@Length@p-p+c p (x-x2);


Balance[p_,{x_,x1_,x2_},c_:1]:=IdentityMatrix@Length@p-p+c p (x-x2)/(x-x1);


done["Balance as it was before seems to be neither necessary nor effective."];


VisBalancing::usage="VisBalancing[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is a visual tool for the balancing. Soon to be obsolete and replaced by VisTransformation.";


VisBalancing[ds_,{x_Symbol,poles_},\[Epsilon]_Symbol:Indeterminate]:=VisBalancing[ds[x],x,\[Epsilon],poles]


VisBalancing[ds_?DSystemQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[ds[x],x,\[Epsilon],poles];


VisBalancing[as_Association,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[as[x],x,\[Epsilon],poles];


VisBalancing[matr_?SquareMatrixQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=Module[
(*
Basic idea: first, find JDecompositionData for all points of the matrix.
Then construct a graphics control
*)
{ttt,
n=Length@matr,
m=matr,
polesData,
indices,index,
prevu,prevv,
psetu,psetv,
clickedu,clickedv,
buttons=Grid[{{"Wait"}}],
us,vs,x1,x2,
lu,lv,
gram,goodBalance,colorMark,
statusline="Ready",balance,
transformation,
updateInteface,
apply,
validate
},
transformation=IdentityMatrix[n];
(*Calculate poles*)
updateInteface=(
(*forming polesData and indices*)
polesData=If[poles===All,PolesInfo[m,x],DeleteCases[{#,PoincareRank[m,{x,#}]}&/@poles,{_,_?Negative}]];
CStaticMonitor[
polesData=
({#1,#2,(*Modified 07.06.2019*)JDData(*/Modified 07.06.2019*)@If[#1=!=\[Infinity],SeriesCoefficient[m,{x,#1,-1-#2}],-SeriesCoefficient[m,{x,#1,1-#2}]],If[#2>0,Prepend[#,"M"]&/@Transpose[{(*Transpose/@*)Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Left],Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Right]}],{}]}&@@@polesData);
,"Calculating JDData..."];
indices={};
Do[
Do[
AppendTo[indices,{i1,i2,{i3},i3==1||prevu(*"allowed to press?" flag*),prevu=Unique["p"](*"pressed?" flag*),i3==1||prevv,prevv=Unique["p"]}],{i2,Length@polesData[[i1,3]]},{i3,Length@polesData[[i1,3,i2,-1]]}
];
Do[
AppendTo[indices,{i1,Length@polesData[[i1,3]]+i2,All,True,Unique["p"],True,Unique["p"]}],{i2,Length@polesData[[i1,4]]}
]
,{i1,Length@polesData}];
polesData={#1,#2,Join[#3,#4]}&@@@polesData;
(*/forming polesData and indices*)
(*functions to set variables*)
psetu=Function[v,(v=#)&]/@indices[[All,5]];psetv=Function[v,(v=#)&]/@indices[[All,7]];
(*
write 
psetu[[i]][True] and psetv[[i]][True] *)(*
for the naive effect of 
indices[[i,5]]=True and indices[[i,7]]=True 
*)
(*/functions to set variables*)
(*forming interface*)
buttons=Grid[{
{
Grid[ArrayFlatten[{{
PadRight[Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedu[#1,#2,#3],Enabled->Dynamic[#4],Appearance->Dynamic[If[#5,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
],
{If[#2>0,Style,#&][Row[{"   ",x,"=",#1,", pr=",#2,"   "}],Bold]}&@@@polesData[[All,{1,2}]],
PadLeft[Reverse/@Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedv[#1,#2,#3],Enabled->Dynamic[#6],Appearance->Dynamic[If[#7,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
]
}}],Spacings->0,ItemSize->All,Alignment->Center]
},{
Button["Apply balance transformation",apply[],Enabled->Dynamic[goodBalance],Background->Dynamic[colorMark]]
},
{
Button["Paste overall transformation",DialogReturn[transformation]]
},
{
Dynamic[statusline]
}
},Alignment->Center];
(*/forming interface*)
(*unsetting buttons*)
Through[psetu[False]];
Through[psetv[False]];
(*/unsetting buttons*)
validate[];
)&;
apply=(
(*apply transformation*)
balance=Balance[Projector[(*Transpose@*)us,vs],{x,x1,x2}];
statusline="balance constructed";
PrintTemporary[statusline];
m=Transform[m,balance,x];
statusline="transformation applied";
PrintTemporary[statusline];
(**)
transformation=ODot[transformation,balance];
statusline="overall transformation calculated";
PrintTemporary[statusline];
updateInteface[];
)&;
validate=(
(*pick right and left vectors*)
us=vs={};
(
If[#5,us=Join[us,polesData[[#1,3,#2,2,#3]]];x1=polesData[[#1,1]]];If[#7,vs=Join[vs,polesData[[#1,3,#2,3,#3]]];x2=polesData[[#1,1]]])&@@@indices;
lu=Length@us;lv=Length@vs;
If[lu==0||lv==0,
goodBalance=False;
colorMark=Automatic
,
gram=ODot[vs,Transpose@us];
goodBalance=(lu==lv&&lv==MatrixRank[gram]);
colorMark=If[MatrixRank[gram]==lu,If[goodBalance,Green,Automatic],Red]
];
statusline=ToString[lu]<>"-dimensional u-space and "<>ToString[lv]<>"-dimensional v-space";
)&;

clickedu=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,5]],
psetu[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetu[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,__} ,{1}]];
psetu[[index]][True];
];
validate[];
)&;
clickedv=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,7]],
psetv[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetv[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,__},{1}]];
psetv[[index]][True];
];
validate[];
)&;
updateInteface[];
DialogInput[Dynamic[buttons(*Refresh[buttons,UpdateInterval\[Rule]1]*)]]
]


todo["VisBalancing: block simultaneus pressing buttons for nonzero Poincare rank singularities"]
todo["VisBalancing: for simple poles allow same-line pressing on left and right"]


VisTransformation::usage="VisTransformation[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is a visual tool for finding transformation. Soon to replace VisBalancing.";


VisTransformation[ds_,{x_Symbol,poles_},\[Epsilon]_Symbol:Indeterminate,opts:OptionsPattern[]]:=VisTransformation[ds[x],x,\[Epsilon],poles,opts]


VisTransformation[ds_?DSystemQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All,opts:OptionsPattern[]]:=VisTransformation[ds[x],x,\[Epsilon],poles,opts];


VisTransformation[as_Association,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All,opts:OptionsPattern[]]:=VisTransformation[as[x],x,\[Epsilon],poles,opts];


Options[VisTransformation]={Fermatica`UseFermat->False,Log->False,Debug->False,Highlighted->False,Animate->False,AnimationRate->5};


VisTransformation[matr_?SquareMatrixQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All,OptionsPattern[]]:=Module[
(*
Basic idea: first, find JDecompositionData for all points of the matrix.
Then construct a graphics control
*)
{
n=Length@matr,
m=matr,i=0,
polespos,polesData,pd,
indices,index,
prevu,prevv,
psetu,psetv,
clickedu,clickedv,
buttons=Grid[{{"Wait"}}],
uinds,vinds,
us,vs,x1,x2,
lu,lv,
bytecount="?",
gram,applyEnabled,colorMark,
statusline="Ready",balance,
transformation,
updateInteface,
apply,
validate,
continue=True,
guidedlist,
guidedlistnew={},
guided,
animationlist,
animationdelay,
animate,dia
},
transformation=IdentityMatrix[n];
guidedlist=Replace[OptionValue[Highlighted],{Except[_List]->{}}];
animationlist=Replace[OptionValue[Animate],Highlighted->guidedlist];
animationdelay=1/OptionValue[AnimationRate];
If[animationlist==={},Return[transformation]];
polespos=Replace[poles,All->PolesPosition[m,x]];
updateInteface=(
If[guidedlist=!={},
guided=First[guidedlist];guidedlist=Rest[guidedlist],
guided={}\[LongLeftRightArrow]{}
];
(*forming polesData and indices*)
polesData=DeleteCases[{#,PoincareRank[m,{x,#}]}&/@polespos,{_,_?Negative}];
Monitor[
polesData=
({#1,#2,JDData[(If[#1=!=\[Infinity],(*SeriesCoefficientMod[m,{x->x-#1,-1-#2}]*)SeriesCoefficient[m,{x,#1,-1-#2}],-SeriesCoefficient[m,{x,#1,1-#2}]]),Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]],If[#2>0,Prepend[#,"Fuchsify"]&/@(TransposePadRight[{Union@A0A1ToSubspaces[Monitor[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],"\t\tLSC"],Left],Union@A0A1ToSubspaces[Monitor[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],"\t\tLSC"],Right]},{}]),{}]}&@@@polesData);
,"Calculating Jordan decomposition data..."];
indices={};
Do[
Do[
AppendTo[indices,{
i1,i2,{i3},
i3==1||prevu(*"allowed to press?" flag*),prevu=Unique["u"](*"pressed?" flag*),i3==1||prevv(*"allowed to press?" flag*),prevv=Unique["v"]}(*"pressed?" flag*)
],{i2,Length@polesData[[i1,3]]},{i3,Length@polesData[[i1,3,i2,-1]]}
];
Do[
AppendTo[indices,{i1,Length@polesData[[i1,3]]+i2,All,True,Unique["f"],True,Unique["f"]}],{i2,Length@polesData[[i1,4]]}
]
,{i1,Length@polesData}];
polesData={#1,#2,Join[#3,#4]}&@@@polesData;
(*/forming polesData and indices*)
(*functions to set variables*)
psetu=Function[v,(v=#)&]/@indices[[All,5]];psetv=Function[v,(v=#)&]/@indices[[All,7]];
(*
write 
psetu[[i]][True] and psetv[[i]][True] *)(*
for the naive effect of 
indices[[i,5]]=True and indices[[i,7]]=True 
*)
(*/functions to set variables*)
(*forming interface*)
buttons=Grid[{
{
Grid[ArrayFlatten[{{index=0;
Replace[PadRight[
Apply[(index++;pd=polesData[[#1,3,#2,1]];Button[Switch[pd/.\[Epsilon]->0,_?Positive,Style[pd,{Lighter@Red}],_?Negative,Style[pd,{Blue,Bold}],_?PossibleZeroQ,Style[pd,{Darker@Green}],_,Style[pd,{Bold}]],clickedu[#1,#2,#3],Enabled->Dynamic[#4],Appearance->Dynamic[If[#5,{"FramedPalette","Pressed"},"FramedPalette"]],TooltipDelay->0.5,Tooltip->"Left button #"<>ToString[index],
Background->If[MemberQ[guided[[1]],index],Yellow,Automatic]]
(*Item[(*,Sequence@@If[MemberQ[guided[[1]],index],{Frame\[Rule]True,FrameStyle\[Rule]Directive[Yellow,AbsoluteThickness[5]]},{}]*)]*))&,SplitBy[indices,First],{2}]
],{0->""},{2}],
{Row[{"   ",x,"=",#1,", pr=",#2,"   "}]}&@@@polesData[[All,{1,2}]],
index=0;
Replace[PadLeft[Reverse/@Apply[(index++;pd=polesData[[#1,3,#2,1]];Button[Switch[pd/.\[Epsilon]->0,_?Positive,Style[pd,{Red,Bold}],_?Negative,Style[pd,{Lighter@Blue}],_?PossibleZeroQ,Style[pd,{Darker@Green}],_,Style[pd,{Bold}]],clickedv[#1,#2,#3],Enabled->Dynamic[#6],Appearance->Dynamic[If[#7,{"FramedPalette","Pressed"},"FramedPalette"]],TooltipDelay->0.5,Tooltip->"Right button #"<>ToString[index],
Background->If[MemberQ[guided[[2]],index],Yellow,Automatic]](*Item[(*,Sequence@@If[MemberQ[guided[[2]],index],{Frame\[Rule]True,FrameStyle\[Rule]Directive[Yellow,AbsoluteThickness[5]]},{}]*)]*))&,SplitBy[indices,First],{2}]
],{0->""},{2}]
}}],Spacings->0,ItemSize->All,Alignment->Center]
},{
Button[Dynamic["Apply balance transformation ("<>bytecount<>"b)"],If[OptionValue[Debug],WriteString["stdout","Pressed \"Apply balance transformation\" button.\n"]];continue=True;DialogReturn[],Enabled->Dynamic[applyEnabled],Background->Dynamic[colorMark]]
},
{
Button["Paste overall transformation",If[OptionValue[Debug],WriteString["stdout","Pressed \"Paste overall transformation\" button.\n"]];DialogReturn[],Background->Dynamic[colorMark]]
},
{
Dynamic[statusline]
}
},Alignment->Center];
(*/forming interface*)
(*unsetting buttons*)
Through[psetu[False]];
Through[psetv[False]];
(*/unsetting buttons*)
validate[];
continue=False;
If[Head[animationlist]=!=List,
DialogInput[buttons],
dia=CreateDialog[buttons];
animate=First@animationlist;
animationlist=Rest@animationlist;
(Pause[animationdelay];clickedu@@indices[[#]])&/@animate[[1]];
(Pause[animationdelay];clickedv@@indices[[#]])&/@animate[[2]];
If[animationlist=!={},continue=True];
Pause[animationdelay];
NotebookClose[dia];
]
)&;
apply=(CMonitor[
applyEnabled=False;
colorMark=Magenta;
(*apply transformation*)
statusline="Constructing balance...";
balance=Balance[Projector[(*Transpose@*)us,vs],{x,x1,x2}];
statusline=statusline<>"\nCalculating overall transformation...";
transformation=ODot[transformation,balance];
If[OptionValue[Log],
WriteString["stdout","Applied balance "<>ToString[uinds\[LongLeftRightArrow]vinds]<>".\n"];
AppendTo[guidedlistnew,uinds\[LongLeftRightArrow]vinds];
];
If[guided=!={}\[LongLeftRightArrow]{}&&Not[MatchQ[uinds\[LongLeftRightArrow]vinds,guided]],
WriteString["stdout","Guided action turned off. Proceed now at your own risk."];
guidedlist={}
];
statusline=statusline<>"\nApplying transformation...";
m=Transform[m,balance,x,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
,
statusline]
)&;
validate=(
(*pick right and left vectors*)
uinds=Flatten[Position[indices[[All,5]],True,{1}]];
vinds=Flatten[Position[indices[[All,7]],True,{1}]];
If[uinds==={},us={},
us=Flatten[polesData[[#1,3,#2,2,#3]]&@@@indices[[uinds]],1];
x1=polesData[[indices[[First@uinds,1]],1]]
];
If[vinds==={},vs={},
vs=Flatten[polesData[[#1,3,#2,3,#3]]&@@@indices[[vinds]],1];
x2=polesData[[indices[[First@vinds,1]],1]]
];
lu=Length@us;lv=Length@vs;
If[lu==0||lv==0||lu!=lv,
applyEnabled=False;
colorMark=Automatic
,
gram=ODot[vs,Transpose@us];bytecount=ToString@ByteCount[gram];(*byte count here*)
applyEnabled=(lv==MatrixRank[gram]);
colorMark=If[applyEnabled,Green,Red]
];
statusline=ToString[lu]<>"-dimensional u-space and "<>ToString[lv]<>"-dimensional v-space";
)&;

clickedu=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,5]],
(*unpress*)
psetu[[index]][False];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k> First[#3],__},{1}]];
If[OptionValue[Debug],WriteString["stdout","Unpressed left  button #"<>ToString[index]<>".\n"]],
(*press+unpress*)
psetu[[#]][False]&/@Flatten[Position[indices,{Except[#1],__},{1}]];
If[#3===All,
psetu[[#]][False]&/@Flatten[Position[indices,{#1,_,Except[All],___},{1}]],
psetu[[#]][False]&/@Flatten[Position[indices,{#1,_,All,___},{1}]]
];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,__} ,{1}]];
psetu[[index]][True];
If[OptionValue[Debug],WriteString["stdout","Pressed left button #"<>ToString[index]<>".\n"]]
];
validate[];
)&;
clickedv=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,7]],
psetv[[index]][False];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k> First[#3],__},{1}]];
If[OptionValue[Debug],WriteString["stdout","Unpressed right  button #"<>ToString[index]<>".\n"]],
psetv[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
If[#3===All,
psetv[[#]][False]&/@Flatten[Position[indices,{#1,_,Except[All],___},{1}]],
psetv[[#]][False]&/@Flatten[Position[indices,{#1,_,All,___},{1}]]
];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,__},{1}]];
psetv[[index]][True];
If[OptionValue[Debug],WriteString["stdout","Pressed right button #"<>ToString[index]<>".\n"]]
];
validate[];
)&;
While[continue,
updateInteface[];
If[applyEnabled,
apply[];
];
bytecount="?";
];
If[OptionValue[Log],
Print["NB: option\n\t",Highlighted->guidedlistnew,"\nwill guide you through the same path,\n while option\n\t",Animate->guidedlistnew,"\nwill press the buttons for you \[HappySmiley]."];
];
transformation
]


ReduceFactors[m_?SquareMatrixQ,pat_]:=Module[{inds=EntangledBlocksIndices[m],odbi=OffDiagonalBlocksIndices[m,Flatten->True,Sort->Row],mt,n=Length@m,mysolve,Cs,c,eqs,sol={},i,imax,pt},
mysolve[eq_]:=If[Length[Cs=Union[Cases[Collect[eq,_c],_c,All]]]>1,sol=Join[sol,Quiet[Flatten[Solve[Collect[eq,_c]==0,Cs]]]]];
pt=PrintTemporary["Constructing equations..."];i=0;imax=Length[odbi];
Monitor[
eqs=Flatten[Function[ij,i++;c[First@First[ij]]-c[First@Last[ij]]*#&/@GetFactor[Flatten[m[[##]]&@@ij],_?NumericQ]]/@odbi],
ProgressIndicator[i,{0,imax}]];
Quiet[NotebookDelete[pt]];
pt=PrintTemporary["Solving equations..."];i=0;imax=Length[eqs];
Monitor[Scan[mysolve[#1//.sol]&,eqs],
ProgressIndicator[i,{0,imax}]
];
Quiet[NotebookDelete[pt]];
DiagonalMatrix[Flatten[ConstantArray[c[First@#],Length[#]]&/@inds]]//.sol/.c->C
]


todo["FactorOut: make clever sorting of the equations"];


FactorOut::usage="FactorOut[m,x,\[Epsilon],\[Mu]] returns a transformation which reduces m to a factorized form.";


FactorOut::notfuchsian="Not Fuchsian matrix...";
FactorOut::notnormalized="Eigenvalues of the matrix residues are not normalized...";
Options[FactorOut]={DependentRowIndices->Automatic,Sort->True,Solve->True,Fermatica`UseFermat->False};


FactorOut[ds_?DSystemQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[ds[x],x,\[Epsilon],\[Mu],opts];


FactorOut[as_Association,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[as[x],x,\[Epsilon],\[Mu],opts];


FactorOut[m_?SquareMatrixQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=Module[
{n=Length@m,mres,t,vars,eqs,sol,ms},
If[!FuchsianQ[m,x],Message[FactorOut::notfuchsian];Return[$Failed]];ms=Replace[OptionValue[DependentRowIndices],Automatic->TClosure[m]];
mres=LeadingSeriesCoefficient[m/\[Epsilon],{x,#1,0}]&@@@PolesInfo[m,x];
FactorDependence[mres,\[Epsilon],\[Mu],Sequence@@FilterRules[#->OptionValue[#]&@@@Options[FactorOut],Options[FactorDependence]]]
]


todo["rewrite FactorOut in the spirit of SimplifyFuchsian"];


FactorDependence::usage="FactorDependence[{m1,m2,\[Ellipsis]},\[Epsilon],\[Mu]] returns a transformation which reduces m1,m2,... to \[Epsilon]\[LongDash]independent matrices.";


Options[FactorDependence]={DependentRowIndices->Automatic,Sort->True,Solve->True,Fermatica`UseFermat->False};
FactorDependence[m:{__?SquareMatrixQ},\[Epsilon]_,\[Mu]_,OptionsPattern[]]:=Module[
{n=Length[First@m],t,vars,eqs,sol,hie,ii},
hie=Replace[OptionValue[DependentRowIndices],{Automatic->tclosure[Transpose[m,{3,1,2}],1,Except[{0..}]],All->ConstantArray[1,{n,n}]}];
If[TrueQ[OptionValue[Sort]],ii=Flatten@EntangledBlocksIndices[hie],ii=All];
hie=hie[[ii,ii]];
t=Replace[hie,1:>Unique["t"],{2}];
vars=DeleteCases[Flatten[Reverse/@t],0];
eqs=DeleteCases[Flatten[Transpose[Reverse/@(ODot[#[[ii,ii]],t,Simplify->False]-ODot[t,#[[ii,ii]]/.\[Epsilon]->\[Mu],Simplify->False])&/@m,{3,1,2}]],0];If[!OptionValue[Solve],CPrint["Returning a list {eqs,t,vars}. To find the transformation one should solve eqs\[Equal]0 with respect to Variables[t] and substitute the solution to t."];Return[{eqs,t,vars}]];
If[OptionValue[Fermatica`UseFermat],
Quiet[sol=Fermatica`FGaussSolve[eqs,vars,Reduce->True]];,
Quiet[sol=GaussSolve[eqs,vars]]
];
t[[ii,ii]]=t//.Dispatch[sol]/.MapIndexed[#->C@@#2&,Complement[vars,First/@sol]];
t
]


done[" implement FactorOut and FactorDependence using Fermat and FGaussSolve"];


FuchsifyBlock::usage="FuchsifyBlock[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),{{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}}] is supposed to fuchsify block \!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\){\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}]].";


done["FuchsifyBlock works now without applying  transformation beforehand."];


Options[FuchsifyBlock]={Simplify->False,Monitor->True,Fermatica`UseFermat->False,Inverse->True};


FuchsifyBlock[ds_?DSystemQ,x_Symbol,{high_List,low_List},dens:_List|All:All,opts:OptionsPattern[]]:=Module[{m,all=Join[high,low],ll=Length@low,lh=Length@high,y,x2y,t,notas},
notas=Notations[ds,all]/.Association->List; 
m=ds[x][[all,all]];
FuchsifyBlock[m,{x,notas},{Range[lh],Range[lh+1,lh+ll]},dens,opts]
]


FuchsifyBlock::pr="Diagonal block `1` is not Fuchsian. Aborting...";
FuchsifyBlock::err="Can not fuchsify";
FuchsifyBlock::notas="More than one notation involved. Not implemented yet.";
FuchsifyBlock[m_?MatrixQ,{x_Symbol,notations:_Association|{___Rule}:{}}|x_Symbol,{high_List,low_List},dens:_List|All:All,OptionsPattern[]]:=
Module[
{all=Join[high,low],lhigh=Length@high,llow=Length@low,densPR,infPR,deg,vars,c,cm,t,p,b,Ah,Al,Bhl,part1,part2,y,x2y,notas,pt,
sp=Boole@Not@TrueQ[OptionValue[Simplify]],
fermat=OptionValue[Fermatica`UseFermat],
monitor=OptionValue[Monitor]},
If[{notations}==={},
notas={},
notas=notations/.Association->List
];
NewDSystem[b,x->Factor[m[[all,all]]],Print->False];
(*Treat notations*)
notas=Select[notas,Not[FreeQ[b[x],First[#]]]&];
If[Length@notas>1,Message[FuchsifyBlock::notas];Return[IdentityMatrix[lhigh+llow]]];
If[Length@notas==1,
(*pt=PrintTemporary[Style["FuchsifyBlock: Found one notation. Changing variable...",Tiny]];*)
{y,x2y}={notas[[1,1]],NotationToRule[notas[[1]],x]};
ChangeVar[b,x2y,y,Print->False];,
y=x
];
(*/Treat notations*)
(*AddNotation[b,#]&/@Flatten[{notas}/.Association\[Rule]List];*)
(*Check that diagonal blocks are Fuchsian*)
densPR=Cases[DenominatorsInfo[b[[(-llow);;,(-llow);;]],y],Replace[dens,{a_List:>{Alternatives@@a,_},All->_}]];
If[MemberQ[Last/@densPR,_?Positive],Message[FuchsifyBlock::pr,low];Abort[]];
densPR=Cases[DenominatorsInfo[b[[;;lhigh,;;lhigh]],y],Replace[dens,{a_List:>{Alternatives@@a,_},All->_}]];
If[MemberQ[Last/@densPR,_?Positive],Message[FuchsifyBlock::pr,high];Abort[]];
(*/Check that diagonal blocks are Fuchsian*)
(*Extracting Poincare ranks*)
densPR=Cases[DenominatorsInfo[b[[;;lhigh,(-llow);;]],y],Replace[dens,{a_List:>{Alternatives@@a,_},All->_}]];
Function[{den,pr},
If[monitor,CStaticMonitor,#1&][
If[den=!=1/y,
(*finite singularities*)
deg=Exponent[den,y];
vars=Array[c,{lhigh,llow,deg},{1,1,0}];
(*Diagonal blocks*)
Ah=QuolyMod[den*b[y][[;;lhigh,;;lhigh]],y->den];
Al=QuolyMod[den*b[y][[(-llow);;,(-llow);;]],y->den];
t=IdentityMatrix[lhigh+llow];
cm=vars.y^Range[0,Exponent[den,y]-1];
part1=QuolyMod[Ah.cm-cm.Al,y->den];
part2=QuolyMod[cm*D[den,y],y->den];
Do[
Bhl=QuolyMod[Factor[b[y][[;;lhigh,(-llow);;]]den^(p+1)],y->den];
Quiet[Check[t[[;;lhigh,(-llow);;]]=cm/den^p/.GaussSolve[Flatten[CoefficientList[Bhl+part1+p*part2,y]],Flatten[vars],Continue->True,Monitor->monitor]/.Thread[Flatten[vars]->0],If[p>0,Message[FuchsifyBlock::err]],GaussSolve::inconsistent],GaussSolve::inconsistent];
Transform[b,t,Print->False]
,
{p,pr,sp,-1}],
(*infinity*)
vars=Array[c,{lhigh,llow},{1,1}];
t=IdentityMatrix[lhigh+llow];
Ah=SeriesCoefficient[b[y][[;;lhigh,;;lhigh]],{y,\[Infinity],1}];
Al=SeriesCoefficient[b[y][[(-llow);;,(-llow);;]],{y,\[Infinity],1}];
Do[
Bhl=SeriesCoefficient[b[y][[;;lhigh,(-llow);;]],{y,\[Infinity],1-p}];
(**)
Quiet[Check[t[[;;lhigh,(-llow);;]]=vars*y^p/.GaussSolve[Bhl+Ah.vars-vars.Al-p*vars,Flatten[vars],Continue->True,Monitor->monitor]/.Thread[Flatten[vars]->0],If[p>0,Message[FuchsifyBlock::err]],GaussSolve::inconsistent],GaussSolve::inconsistent];
Transform[b,t,Print->False]
,
{p,pr,sp,-1}]
],
ToString[den,InputForm]<>":"<>ToString[p]
]
]@@@densPR;
(*(Quiet[NotebookDelete[pt]];#)&[t=Fold[QuolyMod,HistoryConsolidate[b,Inverse\[Rule]False],notas]]*)
t=HistoryConsolidate[b,Inverse->False,Monitor->False];
t=QuolyMod[t,notas];
If[TrueQ@OptionValue[Inverse],{t,2IdentityMatrix[Length@t]-t},t]
]


todo["Make FuchsifyBlock work with notations."];


todo["FuchsifyBlock,Fuchsify: UseFermat option should accept more detailed specification."]


Fuchsify::usage="Fuchsify[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is supposed to Fuchsify \!\(\*
StyleBox[\"m\", \"TI\"]\).";
Fuchsify::err="Something went wrong when fuchsifying the block `1`";


Options[Fuchsify]={Simplify->False,Fermatica`UseFermat->False,Inverse->False,Monitor->True};


todo["Fuchsify: Check new sorting."];


Fuchsify[m_?SquareMatrixQ,{x_Symbol,notas:_Association|{___Rule}:{}}|x_Symbol,dens:_List|All:All,OptionsPattern[]]:=
Module[
{progress,di=First/@EntangledBlocksIndices[m],odi=OffDiagonalBlocksIndices[m,Sort->Row],m1=m,m2,t,t1,ti1,(*block={"\[Ellipsis]","\[Ellipsis]"},*)i="\[Ellipsis]",j="\[Ellipsis]",k,mon=0,monp=-1,l,
fermat=OptionValue[Fermatica`UseFermat],monitor=TrueQ@OptionValue[Monitor]},
t=IdentityMatrix[Length@m];
progress=0*t;
Apply[(progress[[##]]=-1)&,odi,{1}];
l=Length@odi;
If[monitor,CMonitor,#1&][
Function[{bl},
{i,j}=bl;k=Join[i,j];
(*DebugWatch[i,j];*)
progress[[i,j]]=2;
If[monitor,CProgressPrint[monp,mon,l]];
t1=ti1=IdentityMatrix[Length@m1];
Check[t1[[k,k]]=FuchsifyBlock[m1,{x,notas},bl,dens,Fermatica`UseFermat->fermat,Simplify->OptionValue[Simplify],Monitor->False,Inverse->False],Message[Fuchsify::err,{i,j}]];
(*ti1=2IdentityMatrix[Length@t1]-t1;*)
If[Factor@Det[t1[[k,k]]]===0,Message[Fuchsify::err,bl];Return[t]];
m2=m1;
m2[[i,j]]=m2[[i,j]]-DiffMod[t1[[i,j]],x,notas];
m2[[All,j]]=m2[[All,j]]+ODot[m1[[All,i]],t1[[i,j]],Fermatica`UseFermat->fermat];
m2[[i]]=m2[[i]]-ODot[t1[[i,j]],m1[[j]],Fermatica`UseFermat->fermat];
m1=m2;
(*m1=Transform[m1,{t1,ti1,True},{x,notas},Fermatica`UseFermat\[Rule]fermat,Print\[Rule]True];*)
t[[All,j]]=t[[All,j]]+ODot[t[[All,i]],t1[[i,j]],Fermatica`UseFermat->fermat,Simplify->FactorPlus];
(*t=ODot[t,t1,Fermatica`UseFermat\[Rule]fermat,Simplify->FactorPlus];*)
progress[[i,j]]=1;mon++;
]/@odi,
Overlay[{ArrayPlot[progress[[di,di]],ColorRules->{0->Transparent,1->Green,2->Red,-1->Lighter@Gray},ImageSize->Medium(*,Mesh\[Rule]True*)],Style[Grid[{{tospan[j],""},{"",tospan[i]}},Frame->All,Background->{White,White,{{2,1}->Red}}],Tiny]},Alignment->{Right,Top}](*ProgressIndicator[mon,{0,l}]*)];
t
]


tospan[list:{a_Integer,___Integer,b_Integer}]:=If[MatchQ[Differences[list],{1...}],ToString[a]<>";;"<>ToString[b],ToString@list];
tospan[list_]:=ToString@list;


Fuchsify[ds_?DSystemQ,x_Symbol,b___]:=Fuchsify[ds[x],{x,Notations[ds]},b]


todo["Decide what to do when NotationToRule is not possible (many-variate setup, notation is irrelevant to the specified variable)"];


BTSolve::usage="BTSolve[{\!\(\*SubscriptBox[
StyleBox[\"L\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"R\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"B\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"a\", \"TI\"], \(1\)]\)},{\!\(\*SubscriptBox[
StyleBox[\"L\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"R\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"B\", \"TI\"], \(2\)]\),\!\(\*SubscriptBox[
StyleBox[\"a\", \"TI\"], \(2\)]\)},\[Ellipsis]] returns the matrix X which is the solution of the equation \!\(\*SubscriptBox[
StyleBox[\"a\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"L\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\"X\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"XR\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"B\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\*
StyleBox[\(\!\(\*
StyleBox[\"0\", \"TI\"]\).\)] Here \!\(\*SubscriptBox[
StyleBox[\"a\", \"TI\"], \(i\)]\) are numbers and \!\(\*SubscriptBox[
StyleBox[\"L\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"B\", \"TI\"], \(i\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"R\", \"TI\"], \(i\)]\) are \!\(\*
StyleBox[\"n\", \"TI\"]\)\!\(\*
StyleBox[\"\[Times]\", \"TI\"]\)\!\(\*
StyleBox[\"n\", \"TI\"]\), \!\(\*
StyleBox[\"n\", \"TI\"]\)\!\(\*
StyleBox[\"\[Times]\", \"TI\"]\)\!\(\*
StyleBox[\"m\", \"TI\"]\), and \!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"\[Times]\", \"TI\"]\)\!\(\*
StyleBox[\"m\", \"TI\"]\) matrices, respectively. If \!\(\*
StyleBox[\"B\", \"TI\"]\) is omitted, it is zero. If \!\(\*
StyleBox[\"a\", \"TI\"]\) is omitted, it is zero.";


BTSolve[seq:{_?SquareMatrixQ,_?SquareMatrixQ,___}..]:=Module[{n,m,X,LRBaList},
n=Length[{seq}[[1,1]]];m=Length[{seq}[[1,2]]];
(*TODO: check consistency of the parameters*)
X=Partition[Array[C,n*m],m];
LRBaList=Replace[{seq},{{L_?SquareMatrixQ,R_?SquareMatrixQ,B:(_?MatrixQ):{{0}},a_:0}:>a*X+ODot[L,X]-ODot[X,R]+Replace[B,{{0}}:>ConstantArray[0,{n,m}]],_:>Return[$Failed]},{1}];
X/.GaussSolve[Flatten[LRBaList],Flatten[X]]
]


todo["implement option Pattern in BTSolve, similar to DependentRowIndices"];


todo["rewrite BTSolve without necessity to introduce indeterminates"];


Denominators::usage="Denominators[\!\(\*
StyleBox[\"m\", \"TI\"]\)|\!\(\*
StyleBox[\"ds\", \"TI\"]\)] tries to define denominators in the system.\nDenominators[\!\(\*
StyleBox[\"m\", \"TI\"]\)|\!\(\*
StyleBox[\"ds\", \"TI\"]\),\!\(\*
StyleBox[\"pat\", \"TI\"]\)] gives only denominators depending on \!\(\*
StyleBox[\"pat\", \"TI\"]\).";


Options[Denominators]={Print->False};


Denominators[ds_?DSystemQ,pat_:_,excl_:_?NumericQ,OptionsPattern[]]:=Module[{dens},
dens=Denominators/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[dens===Denominators,
dens=Denominators[Values[ds[]],Alternatives@@Variables[ds]];
HistoryAddExtra[ds,{Denominators->dens},Print->OptionValue[Print]],
If[OptionValue[Print],CPrint[Style["Read Denominators from extras.",Small]]]
];
DeleteCases[dens,_?(FreeQ[#,pat]&)|excl]
]


Denominators[m_List,pat_:_,excl_:_?NumericQ]:=Sort@DeleteCases[DeleteDuplicates@Flatten[(First/@FactorList[#])&/@Denominator/@Flatten[m]],_?(FreeQ[#,pat]&)|excl]
Denominators[ex_,pat_:_,excl_:_?NumericQ]:=Sort@DeleteCases[First/@FactorList[Denominator@ex],_?(FreeQ[#,pat]&)|excl]


Denominators[as_Assiciation,pat_:_,excl_:_?NumericQ]:=Denominators[Values[as],Alternatives@@Keys[as],_?(FreeQ[#,pat]&)|excl]


PolesPosition::usage="PolesPosition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] tries to determine all singular points of the matrix \!\(\*
StyleBox[\"m\", \"TI\"]\).";


PolesPosition[m_List,x_Symbol]:=Module[{xf,t,mr},
xf=x/.#&/@Union@Flatten[Solve[#==0,x]&/@Denominators[{m},x]];
mr=Factor[m/t^2/.x->1/t];
If[Quiet[Check[mr/.t->0;False,True,Power::infy]],Sort[Append[xf,\[Infinity]]],Sort[xf]]
]


PolesPosition[ds_Association,x_Symbol]:=PolesPosition[ds[x],x]
PolesPosition[ds_?DSystemQ,x_Symbol]:=PolesPosition[ds[x],x]


PoincareRank::usage="PoincareRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)}] gives the Poincare rank \!\(\*
StyleBox[\"r\", \"TI\"]\) of the singular point \!\(\*
StyleBox[\"x\", \"TI\"]\)=\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\) of \!\(\*
StyleBox[\"m\", \"TI\"]\). When \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)\[NotEqual]\[Infinity] the Poincare rank is the pole order minus 1 (by convention, we put \!\(\*
StyleBox[\"r\", \"TI\"]\)=-1 for regular point). For \!\(\*SubscriptBox[\(x\), \(0\)]\)=\[Infinity] the Poincare rank is 1 minus the leading series order.";


PoincareRank[m_,{x_Symbol,x0_}]:=Max[-1,2*Boole[x0===\[Infinity]]-1-LeadingOrder[m,{x,x0}]]


PoincareRank[ds_Association,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]
PoincareRank[ds_?DSystemQ,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


PolesInfo[ds_Association]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]
PolesInfo[ds_?DSystemQ]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]


PolesInfo::usage="PolesInfo[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of pairs {\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\) is the position of the pole, and \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\) is its Poincare rank.";


PolesInfo[m_,x_Symbol]:=Module[{xs,n},
xs=PolesPosition[m,x];
{#,PoincareRank[m,{x,#}]}&/@xs
]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


PolyPoincareRank::usage="PolyPoincareRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"d\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the Poincare rank \!\(\*
StyleBox[\"r\", \"TI\"]\)  of \!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"  \", \"TI\"]\)at zeros of \!\(\*
StyleBox[\"d\", \"TI\"]\).";


PolyPoincareRank[m_,poly_,x_Symbol]:=Max[-1,2*Boole[poly===1/x]-1-LeadingOrderMod[m,x->poly]]


PolyPoincareRank[ds_Association,{x_Symbol,x0_}]:=PolyPoincareRank[ds[x],{x,x0}]
PolyPoincareRank[ds_?DSystemQ,{x_Symbol,x0_}]:=PolyPoincareRank[ds[x],{x,x0}]


DenominatorsInfo::usage="DenominatorsInfo[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of pairs {\!\(\*SubscriptBox[
StyleBox[\"d\", \"TI\"], \(i\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"d\", \"TI\"], \(i\)]\) are irreducible denominators and \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\) are their Poincare ranks. The last entry is special: {\!\(\*SuperscriptBox[
StyleBox[\"x\", \"TI\"], \(-1\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(\[Infinity]\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(\[Infinity]\)]\) is the Poincare rank at infinity.";


DenominatorsInfo[m_,x_]:=Module[{dens=Denominators[m,x]},Append[{#,PolyPoincareRank[m,#,x]}&/@dens,{1/x,PolyPoincareRank[m,1/x,x]}]]


DenominatorsInfo[ds_Association,x_Symbol]:=DenominatorsInfo[ds[x],x]
DenominatorsInfo[ds_?DSystemQ,x_Symbol]:=DenominatorsInfo[ds[x],x]


FactorPlus::usage="FactorPlus[expr] factors expr iff it has head \"Plus\"";


SetAttributes[FactorPlus,Listable];


FactorPlus[expr_Plus]:=Factor[expr];
FactorPlus[expr_]:=expr;


FactorListPlus::usage="FactorListPlus[expr] factors expr iff it has head \"Plus\" and gives a list of the factors, together with their exponents.";


FactorListPlus[expr_Plus]:=FactorList[expr];
FactorListPlus[expr_]:=Factors[expr];


Factors::usage="Factors[expr] returns the list of expr factors not trying to factorize it.";


Factors[expr_]:=Replace[Replace[{expr},Times->Sequence,{2},Heads->True],{x_^n_Integer:>{x,n},x_:>{x,1}},{1}]


Rookie::sorry="Sorry, I've done what I could.";


Options[Rookie]={Fermatica`UseFermat->False};


Rookie[ds_?DSystemQ,x_,e_,dns_List:Automatic,OptionsPattern[]]:=Module[{b,dens,points,left,leftss,right,rightss,projector,balance,transformation=IdentityMatrix[Length@ds]},
If[Notations[ds]=!={},Message[Rookie::sorry];Return[transformation]];
(*First, we find denominators*)
dens=Replace[dns,Automatic->Append[Denominators[ds],1/x]];
PrintTemporary["I see denominators ",dens];
If[Not[MatchQ[Expand[dens],{(x|_?(FreeQ[#,x]&)+x|1/x)...}]],Message[Rookie::sorry];Return[transformation]];
points=If[#===1/x,\[Infinity],Root[Function@@{x,#},1]]&/@dens;
PrintTemporary["I consider points ",points];
NewDSystem[b,x->ds[x],Print->False];
PrintTemporary["I have created a temporary differential system."];
While[True,
left=GetSubspaces[b,{x,#},e,Left,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]&/@points;
right=GetSubspaces[b,{x,#},e,Right,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]]&/@points;
leftss=DeleteCases[Reverse@SortBy[Flatten[MapIndexed[Function[{ss,k},{First@k,#,Plus@@Pick[ss,#,1]}&@IntegerDigits[#,2,Length@ss]&/@(Range[2^Length@ss]-1)],Map[Length,left,{2}]],1],Last],{__,0}];
PrintTemporary["I have constructed  left subspaces of dimensions ",Last/@leftss];
rightss=DeleteCases[Reverse@SortBy[Flatten[MapIndexed[Function[{ss,k},{First@k,#,Plus@@Pick[ss,#,1]}&@IntegerDigits[#,2,Length@ss]&/@(Range[2^Length@ss]-1)],Map[Length,right,{2}]],1],Last],{__,0}];
PrintTemporary["I have constructed right subspaces of dimensions ",Last/@rightss];
balance=Catch[Function[lss,(Function[rss,Quiet[projector=Projector[Flatten[Pick[left[[lss[[1]]]],lss[[2]],1],1],Flatten[Pick[right[[rss[[1]]]],rss[[2]],1],1]]];If[Union@@projector=!={0}&&lss[[1]]=!=rss[[1]],
PrintTemporary["I found projector of rank ",lss[[3]]];Throw[Balance[projector,{x,points[[lss[[1]]]],points[[rss[[1]]]]}]]]]/@Select[rightss,Last@#===Last[lss]&])]/@leftss;Throw[$Failed]];
If[balance===$Failed,Break[]];
Transform[b,balance,Print->False,Fermatica`UseFermat->OptionValue[Fermatica`UseFermat]];
PrintTemporary["I have applied the balance found."]
];
transformation=HistoryConsolidate[b,Inverse->False]
]


SetAttributes[unprotect,{HoldRest}]
unprotect[s_Symbol,expr_]:=If[MemberQ[Attributes[s],Protected],Unprotect[s];expr;Protect[s],expr]


ker[m_?MatrixQ]:=Module[{cs,l=Length@First@m (*# of cols*),cs1,eqs,sol},
cs=Table[Unique["c"],{l}];
eqs=Dot[m,cs];
sol=GaussSolve[eqs,cs];(*always should be a solution*)
cs1=Complement[cs,First/@sol];
If[cs1==={},
Return[{0&/@cs}],
Return[Transpose@Outer[Coefficient,cs/.sol,cs1]]
]
]


im=ker@*ker@*Transpose;


bjf::usage="bjf[\!\(\*
StyleBox[\"A\", \"TI\"]\),\!\(\*
StyleBox[\"B\", \"TI\"]\),\!\(\*
StyleBox[\"k\", \"TI\"]\)] constructs block matrix of the form ({
 {A, B, 0},
 {0, A, B},
 {0, 0, A}
}) where \!\(\*
StyleBox[\"A\", \"TI\"]\) is repeated \!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)times. In particular, bjf[\[Lambda],1,\!\(\*
StyleBox[\"k\", \"TI\"]\)] gives \!\(\*
StyleBox[\"k\", \"TI\"]\)*\!\(\*
StyleBox[\"k\", \"TI\"]\) Jordan cell.";
bjf[a_,b_,k_Integer]:=Module[{ap,bp},ArrayFlatten[IdentityMatrix[k]*ap+Rest[Transpose[IdentityMatrix[{k,k+1}]]]*bp/.{ap->a,bp->b}]];


obsolete::warn="The syntax `1` is obsolete. Use `2` instead."
obsolete[ex_,old_String->new_String]:=(Message[obsolete::warn,old,new];ex);
obsolete[ex_,___]:=ex;


patternQ[ex_]:=!FreeQ[ex,Pattern|Except|PatternTest|Blank|BlankSequence|BlankNullSequence|Alternatives];


spantolist[span_,l_]:=Replace[span,{Span[a_Integer,b_Integer]:>Range[Mod[a+l+1,l+1],Mod[b+l+1,l+1]],Span[a_Integer,All]:>Range[Mod[a+l+1,l+1],l]}]


End[];


GetIfExists[name_String]:=If [FileExistsQ[#],Get[#];Libra`Private`CPrint["Loaded "<>StringDrop[#,StringLength[DirectoryName[$LibraInputFileName]]]<>" (CRC32: "<>ToString[FileHash[#,"CRC32"]]<>")"]]&/@FileNames[name,{DirectoryName[$LibraInputFileName]}];


GetIfExists["Addons/*.m"];


EndPackage[]


If[($LibraUseFermat=MemberQ[$ContextPath,"Fermatica`"]),CPrint["Prepared to use Fermatica for matrix operations!"]];


If[NameQ["Global`$LibraTODO"]&&Symbol["Global`$LibraTODO"],CellPrint[Cell["todo:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@Libra`Private`todolist;
CellPrint[Cell["done:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[Checkmark] "<>#,{"Text",Small}]]&/@Libra`Private`donelist];
