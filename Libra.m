(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



System`GenCoefficientRules::usage="GenCoefficientRules[expr,vars] does the same as CoefficientRules[expr,vars], but applies also to noninteger powers.";


System`GenCoefficient::usage="GenCoefficient[expr,vars, pows] returns coefficient in front of the Times@@(vars^pows).";


System`GenCoefficientRules[expr_,var_]:=System`GenCoefficientRules[expr,{var}];
System`GenCoefficientRules[expr_List,vars_]:=System`GenCoefficientRules[#,vars]&/@expr;
System`GenCoefficientRules[expr_,vars_List]:=Module[
{ps=Table[Unique[],{Length@vars}],expanded,tov,v},
expanded=Expand[expr*Times@@(vars^ps)];
tov=DeleteDuplicates[Cases[expanded,(_.)(Times@@(vars^(Pattern[#,Blank[]]&/@ps))):>Evaluate[Times@@(vars^ps)->v@@ps],All]];
Thread[Last/@tov ->Last/@CoefficientRules[expanded/.tov,Last/@tov]]/.v->List/.Thread[ps->0]
];
System`GenCoefficient[expr_,var_,pow_]:=System`GenCoefficient[expr,{var},{pow}];
System`GenCoefficient[expr_,vars_List,pows_List]:=Module[{ps=Table[Unique[],{Length@vars}],expanded,v},
expanded=Expand[expr*Times@@(vars^ps)];
Coefficient[expanded/.Times@@(vars^Expand[ps+pows]):>v,v]
]


System`PartitionByLengths::usage="PartitionByLengths[list,lengths] splits list into chunks of the given leghts.\nExample:PartitionByLengths[{a,b,c,d,e,f},{3,1,2}] \[LongRightArrow] {{a,b,c},{d},{e,f}}";


System`PartitionByLengths[a_List,b_List]:=Module[{es=Accumulate[b],bs},
bs=Prepend[Most@es+1,1];
Take[a,#]&/@Transpose[{bs,es}]
]


System`ShuffleProduct::usage="ShuffleProduct[l1,l2] implements the shuffle product, e.g., ShuffleProduct[{a,b},{c,d}] \[LongRightArrow] {{a,b,c,d},{a,c,b,d},{a,c,d,b},{c,a,b,d},{c,a,d,b},{c,d,a,b}}.";


System`ShuffleProduct[a_List,b_List]:=Module[{chrs=Join[a,b],nums},nums=Range[Length[chrs]];Join@(Permute[chrs,#])&/@(Join[#,Complement[nums,#]]&/@Subsets[nums,{Length[a]}])]


System`StuffleProduct::usage="StuffleProduct[l1,l2] implements the stuffle product, e.g., StuffleProduct[{a,b},{c,d}] \[LongRightArrow]{{a,b,c,d},{a,b+c,d},{a,c,b,d},{a,c,b+d},{a+c,b,d},{a+c,b+d},{a,c,d,b},{a+c,d,b},{c,a,b,d},{c,a,b+d},{c,a,d,b},{c,a+d,b},{c,d,a,b}}.\nTo replace '+' in the above expression with function f, use the option Function\[Rule]f. E.g. StuffleProduct[{a,b},{c,d},Function\[Rule]f] \[LongRightArrow]{{a,b,c,d},{a,f[b,c],d},{a,c,b,d},{a,c,f[b,d]},{f[a,c],b,d},{f[a,c],f[b,d]},{a,c,d,b},{f[a,c],d,b},{c,a,b,d},{c,a,f[b,d]},{c,a,d,b},{c,f[a,d],b},{c,d,a,b}}.";


Options[System`StuffleProduct]={Function->Plus}


System`StuffleProduct[alist_List,blist_List,OptionsPattern[]]:=Module[{res,ar=Range[Length@alist],br=-Reverse@Range[Length@blist],p,s,l},
res=ShuffleProduct[ar,br];
res=Flatten[Outer[l,Sequence@@(List/@#//.{pre___,{a:Alternatives@@ar},{b:Alternatives@@br},post___}:>{pre,{s[a,b],p[a,b]},post})]&/@res]/.{s->Sequence,l->List}/.Thread[Join[ar,br]->Join[alist,blist]]/.p->OptionValue[Function]
]


System`TransposeYoungTableau::usage="TransposeYoungTableau[{\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"list\", \"TI\"], \(2\)]\),\[Ellipsis]}] transposes list of lists of non-increasing lengths.";
System`TransposeYoungTableau[yt_List]:=Module[{l=Length@First[yt],sq},Replace[Transpose[PadRight[#,l,sq]&/@yt],sq:>Sequence[],{2}]]


BeginPackage["Libra`"]


$LibraUseFermat=False;
$LibraVersion="1.0\[Beta]";


NewDSystem;


History;HistoryIndex;Undo;Redo;
HistoryAppend;HistoryAddExtra;HistoryDeleteExtra;HistoryConsolidate;
HistoryBurn;


Notations;AddNotation;ModNotation;RuleToNotation;NotationToRule


SubsystemsIndices;
LargestSubsystemsIndices;
EntangledBlocksIndices;
DependentRowIndices;
DependentColumnIndices;
OffDiagonalBlocksIndices;DiagonalBlocksIndices;


PickBasis;


UseFermat::usage="UseFermat is an option for many procedures which determines whether to use Fermat (Fermatica package required)";


ODot;OInverse;


Transform;ChangeVar;


TClosure;


Denominators;PolesPosition;PolesInfo;DenominatorsInfo;


DiagonalQ;
NilpotentQ;
FuchsianQ;
JFormQ;


JDecomposition;JDecompositionData;


JDTowers;JDSpace;JDData;


RatFuncQ;PolyQ;


Factors;FactorPlus;FactorListPlus;


LeadingOrder;


SeriesCoefficients;LeadingSeries;LeadingSeriesCoefficient;LeadingSeriesCoefficients;


PoincareRank;


DSystemQ;


Balance;VisBalancing;
VisTransformation;


A0ToSubspaces;A0A1ToSubspaces;GetSubspaces;Projector;


FactorOut;FactorDependence;


GaussSolve;


BlockTriangularToFuchsian;


FuchsifyBlock;


ToOneDE;ToCompanionDS;


BTSolve;


RadicalsUp;


HistoryCheck;HistoryChop;


PexpExpansion;
II;Protect[II];
II::usage="II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x] denotes iterated integral, \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary (with convention II[{},x]=1). II[{\!\(\*SubscriptBox[\(a\), \(n\)]\),\!\(\*SubscriptBox[\(a\), \(n - 1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]a\), \(1\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)] specifies \!\(\*SubscriptBox[\(x\), \(0\)]\). By definition, II[{\!\(\*SubscriptBox[\(x\), \(0\)]\),\[Ellipsis],\!\(\*SubscriptBox[\(x\), \(0\)]\)},x,\!\(\*SubscriptBox[\(x\), \(0\)]\)]=Log[x-\!\(\*SubscriptBox[\(x\), \(0\)]\)\!\(\*SuperscriptBox[\(]\), \(n\)]\)/n!."


SeriesSolutionData;ConstructSeriesSolution;


SpotCoefficients;


FactorLeadingLetter;FactorTrailingLetter;


InvertMod;QuolyMod;OQuolyMod;
ExtendedQuolyMod;
PolyLeadingOrder;
(*PolyLeadingTerm;*)


PolyKer;PolyPickBasis;PolyMatrixRank;PolyInverse;
PolyEValues;
PolyESpace;PolyProjector;
PolySeriesRules;PolySeriesCoefficient;


EValues;ESpace;


Begin["`Private`"]


SetAttributes[FCStaticMonitor,{HoldAll}];
FCStaticMonitor[code_,msg_String,delay_:0]:=If[$Notebooks,
Monitor[code,msg,delay],
WriteString["stdout","\n["<>msg];(WriteString["stdout","]"];#)&[code]
];
FCStaticMonitor[args__]:=Monitor[args];


SetAttributes[FCMonitor,{HoldAll}];
FCMonitor[code_,mon_,delay_:0,msg_String:""]:=If[$Notebooks,
Monitor[code,mon,delay],
If[msg=!="",WriteString["stdout","\n["<>msg]];(If[msg=!="",WriteString["stdout","]"]];#)&[code]
];


FCPrint[ex__]:=If[$Notebooks,Print[ex],Print@@(ToString/@{ex})];
FCPrintTemporary[ex__]:=If[$Notebooks,PrintTemporary[ex],Print@@(ToString/@{ex})];


FCPrint["\n******************** ",Style["Libra v"<>ToString[$LibraVersion],{Bold}]," ********************\n\
\!\(\*
StyleBox[\"Libra\",\nFontWeight->\"Bold\"]\) (\:2696) is a package for the manipulation with differential systems.\n\[Copyright] Roman N.Lee 2018.\nRead from: "<>$InputFileName<>"\nMD5: "<>ToString[FileHash[$InputFileName,"MD5"]]];


CWrite[msg_String]:=If[!$Notebooks,WriteString["stdout",msg]];


todolist={};
donelist={};
todo[s_String]:=AppendTo[todolist,s];
done[s_String]:=AppendTo[donelist,s];


todo["OffDiagonalBlocksIndices[_?DSystemQ]"]


History::usage="History[ds] is the central object. It is a list with the elements of the following form:
{M,\"Operation\",extra1\[Rule]\[Ellipsis],\[Ellipsis]}";


HistoryIndex::usage="HistoryIndex[ds] is the current position in the History[ds]";


History::first="Undo can not be done. Already at the beginning.";


History::last="Redo can not be done. Already at the end.";


History::nothing="History change not required.";


HistoryAppend::usage="HistoryAppend[ds,{M,{func,arg1,\[Ellipsis]},extra1\[Rule]\[Ellipsis],\[Ellipsis]}] adds the most recent entry to the history.";


Options[HistoryAppend]={HistoryChop->False,Print->True};


HistoryAppend::chop="Did not change history to avoid overwriting forward entries. Use HistoryChop[`1`] first or execute SetOptions[HistoryAppend,HistoryChop\[Rule]False]."


HistoryAppend[ds_Symbol?DSystemQ,event:{_Association,_List,___},OptionsPattern[]]:=If[
TrueQ[OptionValue[HistoryChop]||Length[History[ds]]<=HistoryIndex[ds]],
Unprotect[ds];History[ds]^=Append[Take[History[ds],HistoryIndex[ds]],event];
HistoryIndex[ds]^=HistoryIndex[ds]+1;Protect[ds];If[OptionValue[Print],Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]]<>".",Small]]],
Message[HistoryAppend::chop,ds]];


HistoryAddExtra::usage="HistoryAddExtra[ds_Symbol,extra1\[Rule]\[Ellipsis],\[Ellipsis]] adds some optional information to the current history event.";


Options[HistoryAddExtra]={Print->True};


HistoryAddExtra[ds_Symbol?DSystemQ,rules__Rule,OptionsPattern[]]:=(
Unprotect[ds];History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->Join[DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@First/@{rules}->_],{rules}]];
Protect[ds];
If[OptionValue[Print],Print[Style["Added extra(s) "<>StringRiffle[ToString/@First/@{rules},","]<>" to current history entry.",Small]]];)


HistoryDeleteExtra::usage="HistoryDeleteExtra[ds_Symbol,extra1,\[Ellipsis]] removes optional information from the current history event.";


Options[HistoryDeleteExtra]={Print->True};


HistoryDeleteExtra[ds_Symbol?DSystemQ,extras___,OptionsPattern[]]:=(
Unprotect[ds];History[ds]^=ReplacePart[History[ds],HistoryIndex[ds]->DeleteCases[History[ds][[HistoryIndex[ds]]],Alternatives@@extras->_]];
Protect[ds];
If[OptionValue[Print],Print[Style["Deleted extra(s) "<>StringRiffle[ToString/@extras,","]<>" from current history entry.",Small]]])


Undo[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]>n,
Unprotect[ds];Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]^=HistoryIndex[ds]-n]<>".",Small]];
Protect[ds];
History[ds][[HistoryIndex[ds],1]],Message[History::first]];


Undo[ds_?DSystemQ,All]:=(
Unprotect[ds];Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]^=1]<>".",Small]];
Protect[ds];History[ds][[HistoryIndex[ds],1]])


Redo[ds_?DSystemQ,n_Integer:1]:=If[HistoryIndex[ds]<=Length@History[ds]-n,Unprotect[ds];Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]^=HistoryIndex[ds]+n]<>".",Small]];Protect[ds];History[ds][[HistoryIndex[ds],1]],Message[History::last]];


Redo[ds_?DSystemQ,All]:=(Unprotect[ds];Print[Style["History length for "<>SymbolName[ds]<>" is "<>ToString[HistoryIndex[ds]^=Length@History[ds]]<>".",Small]];Protect[ds];History[ds][[HistoryIndex[ds],1]]);


HistoryChop::usage="HistoryChop[ds_] chops off forward entries in history. Use before applying HistoryConsolidate.";


HistoryChop[ds_?DSystemQ]:=(Unprotect[ds];History[ds]^=Take[History[ds],HistoryIndex[ds]];Protect[ds];HistoryIndex[ds])


HistoryConsolidate::usage="HistoryConsolidate[ds] consolidates history";


HistoryConsolidate::err="Undo history entry is met.";
HistoryConsolidate::chop="Did not change history to avoid overwriting forward entries. Use HistoryChop[`1`] first."


Options[HistoryConsolidate]={HistoryChop->False,HistoryAppend->True,
Inverse->True(*whether to calculate inverse transformation matrix*)
};


HistoryConsolidate[ds_?DSystemQ,OptionsPattern[]]:=Module[{T=IdentityMatrix[Length@ds],Ti=IdentityMatrix[Length@ds],i,ii,t,start,end,val,old,new,subs,inv=OptionValue[Inverse]},
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[Take[History[ds],HistoryIndex[ds]],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
old=new=subs=Keys[val];
end=HistoryIndex[ds];
CWrite["\n"<>ToString[end-start]<>" dots:\n"];
FCMonitor[Do[
CWrite["."];
Replace[History[ds][[i,2]],{
{Transform,ds,tt_?SquareMatrixQ}:>(T=ODot[T,tt];If[inv,Ti=ODot[OInverse[tt],Ti]]),
{Transform,ds,tt_?SquareMatrixQ,ii_}:>((*Modified 14.05.2019*)(*(*Deleted 14.05.2019*)t=IdentityMatrix[Length@ds];t[[ii,ii]]=tt;T=ODot[T,t];If[inv,Ti=ODot[OInverse[t],Ti]](*/Deleted 14.05.2019*)*)
(*Added 14.05.2019*)T[[All,ii]]=ODot[T[[All,ii]],tt];If[inv,Ti[[ii]]=ODot[OInverse[tt],Ti[[ii]]]](*/Added 14.05.2019*)
(*/Modified 14.05.2019*)),
{Transform,ds,tt:{_?SquareMatrixQ,_?SquareMatrixQ}}:>(T=ODot[T,tt[[1]]];If[inv,Ti=ODot[tt[[2]],Ti]]),
{Transform,ds,tt:{_?SquareMatrixQ,_?SquareMatrixQ},ii_}:>(
(*Modified 14.05.2019*)
T[[All,ii]]=ODot[T[[All,ii]],tt[[1]]];
If[inv,
Ti[[ii]]=ODot[tt[[2]],Ti[[ii]]]]
(*/Modified 14.05.2019*)),
{ChangeVar,ds,tt_,nw_,___}:>(T=Factor[T/.tt];If[inv,Ti=Factor[Ti/.tt]];subs=Factor[subs/.tt];new=nw),
{Factor,ds}:>(T=Factor[T];If[inv,Ti=Factor[Ti]]),
{Simplify,ds,tt___}:>(T=Simplify[T,tt];If[inv,Ti=Simplify[Ti,tt]];subs=Simplify[subs,tt]),
{Map,f_,ds,tt___}:>(T=Map[f,T,tt];If[inv,Ti=Map[f,Ti,tt]];),
{MapAt,f_,ds,tt___}:>(T=MapAt[f,T,tt];If[inv,Ti=MapAt[f,Ti,tt]]),
{Undo,__}:>(Message[HistoryConsolidate::err];Abort[])
}
],
{i,start+1,end}],
Overlay[{ProgressIndicator[i,{start,end}],ToString[i-start]<>"/"<>ToString[end-start]},Alignment->Center]];
If[TrueQ@OptionValue[HistoryAppend],
If[TrueQ@OptionValue[HistoryChop]||Length@History[ds]<=HistoryIndex[ds],
HistoryAppend[ds,{val,{Undo,ds,end-start}}];
ChangeVar[ds,Thread[old->subs],new];
If[inv,
Transform[ds,{T,Ti}],
Transform[ds,T]
],
Message[HistoryConsolidate::chop,ds]
]];
T
]


todo["implement HistoryRewrite"];


HistoryCheck::usage="HistoryCheck[ds_] checks history consistency. It simply redoes all transformations and checks whether the same result is obtained.";


HistoryCheck::inconsistent="History[`1`] is inconsistent at index `2`.";
HistoryCheck[des_]:=Module[
{m,i,hi=HistoryIndex[des],mn,action},
CWrite["\n"<>ToString[hi]<>" dots:\n"];
FCMonitor[
Do[
CWrite["."];
mn=History[des][[i,1]];
action=History[des][[i,2]]/.des->m;
#1[##2]&@@action;
(*Print[m];Print[mn];*)
If[!TrueQ@(Union[Keys[mn]]===Union[Keys[m[]]]&&(And@@(MatchQ[Factor[mn[#]-m[#]],{{0...}...}]&/@Keys[mn]))),Message[HistoryCheck::inconsistent,des,i];Return[$Failed]];
,{i,hi}],
Overlay[{ProgressIndicator[i,{1,hi}],i},Alignment->Center]
];
Print["History is consistent!"];
]


HistoryBurn::err="Can not burn!";


HistoryBurn::usage="HistoryBurn[ds] "


HistoryBurn[ds_?DSystemQ]:=Module[{T=IdentityMatrix[Length@ds],i,t,start,end,val},
(*First, calculate transformation. We move in history up to the first Undo[ds,All] or first entry*)
(*starting index: either 1 or index of first full undo*)
start=Position[History[ds],{_,{Undo,ds,_}|{NewDSystem,ds,__},___},{1}][[-1,1]];
val=History[ds][[start,1]];
end=HistoryIndex[ds];
If[val=!=History[ds][[1,1]],Message[HistoryBurn::err];Return[$Failed]];
Unprotect[ds];
History[ds]^=Prepend[History[ds][[start+1;;end]],History[ds][[1]]];
HistoryIndex[ds]^=Length@History[ds];
Protect[ds];
]


todo["rethink how HistoryBurn should work"];


NewDSystem::usage="NewDSystem[ds,{x->Mx, y->My,\[Ellipsis]}] defines a new differential system associated with the variable ds.";
NewDSystem::size="Size of the systems mismatch.";
NewDSystem::error="Something went wrong. Aborting...";


Options[NewDSystem]={Print->True};


Notations::usage="Notations[ds] is a list of notations used."


Notations[ds_?DSystemQ]:=Association[];


NewDSystem[ds_,def_Rule,opts:OptionsPattern[]]:=NewDSystem[ds,{def},opts]
NewDSystem[ds_Symbol,defs_Association,opts:OptionsPattern[]]:=NewDSystem[ds,defs/.Association->List,opts]
NewDSystem[ds_Symbol,defs:{(_Symbol->_?SquareMatrixQ)..},opts:OptionsPattern[]]:=Module[{l},
Quiet[Unprotect[ds];Clear[ds]];(*in case ds was defined earlier*)
Check[
History[ds]^={};HistoryIndex[ds]^=0;
DSystemQ[ds]^=True;
Notations[ds]^=Association[];
(*will be used in arguments patterns*)l=Length/@Last/@defs;
If[!(SameQ@@l),Message[NewDSystem::size]];
Length[ds]^=First@l;
HistoryAppend[ds,{Association[defs],{NewDSystem,ds,Association[defs]}},Print->OptionValue[Print]];
(*ToExpression[#<>"$M:=History["<>#<>"][[HistoryIndex["<>#<>"],1]];Protect["<>#<>"$M]"]&[SymbolName[ds]]*),
Message[NewDSystem::error];Abort[];
];
Unprotect[ds];
redefineOperations[ds];
Protect[ds];
If[TrueQ@OptionValue[Print],Print["Successfully created differential system for "<>ToString@Length@ds<>" functions of "<>StringRiffle[ToString/@First/@defs,","]<>"."];
(*Print["Next, you might want to find denominators appearing. See ?Denominators."];*)];
ds::usage="Differential system for "<>ToString@Length@ds<>" functions of "<>StringJoin@@Riffle[ToString/@First/@defs,","]<>".";

]


redefineOperations[ds_Symbol]:=Module[{t1,i,keys,l},
(*(#[ds,opts___]^:=Function[ds$M,t1=#[ds$M,opts];If[t1===ds$M,Message[History::nothing],HistoryAppend[ds,{t1,{#,ds,opts}}];t1]][ds[]];)&/@{Factor,Simplify,FullSimplify,Apart,Together};*)
Function[fun,fun[ds,opts___]^:=Map[fun[#,opts]&,ds,{2}];]/@{Factor,Simplify,FullSimplify,Apart,Together};
Variables[ds]^:=Keys[History[ds][[HistoryIndex[ds],1]]];
Protect/@Variables[ds];
ds[x_]:=(History[ds][[HistoryIndex[ds],1]])[x];
ds[]:=ds[[]];
ds/:Part[ds,a___]:=Map[Part[#,a]&,History[ds][[HistoryIndex[ds],1]]];
ds/:Map[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
CWrite["\n"<>ToString[l]<>" dots:\n"];
FCMonitor[(t1[#]=Map[(i++;CWrite["."];#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}]];
HistoryAppend[ds,{t1,{Map[f,#1,##2]&,ds,pars}}]);
ds/:MapAt[f_,ds,pars___]:=(t1=History[ds][[HistoryIndex[ds],1]];keys=Keys[t1];
l=(Length@keys)*Length[ds]^2;i=0;
CWrite["\n"<>ToString[l]<>" dots:\n"];
FCMonitor[(t1[#]=MapAt[(i++;CWrite["."];#)&@*f,t1[#],pars])&/@keys,
ProgressIndicator[i,{0,l}]];
HistoryAppend[ds,{t1,{MapAt[f,#1,##2]&,ds,pars}}])
]


DSystemQ::usage="DSystemQ[ds] returns True if ds is a differential system.";
DSystemQ[_]=False;


InvertMod::usage="InvertMod[\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(1\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the polynomial \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), such that \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(1\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)= 1 mod \!\(\*SubscriptBox[
StyleBox[\"P\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


InvertMod[poly1_,poly2_,x_]:=Module[{gcd,u,v},{gcd,{u,v}}=PolynomialExtendedGCD[poly1,poly2,x];If[FreeQ[gcd,x],u/gcd,1/0]
]


QuolyMod::usage="QuolyMod[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the \"remainder\" \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) of the rational function \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) when divided by polynomial \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\). Therefore, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[QuolyMod]={Check->False};
QuolyMod::wrongargs="Something wrong with the arguments of QuolyMod.";


QuolyMod[quoly_List,args__,opts:OptionsPattern[]]:=QuolyMod[#,args,opts]&/@quoly;QuolyMod[quoly_,poly_,x_,OptionsPattern[]]:=Module[{num,den},
If[OptionValue[Check]&&!( RatFuncQ[quoly,x]&&PolyQ[poly,x]),Message[QuolyMod::wrongargs];Abort[]];
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
Together@PolynomialRemainder[InvertMod[den,poly,x]*num,poly,x]
]


ExtendedQuolyMod::usage="ExtendedQuolyMod[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the pair {\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)}, where \!\(\*
StyleBox[\"k\", \"TI\"]\) is the \"leading order\" and \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the \"remainder\". Therefore, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)(\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[ExtendedQuolyMod]={Check->False};
ExtendedQuolyMod::wrongargs="Something wrong with the arguments of ExtendedQuolyMod.";


ExtendedQuolyMod[quoly_List,args__,opts:OptionsPattern[]]:=ExtendedQuolyMod[#,args.opts]&/@quoly;ExtendedQuolyMod[quoly_,poly_,x_,OptionsPattern[]]:=Module[{num,num1,den,den1,rmndr,k=0},
If[FreeQ[poly,x],Return[\[Infinity]]];
If[OptionValue[Check]&&!( RatFuncQ[quoly,x]&&PolyQ[poly,x]),Message[PolyLeadingOrder::wrongargs];Abort[]];
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
If[PossibleZeroQ[num],Return[\[Infinity]]];
While[True,
{den1,rmndr}=PolynomialQuotientRemainder[den,poly,x];
If[rmndr=!=0,Break[]];
den=den1;k--;
];
While[True,
{num1,rmndr}=PolynomialQuotientRemainder[num,poly,x];
If[rmndr=!=0,Break[]];
num=num1;k++;
];
{k,QuolyMod[num/den,poly,x]}
]


PolyLeadingOrder::usage="PolyLeadingOrder[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the \"leading order\"  \!\(\*
StyleBox[\"k\", \"TI\"]\) such that, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where both the numerator and denominator of \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) are mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[PolyLeadingOrder]={Check->False,Parallelize->False};
PolyLeadingOrder::wrongargs="Something wrong with the arguments of PolyLeadingOrder.";


PolyLeadingOrder[ds_?DSystemQ,poly_,x_,opts:OptionsPattern[]]:=PolyLeadingOrder[ds[x],pol_,x,opts]


PolyLeadingOrder[quoly_List,args__,opts:OptionsPattern[]]:=If[OptionValue[Parallelize],
DistributeDefinitions[PolyLeadingOrder];
Min[ParallelMap[PolyLeadingOrder[#,args,opts]&,quoly,{ArrayDepth[quoly]}]],
Min[Map[PolyLeadingOrder[#,args,opts]&,quoly,{ArrayDepth[quoly]}]]
];


PolyLeadingOrder[quoly_,poly_,x_,OptionsPattern[]]:=Module[{num,den,rmndr,k=0},
If[FreeQ[poly,x],Return[\[Infinity]]];
If[OptionValue[Check]&&!( RatFuncQ[quoly,x]&&PolyQ[poly,x]),Message[PolyLeadingOrder::wrongargs];Abort[]];
{num,den}=Through[{Numerator,Denominator}@Together@quoly];
If[PossibleZeroQ[num],Return[\[Infinity]]];
While[True,
{den,rmndr}=PolynomialQuotientRemainder[den,poly,x];
If[rmndr=!=0,Break[]];
k--;
];
While[True,
{num,rmndr}=PolynomialQuotientRemainder[num,poly,x];
If[rmndr=!=0,Break[]];
k++;
];
k
]


todo["Redefine PolyLeadingTerm for matrices."];


SetAttributes[RadicalsUp,Listable];
RadicalsUp[ex_]:=Module[{den=Denominator[ex],num,denc},
num=den*ex;
denc=(den/.{x:Power[_,1/2]:>-x});
If[denc=!=den,Factor[Expand[num*denc]/Expand[den*denc]],ex]
];


PolyKer::usage="PolyKer[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of nullvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} such that each \!\(\*
StyleBox[\"u\", \"TI\"]\) satisfies \!\(\*
StyleBox[\"mu\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\)).\nPolyKer[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";


PolyKer[m_?MatrixQ,poly_,x_,mod:(True|False):True]:=PolyPickBasis[SortBy[polyKer[m,poly,x,mod],Total[Exponent[#,x]]&],poly,x,False]


polyKer[m_,poly_,x_,mod:(True|False):True]:=Module[{k=Exponent[poly,x],n=Dimensions[m][[2]],id,mr,xm,evs},
If[mod,mr=QuolyMod[m,poly,x],mr=m];
mr=id[Coefficient[mr,x,#]]&/@Range[0,k-1];
xm=CoefficientList[poly,x];(*action of x as a matrix from the right*)
xm=Append[Rest[IdentityMatrix[k]],-Most[xm]/Last[xm]];
evs=Factor[(x^Range[0,k-1]).Partition[#,n]]&/@NullSpace[ArrayFlatten[Transpose@NestList[Dot[#1,xm]&,mr,k-1]/.id->Identity]]
]


PolyPickBasis::usage="PolyPickBasis[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] picks a basis out of \!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\) vectors in the field \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\) where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is an irreducible polynomial. The order does not change and the left-most positions are preferable.\nPolyPickBasis[\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] means that \!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\) does not need QuolyMod beforehand."


PolyPickBasis[evs_,poly_,x_,mod:(True|False):True]:=Module[{basis={},basis1},
Scan[(basis1=Append[basis,#];If[polyKer[Transpose@basis1,poly,x,mod]==={},basis=basis1])&,evs];
basis
]


PolyMatrixRank::usage="PolyMatrixRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a matrix rank of \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nPolyMatrixRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";


PolyMatrixRank[m_?MatrixQ,poly_,x_,mod:(True|False):True]:=Length@First@m-Length[PolyKer[m,poly,x]]


PolyInverse::usage="PolyInverse[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the inverse of \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nPolyInverse[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),False] assumes that \!\(\*
StyleBox[\"m\", \"TI\"]\) does not need QuolyMod beforehand.";
PolyInverse[m_?SquareMatrixQ,poly_,x_,mod:(True|False):True]:=Module[{m1},If[mod,m1=QuolyMod[m,poly,x],m1=m];m1=QuolyMod[OInverse[m1],poly,x]]


PolyEValues::usage="PolyEValues[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of the eigenvalues of the square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\) with entries in the field \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\) where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is an irreducible polynomial. An eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) is defined as a root of \!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"\[Lambda]P\", \"TI\"]\)\!\(\*
StyleBox[\"'\", \"TI\"]\)\!\(\*
StyleBox[\"|\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\)) provided that this root is independent of \!\(\*
StyleBox[\"x\", \"TI\"]\).";
PolyEValues::error="Can not determine eigenvalues. Aborting...";


PolyEValues[m_,poly_,x_Symbol]:=Module[
{chpoly,a},
chpoly=Factor@QuolyMod[CharacteristicPolynomial[m,a]/.a->a D[poly,x],poly,x];
Replace[a,#]&/@Flatten[Replace[Factors@chpoly,{_?(FreeQ[#,a]&):>Sequence[],{p_?(FreeQ[#,x]&),n_}:>ConstantArray[Solve[p==0,a],n],_:>(Message[PolyEValues::error];Abort[])},{1}]]
]


EValues::usage="EValues[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list of the eigenvalues of the square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). Supposed to be faster than native Eigenvalues";


EValues[m_]:=Module[
{chpoly,a},
chpoly=Factor@CharacteristicPolynomial[m,a];
Replace[a,#]&/@Flatten[Replace[Factors@chpoly,{_?(FreeQ[#,a]&):>Sequence[],{p_,n_}:>ConstantArray[Solve[p==0,a],n]},{1}]]
]


PolyESpace::usage="PolyESpace[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)] gives a list of the eigenvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} corresponding to the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\). Each \!\(\*
StyleBox[\"u\", \"TI\"]\) is such that (\!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"\[Lambda]P\", \"TI\"]\)\!\(\*
StyleBox[\"'\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"u\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\)(mod \!\(\*
StyleBox[\"p\", \"TI\"]\))."


PolyESpace[m_?SquareMatrixQ,poly_,x_,\[Lambda]_]:=PolyKer[m-\[Lambda] IdentityMatrix[Length@m] D[poly,x],poly,x]


PolyESpace[m_?SquareMatrixQ,poly_,x_,\[Lambda]s_List]:=Join@@(PolyESpace[m,poly,x,#]&/@\[Lambda]s)


PolyESpace[m_?SquareMatrixQ,poly_,x_,All]:=Join@@(PolyESpace[m,poly,x,#]&/@DeleteDuplicates[PolyEValues[m,poly,x]])
PolyESpace[m_?SquareMatrixQ,poly_,x_]:=PolyESpace[m,poly,x,All]


done["PolyESpace: remove linearly dependent vectors."]
done["PolyESpace: allow for a list of \[Lambda]s."]


ESpace::usage="ESpace[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)] gives a list of the eigenvectors {\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"u\", \"TI\"], \(2\)]\),\[Ellipsis]} corresponding to the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\)."


ESpace[m_?SquareMatrixQ,\[Lambda]_]:=NullSpace[m-\[Lambda] IdentityMatrix[Length@m]]


ESpace[m_?SquareMatrixQ,\[Lambda]s_List]:=Join@@(ESpace[m,#]&/@\[Lambda]s)


ESpace[m_?SquareMatrixQ,All]:=Join@@(ESpace[m,#]&/@DeleteDuplicates[EValues[m]])
ESpace[m_?SquareMatrixQ]:=ESpace[m,All]


PolyProjector::usage="PolyProjector[\!\(\*
StyleBox[\"ulist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[
StyleBox[\"u\", \"TI\"], \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"vlist\", \"TI\"]\)\!\(\*
StyleBox[\":\", \"TI\"]\)\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"v\", \"2\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] constructs a projector \!\(\*
StyleBox[\"P\", \"TI\"]\) with entries in \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"]\", \"TI\"]\)\!\(\*
StyleBox[\"/\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\).\nNote that if one of \!\(\*
StyleBox[\"ulist\", \"TI\"]\) or \!\(\*
StyleBox[\"vlist\", \"TI\"]\) is independent of \!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"P\", \"TI\"]\) is also a projector in the usual sense.";


PolyProjector::error="Can not construct projector.";
PolyProjector[u_,v_,poly_,x_]:=Module[{md,ut=Transpose[u]},
Check[md=PolyInverse[ODot[v,ut],poly,x],Message[PolyProjector::error];Return[ConstantArray[0,{Length@First[v],Length@ut}]]];
QuolyMod[ODot[ut,md,v],poly,x]
]


PickBasis::usage="PickBasis[{v1,v2,...}] constructs basis in linear span of vectors v1,v2,\[Ellipsis]. Basically, it removes all dependent vectors from the given list.";


PickBasis[vectors:{__List}]:=Module[{r=0,basis={},rrbasis={}},
Scan[(If[MatrixRank[AppendTo[basis,#]]>r,r++,basis=Most[basis]])&,vectors];basis
]


JDTowers[r_]:=Flatten[JDTowers[r,#]&/@DeleteDuplicates@EValues[r],1];
JDTowers[r_,All]:=Flatten[JDTowers[r,#]&/@DeleteDuplicates@EValues[r],1];
JDTowers[r_?SquareMatrixQ,evs_List]:=Flatten[JDTowers[r,#]&/@evs,1];
JDTowers[r_?SquareMatrixQ,ev_]:=Module[{vecs,vecs1,vecs2,l=Length[r],m,k=0,plist={},ns,rlist={}},
m=r-IdentityMatrix[l]*ev;
vecs=NullSpace[m];
While[Length[vecs]>k,
AppendTo[plist,Length[vecs]-k];
k=Length@vecs;
vecs1=If[(ns=NullSpace[vecs])==={},IdentityMatrix[l],SortBy[NullSpace[ODot[ns,m]],ByteCount]];
Scan[(vecs2=Append[vecs,#];If[MatrixRank[vecs2]===Length[vecs2],vecs=vecs2;])&,vecs1]
];
If[plist==={},Return[{}]];
rlist=PartitionByLengths[vecs,plist];
Do[rlist[[i]]=Join[ODot[rlist[[i+1]],Transpose@m],rlist[[i]]],{i,Length@rlist-1,1,-1}];
rlist=PartitionByLengths[PickBasis[Flatten[rlist,1]],plist];
TransposeYoungTableau[rlist]
]


JDSpace[r_?SquareMatrixQ,a___]:=Flatten[JDTowers[r,a],1]


JDData::usage="JDData[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives data for the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result has a form {{\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\),\!\(\*
StyleBox[\"ulist\", \"TI\"]\),\!\(\*
StyleBox[\"vlist\", \"TI\"]\)},...} where each element corresponds to Jordan cell with the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) , \!\(\*
StyleBox[\"ulist\", \"TI\"]\) being a Jordan chain vectors, starting from the eigenvectors, and \!\(\*
StyleBox[\"vlist\", \"TI\"]\) being the same for transposed matrix. Note that dual bases are \!\(\*
StyleBox[\"ulist\", \"TI\"]\) and Reverse[\!\(\*
StyleBox[\"vlist\", \"TI\"]\)].";


JDData[m_?SquareMatrixQ]:=Module[{
evs=DeleteDuplicates@EValues[m],
us,
vs
},
us=JDTowers[m,#]&/@evs;
evs=Flatten[MapThread[ConstantArray,{evs,Length/@us}],1];
us=Flatten[us,1];
vs=Factor[Reverse/@PartitionByLengths[Inverse[Transpose[Flatten[us,1]]],Length/@us]];
Transpose[{evs,us,vs}]
]


JDecomposition::usage="JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\)] yields the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result is a list {\!\(\*
StyleBox[\"b\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)} where \!\(\*
StyleBox[\"b\", \"TI\"]\) is a similarity matrix and \!\(\*
StyleBox[\"n\", \"TI\"]\) is the Jordan canonical form of \!\(\*
StyleBox[\"m\", \"TI\"]\). JDecomposition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"l\", \"TI\"]\)] does the same, except that it puts \!\(\*
StyleBox[\"l\", \"TI\"]\) above diagonal instead of 1.";


JDecomposition[m_?SquareMatrixQ]:=Module[
{s,d,a,b,p,jc,n=Length@m},
Check[{s,a}=JordanDecomposition[m],Return[$Failed]];
s=Factor@s;
a=Simplify@Transform[m,s];
If[!JFormQ[a],Return[$Failed]];
(*Ugly hack to deal with Mathematica's bugs related to JordanDecomposition*)
d=DiagonalMatrix[FoldList[If[#2===0,1,#1/#2]&,1,Diagonal[a,1]]];s=ODot[s,d];a=Simplify@Transform[a,d];
{s,a}
]


JDecompositionData::usage="JDecompositionData[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives data for the Jordan decomposition of a square matrix \!\(\*
StyleBox[\"m\", \"TI\"]\). The result has a form {{\!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\),\!\(\*
StyleBox[\"ulist\", \"TI\"]\),\!\(\*
StyleBox[\"vlist\", \"TI\"]\)},...} where each element corresponds to Jordan cell with the eigenvalue \!\(\*
StyleBox[\"\[Lambda]\", \"TI\"]\) , \!\(\*
StyleBox[\"ulist\", \"TI\"]\) being a Jordan chain vectors, starting from the eigenvectors, and \!\(\*
StyleBox[\"vlist\", \"TI\"]\) being the same for transposed matrix. Note that dual bases are \!\(\*
StyleBox[\"ulist\", \"TI\"]\) and Reverse[\!\(\*
StyleBox[\"vlist\", \"TI\"]\)].";


JDecompositionData[m_]:=Module[{
n=Length@m,
t,j,
inds,
sizes,
evals,
us,vs
},
{t,j}=JDecomposition[m];
inds=Flatten[{0,Position[Diagonal[j,1],0,{1}],n}];
sizes=Differences[inds];
Assert[n===Plus@@sizes];
evals=j[[#,#]]&/@Rest[inds];
us=PartitionByLengths[Transpose[t],sizes];
vs=Factor[Reverse/@PartitionByLengths[Inverse[t],sizes]];
(*Outer[ODot,Flatten[vs,1],Flatten[us,1],1](*supposed to be identity matrix*)*)
Transpose[{evals,us,vs}]
]


GaussSolve::usage="GaussSolve[eqs,vars] implements gauss method of the solution of linear equations. Option Continue\[Rule]True|False defines how the procedure proceeds when hitting the equation that can not be satisfied (like 1\[Equal]0). With Continue\[Rule]True such equation is simply neglected, and with Continue\[Rule]False the procedure immediately returns $Failed (i.e., no solution).";


GaussSolve::inconsistent="Inconsistent equation encountered.";


Options[GaussSolve]={Continue->True};


GaussSolve[eqs_,vars_,OptionsPattern[]]:=Module[{sol1,res,i=0,l=Length@eqs,sf,cnt=TrueQ[OptionValue[Continue]]},
sf=Collect[#,vars,Together]&;
CWrite["\n"<>ToString[l]<>" dots:\n"];
FCMonitor[
Catch[Fold[
(i++;CWrite["."];Quiet[Check[
{sol1}=Quiet[Solve[0==sf[#2/.#1],vars],{Solve::svars}],
sol1={};If[cnt,Message[GaussSolve::inconsistent],Throw[$Failed]],
{Set::shape}],{Set::shape}];Join[(#1->sf[#2/.sol1])&@@@#1,sol1])&,{},eqs]],
Overlay[{ProgressIndicator[i,{0,l}],ToString[i]<>"/"<>ToString[l]},Alignment->Center]]
]


todo["Implement GaussSolve for matrices. Or at least better version of NullSpace."]


NilpotentQ::usage="NilpotentQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is nilpotent.";
NilpotentQ[m_?SquareMatrixQ]:=Module[{x},Collect[CharacteristicPolynomial[m,x],x,Factor]===(-x)^Length@m]
NilpotentQ[_]=False;


DiagonalQ::usage="DiagonalQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is diagonal.";DiagonalQ[A_?SquareMatrixQ]:=MatchQ[Equal@@@Position[A,Except[0],{2},Heads->False],{True..}];
DiagonalQ[_]=False;


PolyQ::usage="PolyQ[expr,x] gives True if expr is a polynomial function of x.\nPolyQ[{a,b,...},x] gives True iff PolyQ[a,x]&&PolyQ[b,x]&&..=True.";
Module[{p},
PolyQ[expr_,x_]:=Catch[p[expr,x];True];

SetAttributes[p,Listable];
p[ex:(_Plus|_Times),x_]:=p[List@@ex,x];
p[Power[ex_,_Integer?Positive],x_]:=p[ex,x];
p[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


RatFuncQ::usage="RatFuncQ[expr,x] gives True if expr is a rational function of x.\nRatFuncQ[{a,b,...},x] gives True iff RatFuncQ[a,x]&&RatFuncQ[b,x]&&..=True.";
Module[{rf},
RatFuncQ[expr_,x_]:=Catch[rf[expr,x];True];

SetAttributes[rf,Listable];
rf[ex:(_Plus|_Times),x_]:=rf[List@@ex,x];
rf[Power[ex_,_Integer],x_]:=rf[ex,x];
rf[ex_,x_]:=If[!(MatchQ[ex,x]||FreeQ[ex,x]),Throw@False];
]


JFormQ::usage="JFormQ[\!\(\*
StyleBox[\"m\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) is a Jordan form.";
JFormQ[{{_}}]=True;
JFormQ[A_?SquareMatrixQ]:=Module[
{
d=Diagonal[A],
c1=DeleteDuplicates[Flatten[{Diagonal[A,#]&/@Range[2,Length@A-1],Diagonal[A,#]&/@Range[1-Length@A,-1]}]]==={0}
},
c1&&And@@(d[[#]]===d[[#+1]]&/@Flatten[Position[Diagonal[A,1],Except[0],{1},Heads->False]])
];
JFormQ[_]=False;


FuchsianQ::usage="FuchsianQ[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]  gives True if \!\(\*
StyleBox[\"m\", \"TI\"]\) has only simple poles in \!\(\*
StyleBox[\"x\", \"TI\"]\).";FuchsianQ[m_,x_]/;RatFuncQ[m,x]:=MatchQ[DenominatorsInfo[m,x],{{_,_?NonPositive}...}]
FuchsianQ[_]=False;


TClosure::usage="TClosure[m_?MatrixQ] calculates transitive closure of the relation given by m.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";


TClosure[m_?SquareMatrixQ]:=tclosure[m,1]


tclosure::usage="tclosure[m_,d:(1|0):1] calculates transitive closure of the relation given by m. If the second argument is 0, the relation is symmetrized.\n  Try\n(MatrixPlot/@{#,TClosure[#]})&[{{1,0,0,0},{1,0,0,0},{0,1,1,1},{0,0,1,0}}]";
tclosure[m_,d:(1|0):1,p_:Except[0]]:=Module[{paths,edges,newpaths},
paths={#->#&/@Range[Length@m]};(*vertices*)
edges=Complement[Rule@@@Position[m,p,{2},Heads->False],Join@@paths];
If[d===0,edges=DeleteDuplicates[Join[edges,Reverse/@edges]]];
AppendTo[paths,edges];
edges=Dispatch[edges];
While[{}!=(newpaths=Complement[DeleteDuplicates@Flatten[Thread[#1->ReplaceList[#2,edges]]&@@@Last@paths],Join@@paths]),
AppendTo[paths,newpaths]
];
ReplacePart[ConstantArray[0,Take[Dimensions@m,2]],List@@@Flatten[paths]->1]
]


TClosure[ds_?DSystemQ]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[tc===TClosure,
lc=Transpose[Values[ds[[]]],{3,1,2}];
tc=tclosure[lc,1,Except[{0..}]];
HistoryAddExtra[ds,TClosure->tc],
Print[Style["Read TClosure from extras.",Small]]
];
tc
]


TClosure[as_Association]:=Module[{tc,lc},
tc=TClosure/.Drop[History[ds][[HistoryIndex[ds]]],2];
lc=Transpose[Values[ds[[]]],{3,1,2}];
tclosure[lc,1,Except[{0..}]]
]


SubsystemsIndices::usage="SubsystemsIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} with each element being the list of indices for the valid subsystem."


SubsystemsIndices[m_?SquareMatrixQ,tc:(True|False):False]:=SortBy[DeleteDuplicates[Flatten[Position[#,1,{1}]]&/@If[tc,m,TClosure[m]]],{Last@#,Length@#}&]


SubsystemsIndices[ds_?DSystemQ,tc:(False):False]:=SubsystemsIndices[TClosure[ds],True]


LargestSubsystemsIndices::usage="LargestSubsystemsIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} with each element being the list of indices for the valid largest subsystem."


LargestSubsystemsIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{ss=Reverse@SortBy[SubsystemsIndices[m,tc],Length],left=Range[Length@m],left1,res={}},
Do[If[left=!=(left1=Complement[left,ss[[i]]]),left=left1;PrependTo[res,ss[[i]]]],{i,Length@ss}];
res
]


LargestSubsystemsIndices[ds_?DSystemQ,tc:(False):False]:=LargestSubsystemsIndices[TClosure[ds],True]


EntangledBlocksIndices::usage="EntangledBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to lower block-triangular form. The partition indicates separate blocks. The order guarantees that dependent blocks appear earlier.";


EntangledBlocksIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{ss},
ss=SubsystemsIndices[m,tc];
Table[Complement@@Reverse[Take[ss,i]],{i,Length@ss}]]


EntangledBlocksIndices[ds_?DSystemQ,tc:(False):False]:=EntangledBlocksIndices[TClosure[ds],True]


OffDiagonalBlocksIndices::usage="OffDiagonalBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a list of pairs {{{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}},\[Ellipsis]} such that each pair corresponds to the indices of the off-diagonal block. The order should be good for treating blocks with BlockTriangularToFuchsian.";


OffDiagonalBlocksIndices[m_?SquareMatrixQ,tc:(True|False):False]:=Module[{ss,eb,f},
ss=SubsystemsIndices[m,tc];
eb=Table[Complement@@Reverse[Take[ss,i]],{i,Length@ss}];
Flatten[Table[If[SubsetQ[ss[[i]],eb[[j]]],eb[[{i,j}]],Unevaluated[Sequence[]]],{i,Length@ss},{j,i-1,1,-1}],1]
]


OffDiagonalBlocksIndices[ds_?DSystemQ,tc:(False):False]:=OffDiagonalBlocksIndices[TClosure[ds],True]


DiagonalBlocksIndices::usage="DiagonalBlocksIndices[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives a partitioned list {{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]},\[Ellipsis]} such that the reordering {\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis],\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(k + 1\)]\),\[Ellipsis]} of columns and rows of \!\(\*
StyleBox[\"m\", \"TI\"]\) transforms it to block-diagonal form. The partition indicates separate diagonal blocks.";


DiagonalBlocksIndices[m_]:=GatherBy[MapIndexed[{#2,Position[#,1,{1}]}&,tclosure[m,0]],Last][[All,All,1,1]]


DependentRowIndices::usage="DependentRowIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent rows";


DependentRowIndices[m_?SquareMatrixQ,rows_,tc:(True|False):False]:=Union@Flatten[Position[#,1,{1}]&/@If[tc,m,TClosure[m]][[Flatten[{rows}]]]]


DependentRowIndices[ds_?DSystemQ,rows_,tc:(False):False]:=DependentRowIndices[TClosure[ds],rows,True]


DependentColumnIndices::usage="DependentColumnIndices[\!\(\*
StyleBox[\"matrix\", \"TI\"]\),\!\(\*
StyleBox[\"index\", \"TI\"]\)] gives a list of indices of all dependent columns";


DependentColumnIndices[m_?SquareMatrixQ,args__]:=DependentRowIndices[Transpose[m],args]


DependentColumnIndices[ds_?DSystemQ,rows_,tc:(False):False]:=DependentColumnIndices[TClosure[ds],rows,True]


$LibraUseFermat::error="$LibraUseFermat can be set either to False or to True. The latter case requires Fermatica\` to be in the $ContextPath.";
$LibraUseFermat/:Set[$LibraUseFermat,val_]:=If[(val===False)||(val===True&&MemberQ[$ContextPath,"Fermatica`"]),OwnValues[$LibraUseFermat]={HoldPattern[$LibraUseFermat]:>val};val,Message[$LibraUseFermat::error];$LibraUseFermat];


OQuolyMod::usage="OQuolyMod[quoly,poly,x] gives the \"remainder\" of the rational function quoly when divided by poly. First capital 'O' stands for 'optimized'.";


Options[OQuolyMod]={UseFermat->False};


done["Remove obsolete definitionfor OQuolyMod[quoly_,rule:_Rule|_RuleDelayed]"];


OQuolyMod[quoly_,poly_,x_Symbol,OptionsPattern[]]:=If[$LibraUseFermat&&OptionValue[UseFermat],
Replace[CheckAbort[FQuolyMod[quoly,poly,x],$Failed],$Failed:>(Print["OQuolyMod: resorting to Mathematica\[Ellipsis]"];QuolyMod[quoly,poly,x])],
QuolyMod[quoly,poly,x]]


FQuolyMod[exs__]:=FCStaticMonitor[Fermatica`FQuolyMod[exs],Style["Executing Fermatica`FQuolyMod...",Tiny],1]


todo["Make better version of QuolyMod and especially FQuolyMod to deal with several successive moddings wrt to different polynomials and variables."];


ODot::usage="ODot[m1,m2,...] is an optimized dot product."


Options[ODot]={UseFermat->False};


ODot[exs__,OptionsPattern[]]:=If[$LibraUseFermat&&OptionValue[UseFermat],
Replace[CheckAbort[FDot[exs],$Failed],$Failed:>(Print["ODot: resorting to Mathematica\[Ellipsis]"];Together@Dot[exs])],
Together@Dot[exs]];


FDot[exs__]:=FCStaticMonitor[Fermatica`FDot[exs],Style["Executing Fermatica`FDot...",Tiny],1]


OInverse::usage="OInverse[m] is an optimized version of Inverse[m] for block-triangular matrices.";


Options[OInverse]={Print->False,UseFermat->False};


OInverse[m_,OptionsPattern[]]:=Module[{s=TClosure[m],print=TrueQ@OptionValue[Print],diag,dep,mi=IdentityMatrix[Length@m],stat=""},
(*invert diagonal*)
If[print,FCMonitor,#&][
stat="Finding diagonal blocks\[Ellipsis]";
If[print,CWrite["\n"];CWrite[stat]];
diag=EntangledBlocksIndices[s,True];
(stat="Inverting diagonal elements with indices "<>ToString[#];
If[print,CWrite["\n"];CWrite[stat]];
mi[[#,#]]=If[$LibraUseFermat&&OptionValue[UseFermat],
Replace[CheckAbort[FInverse[#],$Failed],$Failed:>(Print["Inverse: resorting to Mathematica\[Ellipsis]"];Together[Inverse[#]])],
Together[Inverse[#]]]&@m[[#,#]])&/@diag;
(dep=Complement[DependentRowIndices[s,#,True],#];stat="Inverting off-diagonal elements "<>ToString[dep]<>" on rows "<>ToString[#];
If[print,CWrite["\n"];CWrite[stat]];
mi[[#,dep]]=-ODot[mi[[#,#]],ODot[m[[#,dep]],mi[[dep,dep]]]])&/@diag;
,
stat];
Return[mi]
]


FInverse[ex_]:=FCStaticMonitor[Fermatica`FInverse[ex],Style["Executing Fermatica`FInverse...",Tiny],1]


Unprotect[Series];
Series[expr_,{x_,x0_,n_Integer}]/;FreeQ[expr,x]:=expr+SeriesData[x,x0,{},n+1,n+1,1]
Series[expr_List,{x_,x0_,n_Integer}]:=Map[Series[#,{x,x0,n}]&,expr]
Protect[Series];
todo["NB: Series redefined!"]


SeriesCoefficients::usage="SeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 up to  (x-x0)^n return the list of these terms";


SeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,series,n},
series=Series[A,{x,x0,k}];
n=LeadingOrder[series,{x,x0}];
SeriesCoefficient[series,{x,x0,#}]&/@Range[n,k]
]


LeadingSeries::usage="LeadingSeries[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeries[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[A+SeriesData[x,x0,{},\[Infinity],\[Infinity],1]]];
Series[A,{x,x0,n+k}]
]
LeadingSeries[A_,{x_Symbol,\[Infinity],k_}]:=Module[
{i,n=LeadingOrder[A,{x,\[Infinity]}]},
If[n==\[Infinity],Return[A+SeriesData[x,\[Infinity],{},\[Infinity],\[Infinity],1]]];
Series[A,{x,\[Infinity],n+k}]
]


LeadingSeriesCoefficient::usage="LeadingSeriesCoefficient[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion";


LeadingSeriesCoefficient[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}]},
If[n==\[Infinity],Return[0]];
SeriesCoefficient[A,{x,x0,n+k}]
]


LeadingSeriesCoefficients::usage="LeadingSeriesCoefficients[f,{x,x0,n}] generate a power series expansion for f about the point x=x0 with n first nonzero terms of expansion and return the list of these terms";


LeadingSeriesCoefficients[A_,{x_Symbol,x0_,k_}]:=Module[
{i,n=LeadingOrder[A,{x,x0}],series},
If[n==\[Infinity],Return[0]];
series=Series[A,{x,x0,n+k}];
SeriesCoefficient[series,{x,x0,#}]&/@Range[n,n+k]
]


LeadingOrder::usage="LeadingOrder[expr,{x,x0}] gives the leading order of expansion in x.\nLeadingOrder[expr,poly,x] returns the leading order of the polynomial poly whic can be factorised for expr.";


(*Modified 18.05.2019*)(*Added 18.05.2019*)LeadingOrder[expr_List,a__]:=Min[LeadingOrder[#,a]&/@expr](*/Added 18.05.2019*)
LeadingOrder[expr_,x_Symbol(*Added 18.05.2019*),opts:OptionsPattern[](*/Added 18.05.2019*)]:=(*Added 18.05.2019*)lorder[expr,{x,0}](*/Added 18.05.2019*)(*(*Deleted 18.05.2019*)Min[lorder[expr,{x,0}]](*/Deleted 18.05.2019*)*)
LeadingOrder[expr_,{x_Symbol,x0_},opts:OptionsPattern[]]:=(*Added 18.05.2019*)lorder[expr,{x,x0}](*/Added 18.05.2019*)(*(*Deleted 18.05.2019*)Min[lorder[expr,{x,x0}]](*/Deleted 18.05.2019*)*)(*/Modified 18.05.2019*)


(*SetAttributes[lorder,Listable]*)
(*lorder[0,x_Symbol]=\[Infinity];
lorder[expr_,x_Symbol]:=Plus@@Cases[Factors[expr],{x^a_.,n_}\[RuleDelayed]a n]*)
(*(*Deleted 18.05.2019*)lorder[expr_List,x_]:=lorder[#,x]&/@expr;(*/Deleted 18.05.2019*)*)
lorder[0,{x_Symbol,x0_}]=\[Infinity];
lorder[expr_,{x_Symbol,x0_}]:=Plus@@Cases[FactorList[expr/.x->x+x0],{x^a_.,n_}:>a n];
lorder[expr_,{x_Symbol,\[Infinity]}]:=Plus@@Cases[FactorList[expr/.x->1/x],{x^a_.,n_}:>a n];
(*lorder[expr_,{x_Symbol,x0_}]:=Series[expr,{x,x0,-20}][[4]];*)
lorder[expr_SeriesData,{x_Symbol,x0_}]/;MatchQ[Take[List@@expr,2],{x,x0}]:=expr[[4]];


PolySeriesRules::usage="PolySeriesRules[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)}] gives a list of the form {{\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"k\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\"1\", \"TI\"]\)}\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[
RowBox[{\"k\", \"+\", \"1\"}], \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\[Ellipsis],{\!\(\*
StyleBox[\"n\", \"TI\"]\)}\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)}, such that each \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a polynomial with deg(\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\))<deg(\!\(\*
StyleBox[\"p\", \"TI\"]\)) and PolyLeadingOrder[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*SubsuperscriptBox[\(\[Sum]\), 
StyleBox[
RowBox[{\"i\", \"=\", \"k\"}], \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[
StyleBox[\"p\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]>\!\(\*
StyleBox[\"n\", \"TI\"]\)."


PolySeriesRules[ex_,{x_,den_,o_}]:=Module[{lo,tmp,rem,res={}},
If[!(RatFuncQ[ex,x]||PolyQ[den,x]),Return[$Failed]];
lo=PolyLeadingOrder[ex,den,x];
If[o<lo,Return[{{o}->0*ex}]];
tmp=Together[ex/den^lo];
Do[
rem=QuolyMod[tmp,den,x];
AppendTo[res,rem];
tmp=Together[(tmp-rem)/den];
If[tmp===0,res=PadRight[res,o-lo+1];Break[]]
,{i,lo,o}];
Thread[List/@(lo-1+Range[Length@res])->(res)]
]


PolySeriesCoefficient::usage="PolySeriesCoefficient[\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"n\", \"TI\"]\)}] gives the coefficient \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"n\", \"TI\"]]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) in the expansion \!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\[Sum]\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)\!\(\*SuperscriptBox[
StyleBox[\"p\", \"TI\"], 
StyleBox[\"i\", \"TI\"]]\)."


PolySeriesCoefficient[ex_,{x_,den_,o_}]:=Replace[Cases[PolySeriesRules[ex,{x,den,o}],({o}->c_):>c,1,1],{{c_}:>c,{}->Indeterminate}]


SeriesSolutionData::usage="SeriesSolutionData[M,{x,x0,n}] constructs data for generalized power series solution of the system \[PartialD]U=M\[InvisibleComma]U.\nGeneralized form: SeriesSolutionData[M,{x,y(x),n}].\n    \[FilledSmallCircle] M should be rational.\n    \[FilledSmallCircle] M should be Fuchsian at x=x0.\n    \[FilledSmallCircle] Residue A at x=x0 should be free of resonances.\n    \[FilledSmallCircle] SeriesSolutionData returns data U with the asymptotics (x-x0)^A.\nReturned data has the form of a list with each element having the form {\[Lambda],\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\),s,{\!\(\*SubscriptBox[\(T\), \(1\)]\),\!\(\*SubscriptBox[\(\[Ellipsis]T\), \(s\)]\)}&,C[\[Lambda],0..\!\(\*SubscriptBox[\(K\), \(\[Lambda]\)]\)]}.";
SeriesSolutionData::notrat="Matrix received is not rational in `1`.";
SeriesSolutionData::ppr="Positive Poincare rank at `1`=`2`.";
SeriesSolutionData::res="Resonant eigenvalues at `1`=`2`.";


ssd[M_?SquareMatrixQ,y_,yv_]:=Module[
{pr,A,T,JF,x2A,p,fp,Q,poles,dens,qs,Bs,\[Lambda],tmp,
Rcoefs,rcoefs,n,Rdata,
statusline=""},
FCMonitor[
If[!RatFuncQ[M,y],Message[SeriesSolutionData::notrat,yv];Return[$Failed]];
If[(pr=PoincareRank[M,{y,0}])>0,Message[SeriesSolutionData::ppr,yv,0];Return[$Failed]];
A=SeriesCoefficient[M,{y,0,-1}];
CWrite["\n"];CWrite[statusline="Reducing to Jordan form..."];
{T,JF}=JDecomposition[A];
fp=p[#[[1,1]],Max[Length/@#]-1]&/@GatherBy[DeleteDuplicates[Map[First,Split[Transpose[{Diagonal[JF],Append[Diagonal[JF,1],0]}],#1[[2]]=!=0&],{2}]],First];
PrintTemporary["Leading expansion terms:\n",Sequence@@(Riffle[TraditionalForm[yv^#1 Log[yv]^#2]&@@@fp,","])];
If[MemberQ[Factor[Subtract@@@Subsets[First/@fp,{2}]],_Integer],Message[SeriesSolutionData::res,yv,0];Return[$Failed]];
(*Now we find common denominator Q, Eq(6) of DESS paper*)
CWrite["\n"];CWrite[statusline="Getting rid  of denominators..."];
(*poles=DeleteCases[PolesPosition[M,y],\[Infinity]|0];
Q=Times@@((y-#)^(1+PoincareRank[M,{y,#}])&/@poles);*)
Q=1;
While[{}=!=(dens=Denominators[Together[M Q],y]),
Q*=PolynomialLCM[Sequence@@dens,y];
];
Q=Numerator@Together[Q/y];
qs=CoefficientList[Q,y];
Bs=Coefficient[Factor[Q(y M-\[Lambda] IdentityMatrix[Length@M])],y,#]&/@Range[0,Length[qs]-1];
CWrite["\n"];CWrite[statusline="Evaluating matrix exponent..."];
x2A=ODot[ODot[T,(Expand[Expand[Simplify[MatrixExp[JF*Log[y]]]p[0,0]]/.{Log[y]->p[0,1],y->p[1,0]}]//.{p[a_,b_]^c_:>p[a*c,b*c],p[a_,b_]*p[c_,d_]:>p[a+c,b+d]})],OInverse[T]];
CWrite["\n"];CWrite[statusline="Evaluating recurrence coefficients..."];
Rcoefs=Function[{\[Alpha],k},Evaluate@MapThread[bjf[#1,#2*IdentityMatrix[Length@M],k+1]&,{MapIndexed[(#/.{\[Lambda]->\[Alpha]+n-First[#2]+1})&,Bs],-qs},1](*Function[n,]*)];
Rdata=Function[{\[Alpha],k},
CWrite["\n"];CWrite[statusline="Evaluating recurrence coefficients for power "<>ToString[\[Alpha]]<>"..."];
rcoefs=Rcoefs[\[Alpha],k](*[n]*);
tmp=OInverse[-rcoefs[[1]]];(*may be improved by dedicated calculation of inverse of bjf with 
off-diagonal terms calculated by iterative multiplication by -A^(-1)B*)
{\[Alpha],k,Length@rcoefs-1(*=s from the paper*),Function@@({ODot[tmp,#]&/@Rest[rcoefs]/.n:>Slot[1]}),Flatten[#!*Coefficient[x2A,p[\[Alpha],#]]&/@Range[0,k],1]}
]@@@fp;
Rdata
,statusline]]


(*Shortcuts*)
SeriesSolutionData[M_?SquareMatrixQ,{x_,\[Infinity]}]:=
Module[{z},ssd[-x^2M/.{x->1/z},z,1/x]];
SeriesSolutionData[M_?SquareMatrixQ,{x_,x0_}]/;FreeQ[x0,x]:=
Module[{z},ssd[M/.{x->z+x0},z,x-x0]]; 
SeriesSolutionData[M_?SquareMatrixQ,{x_,y_}]:=
Module[{z,xvar},xvar=x/.First[Solve[z==y,x]];ssd[M D[xvar,z]/.{x->xvar},z,y]];


ConstructSeriesSolution::usage="ConstructSeriesSolution[rdata_,{x_,o_}] makes a series solution out of rdata (see ?SeriesSolutionData for how to get rdata).\n    o \[LongDash] order in x.\nIf f=ConstructSeriesSolution[SeriesSolutionData[M,{x,0}],{x,o}], then one may check the equation by Factor[D[y,x]-M.y].\nOptions:\n    O\[Rule]True|False:False \[LongDash] whether to add O[x]^o\n    Split\[Rule]True|False:False determines whether to split contribution of different fractional powers.\n    Hold->f|False:False -- whether to wrap the leading powers. If f\[NotEqual]False is given, f[lp] is used instead of \!\(\*SuperscriptBox[\(x\), \(lp\)]\).\nSince Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended. If option Split\[Rule]True is used,  ConstructSeriesSolution returns the result as a rectangular matrix n\[Times](n*|S|), with each square n\[Times]n block corresponding to a specific fractional power.";
ConstructSeriesSolution::mixed="Since Mathematica treats generalized power series poorly, using options O\[Rule]True and Split\[Rule]False simultaneously is not recommended.";


Options[ConstructSeriesSolution]={O->False,Split->False,Simplify->Factor};


ConstructSeriesSolution[rdata_,{x_,o_}, OptionsPattern[]]:=Module[{c,n,sdata,sf=OptionValue[Simplify],Oo=TrueQ@OptionValue[O],So=TrueQ@OptionValue[Split](*,Ho=If[TrueQ@!OptionValue[Hold],x^#&,OptionValue[Hold]]*)},
If[Oo&&!So,Message[ConstructSeriesSolution::mixed]];
Oo=If[Oo,x^o O[x],0];
sdata=(Function[{lp,llp,M,coefs,init},
c[lp,0]=init;c[lp,n_Integer?Positive]:=(Quiet[Unset[c[n-M-1]]];(*clean up*)
c[lp,n]=sf@Sum[Dot[coefs[n][[m]],c[lp,n-m]],{m,Min[M,n]}]);
x^lp*(Dot[((Log[x]^#/#!)&/@Range[0,llp]),(Partition[#,Length@#/(llp+1)]&[Sum[c[lp,n]*x^n,{n,0,o}]])]+Oo)
]@@@rdata);
If[So,ArrayFlatten[{sdata}],Plus@@sdata]
]


PexpExpansion::usage="PexpExpansion[{M,n},x] gives the perturbative expansion of the \!\(\*FormBox[\(Pexp[\[Integral]dx\\\ M]\),
TraditionalForm]\) in \!\(\*FormBox[\(M\),
TraditionalForm]\) up to the term \!\(\*FormBox[\(\(\[Proportional]\)\*SuperscriptBox[\(M\), \(n\)]\),
TraditionalForm]\) via the iterated integrals \!\(\*FormBox[\(II[{\*SubscriptBox[\(a\), \(n\)], \*SubscriptBox[\(a\), \(n - 1\)], \*SubscriptBox[\(\[Ellipsis]a\), \(1\)]}, x] = \(\*UnderscriptBox[\(\[Integral]\[Ellipsis] \[Integral]\), \(\*SubscriptBox[\(x\), \(0\)] < \*SubscriptBox[\(x\), \(1\)] < \*SubscriptBox[\(\[Ellipsis]x\), \(n\)] < x\)] \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(n\)]\), \(\*SubscriptBox[\(x\), \(n\)] - \*SubscriptBox[\(a\), \(n\)]\)] \(\[Ellipsis]\) \*FractionBox[\(\[DifferentialD]\*SubscriptBox[\(x\), \(1\)]\), \(\*SubscriptBox[\(x\), \(1\)] - \*SubscriptBox[\(a\), \(1\)]\)]\(\\\ \)\)\),
TraditionalForm]\), where \!\(\*FormBox[SubscriptBox[\(x\), \(0\)],
TraditionalForm]\) is arbitrary. The result is the list of successive terms."


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
FCMonitor[
res=NestList[Function[pr,i++;CWrite["."];t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x]:>II[{#,a},x]})&/@p)],IdentityMatrix[Length@M]*II[{},x],n],
i,"\n"]
]


PexpExpansion[{M_?MatrixQ,n_Integer},x_Symbol,x0_]:=Module[{p=PolesInfo[M,x],op,res,w,i=0,t},
If[Not[MatchQ[p,{{_,0}...}]],Abort[]];
p=DeleteCases[First/@p,\[Infinity]];
op=Plus@@(SeriesCoefficient[M,{x,#,-1}]w[#]&/@p); (*operator*)
FCMonitor[
res=NestList[Function[pr,i++;
CWrite["."];t=Expand[Dot[op,pr]];Plus@@((Coefficient[t,w[#]]/.{II[{a___},x,x0]:>II[{#,a},x,x0]})&/@p)],IdentityMatrix[Length@M]*II[{},x,x0],n],
i]
]


InsertionPositions[m_Integer,n_Integer]:=Module[{ss,range},
range=Range[n]-1;
#-range&/@Subsets[Range[m+n],{n}]
]
ShuffleProductNestList[l_,list_List,n_Integer]:=Module[{len=Length@list,k},
Table[Insert[list,l,List/@#]&/@InsertionPositions[len,k],{k,0,n}]
]


todo["InsertionPositions can probably be written in C"];


FactorLeadingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{ls:(l)..,b1:Except[l],bs___},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Prepend[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{(l)..,Except[l],___},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


FactorTrailingLetter[expr_,l_,h_:II]:=Module[{IIs,IIrules={},shuffleRule,ex=expr,k,il,i},
shuffleRule=h[{bs___,b1:Except[l],ls:(l)..},x_]:>Plus@@MapIndexed[Function[{shs,il},i=First[il]-1;((-1)^i)*h[Drop[{ls},-i],x]*Plus@@(h[Append[#,b1],x]&/@shs)],ShuffleProductNestList[l,{bs},Length@{ls}]];
IIs=DeleteDuplicates[Cases[ex,h[{___,Except[l],(l)..},x_],All]];
IIrules=Thread[IIs->Replace[IIs,shuffleRule,{1}]];
ex=ex/.Dispatch[IIrules]/.h[ls:{(l)..},x_]:>h[{l},x]^Length[ls]/Length[ls]!;
Return[ex]
]


SpotCoefficients::usage="SpotCoefficients[Mf,T,\[Epsilon],{x,y(x),o}] tries to find the coefficients in the asymptotic expansion of the initial integrals which are sufficient for fixing boundary conditions. The output is a list with each element being of the form {y(x),i,\[Alpha],k}. It stands for the coefficient \!\(\*SuperscriptBox[\(y\), \(\[Alpha]\)]\)\!\(\*SuperscriptBox[\(ln\), \(k\)]\)y in i-th integral.";
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]/;FreeQ[y,x]:=SpotCoefficients[Mf,T,\[Epsilon],{x,y,o}]
SpotCoefficients[Mf_,T_,\[Epsilon]_,{x_,y_,o_}]:=Module[{rdata,TUr,z,zrule,ii,p,powers,tmp,cs=ConstantArray[0,Length@Mf]},
zrule=First[Solve[z==y,x]];
FCMonitor[
MapIndexed[(ii=#;CWrite[ToString[ii]];
rdata=SeriesSolutionData[Factor[Mf[[ii,ii]]],{x,y}];TUr=(Plus@@Partition[#1,Length[ii]]&)/@Map[Collect[Expand[#1 p[0,0]]/. {Log[z]->p[0,1],z->p[1,0]}//. {p[a_,b_]^c_:>p[a c,b c],p[a_,b_] p[c_,d_]:>p[a+c,b+d]},_p,Factor]&,Normal[(T[[ii,ii]]/. zrule).ConstructSeriesSolution[rdata,{z,o},Split->True,O->True]],{2}];powers={};tmp={};MapIndexed[Function[{row,i},Module[{ps=SortBy[Union[Cases[row,_p,All]],First[#/.\[Epsilon]->0]&]},Catch[((tmp=Append[tmp,Factor[Coefficient[row,#1]]];If[MatrixRank[tmp]>=First[i],AppendTo[powers,#1];Throw[0]];tmp=Most[tmp])&)/@ps;
Print["Could not find suitable coefficients for block ",ii," Aborting..."];
Abort[]]]],TUr];cs[[ii]]=MapIndexed[{y,ii[[First[#2]]],Sequence@@#1}&,powers];
)&,EntangledBlocksIndices[TClosure[Mf]+TClosure[T]]],
ii];
cs
]


ToOneDE::usage="ToOneDE[M,x,i] constructs one higher-order differential equation for the i-th master.\nIt returns the list of the coefficients {Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]} in front of the consecutive orders of derivatives, so that the equation has the form Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0.";


ToOneDE[M_,x_,i_:1]:=Module[
{ders,Mk=IdentityMatrix[Length@M]},
ders={Mk[[i]]};
While[MatrixRank[ders]==Length@ders,
PrintTemporary[Length@ders];
(*Add one more row*)
Mk=Factor[D[Mk,x]+Mk.M];
AppendTo[ders,Mk[[i]]];
];
First[NullSpace[Transpose[ders]]]
]


ToCompanionDS::usage="ToCompanionDS[{Subscript[c, 0],Subscript[c, 1],\[Ellipsis],Subscript[c, n]}] constructs the companion matrix Subscript[M, c] out of the coefficients of differential equation Subscript[c, 0]f(x)+Subscript[c, 1]f'(x)+\[Ellipsis]+Subscript[c, n]f^(n)(x)=0. This matrix enters the right-hand side of the differential system \!\(
\*SubscriptBox[\(\[PartialD]\), \(x\)]F\)=Subscript[M, c]F, where F=(f,f',\[Ellipsis],f^(n))^T.";


ToCompanionDS[coefs_List]:=Append[Rest@IdentityMatrix[Length@coefs-1],Factor[Most[coefs]/-Last[coefs]]]


done["Transform: add support for notations."]


Transform::usage="Transform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\).\nTransform[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the matrix Inverse[\!\(\*
StyleBox[\"t\", \"TI\"]\)].(\!\(\*
StyleBox[\"m\", \"TI\"]\).\!\(\*
StyleBox[\"t\", \"TI\"]\)-D[\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)]).\nTransform[\!\(\*
StyleBox[\"ds\", \"TI\"]\),\!\(\*
StyleBox[\"t\", \"TI\",\nFontSize->12]\)] transforms the differential system.";


Options[Transform]={Simplify->Factor,Print->True,UseFermat->False};


Transform::notinv="The two matrices are not reciprocal to each other. Aborting...";
Transform::range="Something wrong with application range `1`. Aborting...";


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,opts:OptionsPattern[]]:=Module[{ti=OInverse@t},
transform[m,t,ti,OptionValue[UseFermat]] 
];
Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False}]:=If[checked||Factor[ti.t]===IdentityMatrix[Length@t],
transform[m,t,ti,OptionValue[UseFermat]],
Message[Transform::notinv];Abort[]]; 



transform[m_,t_,ti_,fermat:True|False]:=ODot[ti,ODot[m,t,UseFermat->fermat],UseFermat->fermat];
transform[m_,t_,ti_,x_,fermat:True|False]:=ODot[ti,ODot[m,t,UseFermat->fermat]-D[t,x],UseFermat->fermat];
transform[m_,t_,ti_,x_,{},fermat:True|False]:=ODot[ti,ODot[m,t,UseFermat->fermat]-D[t,x],UseFermat->fermat];


transform[m_,t_,ti_,x_,notas:{__Rule},fermat:True|False]:=Internal`InheritedBlock[{D},
SetOptions[D,NonConstants->First/@notas];
(*Modified 18.05.2019*)Fold[ModNotation[#1,#2,UseFermat->fermat]&,ODot[ti,ODot[m,t,UseFermat->fermat]-(D[t,x]/.First[Solve[0==D[Last/@notas,x],D[First/@notas,x]]]),UseFermat->fermat],notas](*/Modified 18.05.2019*)
]


Transform[m_?SquareMatrixQ,t_?SquareMatrixQ,{x_Symbol,notas:_Association|{___Rule}:{}}|x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],opts:OptionsPattern[]]:=Transform[m,{t,OInverse@t,True},{x,notas},i,opts];
Transform[m_?SquareMatrixQ,{t_?SquareMatrixQ,ti_?SquareMatrixQ,checked:True|False:False},{x_Symbol,notas:_Association|{___Rule}:{}}|x_Symbol,i:{__Integer}|Span[_,_]:Span[1,All],OptionsPattern[]]:=Module[{mt},If[checked||ODot[ti,t]===IdentityMatrix[Length@t],
mt=transformrange[m,t,ti,x,i,notas/.Association->List,OptionValue[UseFermat]];
mt,
Message[Transform::notinv];Abort[]]
];


transformrange[m_,t_,ti_,x_,Span[1,All],notas:{___Rule}:{},fermat:True|False]:=transform[m,t,ti,x,notas,fermat];
transformrange[m_,t_,ti_,x_,i_,notas:{___Rule}:{},fermat:True|False]:=Module[{mt=m,jj,ii,l=Length@m},
ii=Replace[i,{Span[a_Integer,b_Integer]:>Range[Mod[a+l+1,l+1],Mod[b+l+1,l+1]],Span[a_Integer,All]:>Range[Mod[a+l+1,l+1],Length@m]}];
If[Not[MatchQ[ii,{(_Integer?(1<=#<= l&))..}]],Message[Transform::range,i];Abort[]];
mt[[ii,ii]]=transform[m[[ii,ii]],t,ti,x,notas,fermat];
jj=Complement[DependentColumnIndices[m,ii],ii];
If[jj=!={},mt[[jj,ii]]=(*Modified 18.05.2019*)Fold[ModNotation[#,#2,UseFermat->fermat]&,ODot[mt[[jj,ii]],t,UseFermat->fermat],notas/.Association->List](*/Modified 18.05.2019*)];
jj=Complement[DependentRowIndices[m,ii],ii];
If[jj=!={},mt[[ii,jj]]=(*Modified 18.05.2019*)Fold[ModNotation[#,#2,UseFermat->fermat]&,ODot[ti,mt[[ii,jj]],UseFermat->fermat],notas/.Association->List](*/Modified 18.05.2019*)];
mt
];


Transform[ds_?DSystemQ,t_,i:{__Integer}|Span[_,_]:Span[1,All],opts:OptionsPattern[]]:=Module[{m=ds[[]]},
(m[#]=Transform[m[#],t,{#,Notations[ds]},i,opts])&/@Keys[m];
HistoryAppend[ds,{m,{Transform,ds,t,i}},Sequence@@FilterRules[{opts},Options[HistoryAppend]]];
m
]


ChangeVar::usage="ChangeVar[ds,{rules},{vars}] changes variable in the matrix.";


ChangeVar[m_?SquareMatrixQ,x_->xviay_,y_Symbol]:=Factor[m D[xviay,y]/.x->xviay]


ChangeVar[ds_?DSystemQ,rs1:_Rule|{__Rule},ys1:_Symbol|_List]:=Module[{keys=Keys[ds[[]]],M,rs=Flatten[{rs1}],ys=Flatten[{ys1}],nkeys=Keys[Notations[ds]]},
M=Association@@(Function[y,y->Plus@@((D[#1/.rs,y]ds[#1]/.rs)&/@keys)]/@ys);
Unprotect[ds];
Notations[ds]^=Numerator@Together[Notations[ds]/.rs];
Protect[ds];
HistoryAppend[ds,{M,{ChangeVar,ds,rs,ys}}];
Protect/@ys;
ds[[]]
]


AddNotation::usage="AddNotation[ds,y\[Rule]p(x,y)] adds notation y connected with x via p(x,y)=0.";


AddNotation[ds_?DSystemQ,y_Symbol->p_]:=Module[{keys=Keys[ds[]],M,nots=Notations[ds]},
If[FreeQ[p,y],Message[AddNotation::wrng];Return[$Failed]];
nots[y]=p;
Unprotect[ds];
Notations[ds]^=nots;
Protect[ds];
HistoryAppend[ds,{ds[],{AddNotation,ds,y->p}}];
Protect[y];
ds[[]]
]


ModNotation::usage="ModNotation[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)] is a shortcut for OQuolyMod[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)]. Should be good for reducing dependence on notations.";


Options[ModNotation]={UseFermat->False}


ModNotation[quoly_,rule:_Rule|_RuleDelayed,OptionsPattern[]]:=OQuolyMod[quoly,rule[[2]],rule[[1]],UseFermat->OptionValue[UseFermat]]


todo["Think of removing _RuleDelayed in ModNotation[quoly_,rule:_Rule|_RuleDelayed]"]


RuleToNotation::usage="RuleToNotation[\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)] gives a rule \!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the numerator of \!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


RuleToNotation::error="The function `1` is not rational.";


RuleToNotation[x_->q_,y_]:=Module[{p},
If[RatFuncQ[q,y],
p=Numerator@Together[q-x];Return[y->p],
Message[RuleToNotation::error,q];
Return[$Failed]
]
]


NotationToRule::usage="NotationToRule[\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\)] gives a rule \!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"\[Rule]\", \"TI\"]\)\!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the solution of \!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"y\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"0\", \"TI\"]\) wrt \!\(\*
StyleBox[\"x\", \"TI\"]\).";


NotationToRule::error="The equation `1`=0 is not sutable for introducing notation.";


NotationToRule[y_->p_,x_]:=Module[{rule},
If[PolyQ[p,x|y]&&Exponent[p,x]==1,
{{rule}}=Solve[p==0,x];Return[rule],
Message[NotationToRule::error,p];
Return[$Failed]
]
]


A0ToSubspaces::usage="A0ToSubspaces[A0,\[Epsilon]\[Rule]0,Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances with positive gains.\nWhen called with option All\[Rule]True, it returns all subspaces.";


Options[A0ToSubspaces]={All->False};


A0ToSubspaces[A0_?SquareMatrixQ,rules_,side:(Left|Right):Left,OptionsPattern[]]:=Module[{l=Length@A0,jdata,sel=Select},
jdata={Factor[#1]/.rules,##2}&@@@JDData@A0;
(*Pick suitable evs*)
If[TrueQ[OptionValue[All]],sel=#&];
If[side===Right,
SortBy[sel[jdata,TrueQ[Positive[First@#]]&],-First[#]&][[All,3]],
SortBy[sel[jdata,TrueQ[Negative[First@#]]&],First][[All,2]]
]
]


todo["Eliminate JDData from A0ToSubspaces."];


todo["Write PolyA0ToSubspaces."]


A0A1ToSubspaces::usage="A0A1ToSubspaces[{A0,A1},Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances.";


A0A1ToSubspaces[{A0_?SquareMatrixQ,A1_?SquareMatrixQ},side:(Left|Right):Left]/;Length@A0==Length@A1:=Module[{l=Length[A1],\[Lambda],ns,A}, 
A=ArrayFlatten[{{A0,A1-\[Lambda]*IdentityMatrix[l]},{0,A0}}];
If[side===Left,A=Take[#,-l]&/@ker[A],A=Take[#,l]&/@ker[Transpose@A]];
(*Get rid of denominators*)
ns=Collect[Cancel[PolynomialLCM@@Denominator[#]*#],\[Lambda],Factor]&/@Factor@DeleteCases[A,{0..}];
ns=SortBy[DeleteDuplicates[DeleteCases[RowReduce[FixedPointList[D[#,\[Lambda]]&,#]/.\[Lambda]->0],{0..}]&/@ns],Length];
(*If[side===Left,Transpose/@ns,ns]*)ns
]


todo["improve A0A1ToSubspaces \[LongDash] calculate Groebner basis of \!\(\*SubscriptBox[\(u\), \(1\)]\)(\[Lambda]),\[Ellipsis],\!\(\*SubscriptBox[\(u\), \(k\)]\)(\[Lambda])."];


GetSubspaces::usage="GetSubspaces[\!\(\*
StyleBox[\"m\", \"TI\"]\),{x,\!\(\*SubscriptBox[\(x\), \(0\)]\)},\[Epsilon],Left|Right] gives the subspaces which may be used for the construction of the projectors for the balances with positive gains.\nWhen called with option All\[Rule]True, it returns all subspaces."


Options[GetSubspaces]={All->False}


GetSubspaces[m_?DSystemQ,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]
GetSubspaces[m_Association,{x_,x0_},args___]:=GetSubspaces[m[x],{x,x0},args]


GetSubspaces[m_?SquareMatrixQ,{x_,x0_},\[Epsilon]_,side:(Left|Right):Left,OptionsPattern[]]:=Module[
{r,s,o,ser,m0,m1,status=""},
FCMonitor[
status="Evaluating Poincare rank...";
CWrite["\n"<>status];
r=PoincareRank[m,{x,x0}];
PrintTemporary["Poincare rank: "<>ToString[r]];
status="Evaluating expansion";
s=2Boole[x0===\[Infinity]]-1;
o=s-r;(*leading order of expansion*)
If[r>0,
If[TrueQ@OptionValue[All],
(*Just return all subspaces*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[A0ToSubspaces[m0,\[Epsilon]->0,side,All->True]],
(*return Barkatou subspaces*)
ser=-s*Series[m,{x,x0,o+1}];
m0=SeriesCoefficient[ser,{x,x0,o}];
m1=SeriesCoefficient[ser,{x,x0,o+1}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[A0A1ToSubspaces[{m0,m1},side]]
],
(*Fuchsian singularity*)
m0=-s*SeriesCoefficient[m,{x,x0,o}];
status="Evaluating subspaces";
CWrite["\n"<>status];
Return[A0ToSubspaces[m0,\[Epsilon]->0,side,All->OptionValue[All]]]
]
,status
]
]


Projector::usage="Projector[image,coimage] constructs projector with prescribed image and coimage.";


Projector[u_,v_]:=Module[{ut=Transpose@u},Check[ODot[ut,Inverse@Dot[v,ut],v],ConstantArray[0,{Length@First[v],Length@ut}]]]


Balance::usage="A balance transformation matrix. Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)\!\(\*FractionBox[\(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"2\"]\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(1\)]\),\[Infinity]}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)\!\(\*FractionBox[\(1\), \(\*
StyleBox[\"x\", \"TI\"] \*
StyleBox[\"-\", \"TI\"]\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \"1\"]\)]\)\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\), and Balance[\!\(\*
StyleBox[\"c\[DoubleStruckCapitalP]\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\[Infinity],\!\(\*SubscriptBox[\(x\), \(2\)]\)}]=\!\(\*
StyleBox[\"\[DoubleStruckCapitalI]\", \"TI\"]\)-\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\)+\!\(\*
StyleBox[\"c\", \"TI\"]\)(\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\"-\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(2\)]\))\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\). The constant \!\(\*
StyleBox[\"c\", \"TI\"]\) is defined from the condition \!\(\*SuperscriptBox[
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"], \(2\)]\)=\!\(\*
StyleBox[\"\[DoubleStruckCapitalP]\", \"TI\"]\).";


Balance::notprojector="Warning: `1` is not a projector. Returning identity matrix";


Balance[p_,{x_,x1_,\[Infinity]}]:=Module[{c},
Check[{c}=LinearSolve[List/@Flatten[p],Flatten@ODot[p,p]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];Return[Factor[IdentityMatrix@Length@p-p/c]+p 1/(x-x1)]
]


Balance[p_,{x_,\[Infinity],x2_}]:=Module[{c},
Check[{c}=LinearSolve[List/@Flatten[p],Flatten@ODot[p,p]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];Return[Factor[IdentityMatrix@Length@p-p/c]+p (x-x2)]
]


Balance[p_,{x_,x1_,x2_}]:=Module[{c},
Check[{c}=LinearSolve[List/@Flatten[p],Flatten@ODot[p,p]],Message[Balance::notprojector,p];Return[IdentityMatrix@Length@p]];Return[Factor[IdentityMatrix@Length@p-p/c]+p (x-x2)/(x-x1)]
]


done["Balance as it was before seems to be neither necessary nor effective. Redone."];


VisBalancing::usage="VisBalancing[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is a visual tool for the balancing. Soon to be obsolete and replaced by VisTransformation.";


VisBalancing[ds_,{x_Symbol,poles_},\[Epsilon]_Symbol:Indeterminate]:=VisBalancing[ds[x],x,\[Epsilon],poles]


VisBalancing[ds_?DSystemQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[ds[x],x,\[Epsilon],poles];


VisBalancing[as_Association,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[as[x],x,\[Epsilon],poles];


VisBalancing[matr_?SquareMatrixQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=Module[
(*
Basic idea: first, find JDecompositionData for all points of the matrix.
Then construct a graphics control
*)
{ttt,
n=Length@matr,
m=matr,
polesData,
indices,index,
prevu,prevv,
psetu,psetv,
clickedu,clickedv,
buttons=Grid[{{"Wait"}}],
us,vs,x1,x2,
lu,lv,
gram,goodBalance,colorMark,
statusline="Ready",balance,
transformation,
updateInteface,
apply,
validate
},
transformation=IdentityMatrix[n];
(*Calculate poles*)
updateInteface=(
(*forming polesData and indices*)
polesData=If[poles===All,PolesInfo[m,x],DeleteCases[{#,PoincareRank[m,{x,#}]}&/@poles,{_,_?Negative}]];
FCStaticMonitor[
polesData=
({#1,#2,(*Modified 07.06.2019*)JDData(*/Modified 07.06.2019*)@If[#1=!=\[Infinity],SeriesCoefficient[m,{x,#1,-1-#2}],-SeriesCoefficient[m,{x,#1,1-#2}]],If[#2>0,Prepend[#,"M"]&/@Transpose[{(*Transpose/@*)Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Left],Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Right]}],{}]}&@@@polesData);
,"Calculating JDData..."];
indices={};
Do[
Do[
AppendTo[indices,{i1,i2,{i3},i3==1||prevu(*"allowed to press?" flag*),prevu=Unique["p"](*"pressed?" flag*),i3==1||prevv,prevv=Unique["p"]}],{i2,Length@polesData[[i1,3]]},{i3,Length@polesData[[i1,3,i2,-1]]}
];
Do[
AppendTo[indices,{i1,Length@polesData[[i1,3]]+i2,All,True,Unique["p"],True,Unique["p"]}],{i2,Length@polesData[[i1,4]]}
]
,{i1,Length@polesData}];
polesData={#1,#2,Join[#3,#4]}&@@@polesData;
(*/forming polesData and indices*)
(*functions to set variables*)
psetu=Function[v,(v=#)&]/@indices[[All,5]];psetv=Function[v,(v=#)&]/@indices[[All,7]];
(*
write 
psetu[[i]][True] and psetv[[i]][True] *)(*
for the naive effect of 
indices[[i,5]]=True and indices[[i,7]]=True 
*)
(*/functions to set variables*)
(*forming interface*)
buttons=Grid[{
{
Grid[ArrayFlatten[{{
PadRight[Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedu[#1,#2,#3],Enabled->Dynamic[#4],Appearance->Dynamic[If[#5,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
],
{If[#2>0,Style,#&][Row[{"   ",x,"=",#1,", pr=",#2,"   "}],Bold]}&@@@polesData[[All,{1,2}]],
PadLeft[Reverse/@Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedv[#1,#2,#3],Enabled->Dynamic[#6],Appearance->Dynamic[If[#7,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
]
}}],Spacings->0,ItemSize->All,Alignment->Center]
},{
Button["Apply balance transformation",apply[],Enabled->Dynamic[goodBalance],Background->Dynamic[colorMark]]
},
{
Button["Paste overall transformation",DialogReturn[transformation]]
},
{
Dynamic[statusline]
}
},Alignment->Center];
(*/forming interface*)
(*unsetting buttons*)
Through[psetu[False]];
Through[psetv[False]];
(*/unsetting buttons*)
validate[];
)&;
apply=(
(*apply transformation*)
balance=Balance[Projector[(*Transpose@*)us,vs],{x,x1,x2}];
statusline="balance constructed";
PrintTemporary[statusline];
m=Transform[m,balance,x];
statusline="transformation applied";
PrintTemporary[statusline];
(**)
transformation=ODot[transformation,balance];
statusline="overall transformation calculated";
PrintTemporary[statusline];
updateInteface[];
)&;
validate=(
(*pick right and left vectors*)
us=vs={};
(
If[#5,us=Join[us,polesData[[#1,3,#2,2,#3]]];x1=polesData[[#1,1]]];If[#7,vs=Join[vs,polesData[[#1,3,#2,3,#3]]];x2=polesData[[#1,1]]])&@@@indices;
gram=Outer[ODot,us,vs,1];
lu=Length@us;lv=Length@vs;
goodBalance=(lu+lv>0&&lu==lv&&lv==MatrixRank[gram]);
colorMark=If[lu==0||lv==0||MatrixRank[gram]==lu,If[goodBalance,Green,Automatic],Red];
statusline=ToString[lu]<>"-dimensional u-space and "<>ToString[lv]<>"-dimensional v-space";
)&;

clickedu=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,5]],
psetu[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetu[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,__} ,{1}]];
psetu[[index]][True];
];
validate[];
)&;
clickedv=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,7]],
psetv[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetv[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,__},{1}]];
psetv[[index]][True];
];
validate[];
)&;
updateInteface[];
DialogInput[Dynamic[buttons(*Refresh[buttons,UpdateInterval\[Rule]1]*)]]
]


todo["VisBalancing: block simultaneus pressing buttons for nonzero Poincare rank singularities"]
todo["VisBalancing: for simple poles allow same-line pressing on left and right"]


VisTransformation::usage="VisTransformation[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] is a visual tool for finding transformation. Soon to replace VisBalancing.";


VisTransformation[ds_,{x_Symbol,poles_},\[Epsilon]_Symbol:Indeterminate]:=VisBalancing[ds[x],x,\[Epsilon],poles]


VisTransformation[ds_?DSystemQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[ds[x],x,\[Epsilon],poles];


VisTransformation[as_Association,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=VisBalancing[as[x],x,\[Epsilon],poles];


VisTransformation[matr_?SquareMatrixQ,x_Symbol,\[Epsilon]_Symbol:Indeterminate,poles:All|{__}:All]:=Module[
(*
Basic idea: first, find JDecompositionData for all points of the matrix.
Then construct a graphics control
*)
{
n=Length@matr,
m=matr,
polespos,polesData,
indices,index,
prevu,prevv,
psetu,psetv,
clickedu,clickedv,
buttons=Grid[{{"Wait"}}],
us,vs,x1,x2,
lu,lv,
gram,applyEnabled,colorMark,
statusline="Ready",balance,
transformation,
updateInteface,
apply,
validate,
continue=True
},
transformation=IdentityMatrix[n];
polespos=Replace[poles,All->PolesPosition[m,x]];
updateInteface=(
(*forming polesData and indices*)
polesData=DeleteCases[{#,PoincareRank[m,{x,#}]}&/@polespos,{_,_?Negative}];
Libra`Private`FCStaticMonitor[
polesData=
({#1,#2,(*Modified 07.06.2019*)JDData(*/Modified 07.06.2019*)@If[#1=!=\[Infinity],SeriesCoefficient[m,{x,#1,-1-#2}],-SeriesCoefficient[m,{x,#1,1-#2}]],If[#2>0,Prepend[#,"M"]&/@Transpose[{(*Transpose/@*)Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Left],Union@A0A1ToSubspaces[Factor[LeadingSeriesCoefficients[m,{x,#1,1}]],Right]}],{}]}&@@@polesData);
,"Calculating Jordan decomposition data..."];
indices={};
Do[
Do[
AppendTo[indices,{i1,i2,{i3},i3==1||prevu(*"allowed to press?" flag*),prevu=Unique["p"](*"pressed?" flag*),i3==1||prevv,prevv=Unique["p"]}],{i2,Length@polesData[[i1,3]]},{i3,Length@polesData[[i1,3,i2,-1]]}
];
Do[
AppendTo[indices,{i1,Length@polesData[[i1,3]]+i2,All,True,Unique["p"],True,Unique["p"]}],{i2,Length@polesData[[i1,4]]}
]
,{i1,Length@polesData}];
polesData={#1,#2,Join[#3,#4]}&@@@polesData;
(*/forming polesData and indices*)
(*functions to set variables*)
psetu=Function[v,(v=#)&]/@indices[[All,5]];psetv=Function[v,(v=#)&]/@indices[[All,7]];
(*
write 
psetu[[i]][True] and psetv[[i]][True] *)(*
for the naive effect of 
indices[[i,5]]=True and indices[[i,7]]=True 
*)
(*/functions to set variables*)
(*forming interface*)
buttons=Grid[{
{
Grid[ArrayFlatten[{{
PadRight[Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedu[#1,#2,#3],Enabled->Dynamic[#4],Appearance->Dynamic[If[#5,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
],
{If[#2>0,Style,#&][Row[{"   ",x,"=",#1,", pr=",#2,"   "}],Bold]}&@@@polesData[[All,{1,2}]],
PadLeft[Reverse/@Apply[Button[Switch[#/.\[Epsilon]->0,_?Positive,Style[#,Red],_?Negative,Style[#,Blue],_,#]&@polesData[[#1,3,#2,1]],clickedv[#1,#2,#3],Enabled->Dynamic[#6],Appearance->Dynamic[If[#7,{"FramedPalette","Pressed"},"FramedPalette"]]]&,SplitBy[indices,First],{2}]
]
}}],Spacings->0,ItemSize->All,Alignment->Center]
},{
Button["Apply balance transformation",DialogReturn[],Enabled->Dynamic[applyEnabled],Background->Dynamic[colorMark]]
},
{
Button["Paste overall transformation",continue=False;DialogReturn[];]
},
{
Dynamic[statusline]
}
},Alignment->Center];
(*/forming interface*)
(*unsetting buttons*)
Through[psetu[False]];
Through[psetv[False]];
(*/unsetting buttons*)
validate[];
DialogInput[buttons];
)&;
apply=(Libra`Private`FCMonitor[
applyEnabled=False;
colorMark=Magenta;
(*apply transformation*)
statusline="Constructing balance...";
balance=Balance[Projector[(*Transpose@*)us,vs],{x,x1,x2}];
statusline=statusline<>"\nCalculating overall transformation...";
transformation=ODot[transformation,balance];
statusline=statusline<>"\nApplying transformation...";
m=Transform[m,balance,x];,
statusline]
)&;
validate=(
(*pick right and left vectors*)
us=vs={};
(
If[#5,us=Join[us,polesData[[#1,3,#2,2,#3]]];x1=polesData[[#1,1]]];If[#7,vs=Join[vs,polesData[[#1,3,#2,3,#3]]];x2=polesData[[#1,1]]])&@@@indices;
gram=Outer[ODot,us,vs,1];
lu=Length@us;lv=Length@vs;
applyEnabled=(lu+lv>0&&lu==lv&&lv==MatrixRank[gram]);
colorMark=If[lu==0||lv==0||MatrixRank[gram]==lu,If[applyEnabled,Green,Automatic],Red];
statusline=ToString[lu]<>"-dimensional u-space and "<>ToString[lv]<>"-dimensional v-space";
)&;

clickedu=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,5]],
psetu[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetu[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetv[[#]][False]&/@Flatten[Position[indices,{#1,__} ,{1}]];
psetu[[index]][True];
];
validate[];
)&;
clickedv=(
{{index}}=Position[indices,{#1,#2,#3,__},{1},1];
If[indices[[index,7]],
psetv[[#]][False]&/@Flatten[Position[indices,{#1,#2,{k_}/;k>= First[#3],__},{1}]],
psetv[[#]][False]&/@Flatten[Position[indices,{k_,__}/;k!= #1,{1}]];
psetu[[#]][False]&/@Flatten[Position[indices,{#1,__},{1}]];
psetv[[index]][True];
];
validate[];
)&;
updateInteface[];
While[continue,
apply[];
updateInteface[];
];
transformation
]


FactorOut::usage="FactorOut[m,x,\[Epsilon],\[Mu]] returns a transformation which reduces m to a factorized form.";


FactorOut::notfuchsian="Not Fuchsian matrix...";
FactorOut::notnormalized="Eigenvalues of the matrix residues are not normalized...";
Options[FactorOut]={DependentRowIndices->Automatic,Solve->True};


FactorOut[ds_?DSystemQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[ds[x],x,\[Epsilon],\[Mu],opts];
FactorOut[as_Association,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=FactorOut[as[x],x,\[Epsilon],\[Mu],opts];


FactorOut[m_?SquareMatrixQ,x_,\[Epsilon]_,\[Mu]_,opts:OptionsPattern[]]:=Module[
{n=Length@m,mres,t,vars,eqs,sol,ms},
If[!FuchsianQ[m,x],Message[FactorOut::notfuchsian];Return[$Failed]];ms=Replace[OptionValue[DependentRowIndices],Automatic->TClosure[m]];
mres=LeadingSeriesCoefficient[m/\[Epsilon],{x,#1,0}]&@@@PolesInfo[m,x];
FactorDependence[mres,\[Epsilon],\[Mu],Sequence@@FilterRules[#->OptionValue[#]&@@@Options[FactorOut],Options[FactorDependence]]]
]


todo["rewrite FactorOut in the spirit of SimplifyFuchsian"];


FactorDependence::usage="FactorDependence[{m1,m2,\[Ellipsis]},\[Epsilon],\[Mu]] returns a transformation which reduces m1,m2,... to \[Epsilon]\[LongDash]independent matrices.";


Options[FactorDependence]={DependentRowIndices->Automatic,Solve->True};
FactorDependence[m:{__?SquareMatrixQ},\[Epsilon]_,\[Mu]_,OptionsPattern[]]:=Module[
{n=Length[First@m],t,vars,eqs,sol,ms},
ms=Replace[OptionValue[DependentRowIndices],Automatic->tclosure[Transpose[m,{3,1,2}],1,Except[{0..}]]];
(*insert here check for normalization*)
t=ConstantArray[0,{n,n}];
vars=(t[[##]]=Unique["t"])&@@@Flatten[Outer[List,{#},DependentRowIndices[ms,{#}]]&/@Range[n],2];
eqs=SortBy[Flatten[(Dot[#,t]-Dot[t,#/.\[Epsilon]->\[Mu]])&/@m],ByteCount];If[!OptionValue[Solve],Print["Returning a pair {eqs,t}. To find the transformation one should solve eqs\[Equal]0 with respect to Variables[t] and substitute the solution to t."];Return[{eqs,t}]];
Quiet[sol=GaussSolve[eqs,vars]];
t/.sol/.MapIndexed[#->C@@#2&,Complement[vars,First/@sol]]
]


todo[" implement FactorOut and FactorDependence using Fermat and TGaussSolve"];


BlockTriangularToFuchsian::usage="BlockTriangularToFuchsian[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gets rid of multiple poles in off-diagonal elements.\nBlockTriangularToFuchsian[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"{\", \"TI\"]\)\!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\)\!\(\*
StyleBox[\"}\", \"TI\"]\)] gets rid of multiple poles in off-diagonal elements for points \!\(\*
StyleBox[SubscriptBox[\"p\", \"1\"], \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*SubscriptBox[
StyleBox[\"p\", \"TI\"], \(2\)]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"\[Ellipsis]\", \"TI\"]\) only. Each \!\(\*
StyleBox[SubscriptBox[\"p\", \"i\"], \"TI\"]\) is either a point \!\(\*
StyleBox[\"p\", \"TI\"]\) or a pair {\!\(\*
StyleBox[\"p\", \"TI\"]\)\!\(\*
StyleBox[\",\", \"TI\"]\)\!\(\*
StyleBox[\"r\", \"TI\"]\)}, where \!\(\*
StyleBox[\"r\", \"TI\"]\) is a Poincare rank.";


Options[BlockTriangularToFuchsian]={
Simplify->False(*whether to simplify simple poles*)
(*,Check\[Rule]True(*whether to check if diagonal blocks are fuchsian*)*)
};


BlockTriangularToFuchsian[ds_?DSystemQ,x_,p:(_List|All):All,opts:OptionsPattern[]]:=
BlockTriangularToFuchsian[ds[x],x,p,opts];


BlockTriangularToFuchsian[as_Association,x_,p:(_List|All):All,opts:OptionsPattern[]]:=
BlockTriangularToFuchsian[as[x],x,p,opts];


BlockTriangularToFuchsian::blocks="Diagonal blocks are not Fuchsian...";
BlockTriangularToFuchsian[matr_,x_,p:(_List|All):All,OptionsPattern[]]:=Module[
{
n=Length@matr,order,
m=matr,mt,i1,i2,
ind1,ind2,t,o,vars,sol,
transform,c,
poles,oc=Boole[Not[TrueQ@OptionValue[Simplify]]],
blocks=EntangledBlocksIndices[matr]
},
(*Modified 18.05.2019*)poles=Reverse@DeleteCases[Replace[p,{All:>PolesInfo[matr,x],_:>Replace[p,{z_List:>z,z_:>{z,PoincareRank[matr,{x,z}]}},{1}]}],{_,_?Negative}](*/Modified 18.05.2019*);
transform=IdentityMatrix[n];
If[poles=={},Return[transform]];
(*(*Deleted 09.02.2018*)If[OptionValue[Check],If[!And@@(FuchsianQ[m[[#,#]],x]&/@blocks),Message[BlockTriangularToFuchsian::blocks]];Return[IdentityMatrix[n]]];(*/Deleted 09.02.2018*)*)
Function[{x0,order},
(*Cycle over blocks.*)
FCMonitor[
Do[
(*First, generate matrix*)
i2="?";
c=ConstantArray[0,{n,n}];
ind1=Flatten[blocks[[i1]]];ind2=Flatten[blocks[[1;;(i1-1)]]];
vars=Table[Unique["c"],{Length@ind1},{Length@ind2}];
c[[ind1,ind2]]=vars;
vars=Flatten@vars;
(*matrix generated*)
(*(*Deleted 19.05.2019*)order=PoincareRank[m[[ind1,ind2]],{x,x0}];(*/Deleted 19.05.2019*)*)
(*Now cycle over pole order*)
Unset[i2];
Do[
CWrite["\n"<>ToString[x0]<>":"<>ToString[i1]<>"\[LeftArrow]"<>"i2"];
If[x0=!=\[Infinity],
t=IdentityMatrix[n]+c/(x-x0)^i2;o=-1,
t=IdentityMatrix[n]+c*(x)^i2;o=1];
mt=Transform[m,t,x];(*TODO: here Fermat should not be used*)
Quiet[Check[sol=GaussSolve[If[i2>0,SortBy,#1&][Flatten[SeriesCoefficient[mt[[ind1,ind2]],{x,x0,o-i2}]],ByteCount],vars],If[i2>0,Print["Problem"]];Continue[],{GaussSolve::inconsistent}],{GaussSolve::inconsistent}];
m=Factor[mt/.sol/.Thread[Flatten@c->0]];
transform=ODot[transform,(t/.sol/.Thread[Flatten@c->0])];
,{i2,order,oc,-1}]
,{i1,2,Length@blocks}],
Row[{x0,":",i1,"\[LeftArrow]",i2}]]
](*Modified 19.05.2019*)@@@poles;(*/Modified 19.05.2019*)
Return[transform];
]


todo["BlockTriangularToFuchsian, option Simplify\[Rule]True seems to be broken"];


todo["BlockTriangularToFuchsian, treat Notations."];


FuchsifyBlock::usage="FuchsifyBlock[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),{{\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}}] is supposed to Fuchsify block \!\(\*
StyleBox[\"m\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\)\!\(\*
StyleBox[\"[\", \"TI\"]\){\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"i\", \"TI\"], \(2\)]\),\[Ellipsis]},{\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(1\)]\),\!\(\*SubscriptBox[
StyleBox[\"j\", \"TI\"], \(2\)]\),\[Ellipsis]}]].";


todo["FuchsifyBlock \[LongDash] one can do even faster by using BTSolve. No need to apply  transformation beforehand."];


FuchsifyBlock[ds_?DSystemQ,x_Symbol,{high_List,low_List}]:=Module[{m,all=Join[high,low],ll=Length@low,lh=Length@high,y,x2y,t,notas=Notations[ds]/.Association->List},
m=ds[x][[all,all]];
notas=Select[notas,Not[FreeQ[m,First[#]]]&];
If[Length@notas>1,Message[FuchsifyBlock::notas];Abort[]];
If[Length@notas==0,
FuchsifyBlock[m,x,{Range[lh],Range[lh+1,lh+ll]}],
PrintTemporary["Found one notation. Changing variable..."];
{y,x2y}={#,NotationToRule[#1->#2,x]}&@@(notas=First[notas]);
ModNotation[FuchsifyBlock[(m/.x2y)*D[x2y[[2]],y],y,{Range[lh],Range[lh+1,lh+ll]}],notas]
]
]


FuchsifyBlock::pr="Diagonal block `1` is not Fuchsian. Aborting...";
FuchsifyBlock[m_?MatrixQ,{x_Symbol,notas:_Association|{___Rule}:{}}|x_Symbol,{high_List,low_List}]:=
Module[
{all=Join[high,low],lhigh=Length@high,llow=Length@low,densPR,infPR,deg,vars,c,cm,t,p,b,Ah,Al,Bhl,part1,part2},
NewDSystem[b,x->m[[all,all]],Print->False];
If[Not[{notas}==={}],Abort[]];(*Can not treat notations yet*)
AddNotation[b,#]&/@Flatten[{notas}/.Association->List];
(*Check that diagonal blocks are Fuchsian*)
densPR=DenominatorsInfo[b[[(-llow);;,(-llow);;]],x];
If[MemberQ[Last/@densPR,_?Positive],Message[FuchsifyBlock::pr,low];Abort[]];
densPR=DenominatorsInfo[b[[;;lhigh,;;lhigh]],x];
If[MemberQ[Last/@densPR,_?Positive],Message[FuchsifyBlock::pr,high];Abort[]];
(*/Check that diagonal blocks are Fuchsian*)
(*Extracting Poincare ranks*)
densPR=DenominatorsInfo[b[[;;lhigh,(-llow);;]],x];(*(*1/x is special: x=\[Infinity]*)
{infPR}=Cases[densPR,{1/x,r_}\[RuleDelayed]r];Print[infPR];
densPR=DeleteCases[densPR,{1/x,_}];(*here they are only finite*)*)
Function[{den,pr},
CWrite["\n"<>ToString[den]<>": "<>ToString[pr]<>"\n"];
FCMonitor[
If[den=!=1/x,
(*finite singularities*)
deg=Exponent[den,x];
vars=Array[c,{lhigh,llow,deg},{1,1,0}];
(*Diagonal blocks*)
Ah=QuolyMod[den*b[x][[;;lhigh,;;lhigh]],den,x];
Al=QuolyMod[den*b[x][[(-llow);;,(-llow);;]],den,x];
t=IdentityMatrix[lhigh+llow];
cm=vars.x^Range[0,Exponent[den,x]-1];
part1=QuolyMod[Ah.cm-cm.Al,den,x];
part2=QuolyMod[cm*D[den,x],den,x];
Do[
CWrite["."];
Bhl=QuolyMod[Factor[b[x][[;;lhigh,(-llow);;]]den^(p+1)],den,x];
t[[;;lhigh,(-llow);;]]=cm/den^p/.GaussSolve[Flatten[CoefficientList[Bhl+part1+p*part2,x]],Flatten[vars]];
Transform[b,t,Print->False]
,
{p,pr,1,-1}],
(*infinity*)
vars=Array[c,{lhigh,llow},{1,1}];
t=IdentityMatrix[lhigh+llow];
Ah=SeriesCoefficient[b[x][[;;lhigh,;;lhigh]],{x,\[Infinity],1}];
Al=SeriesCoefficient[b[x][[(-llow);;,(-llow);;]],{x,\[Infinity],1}];
Do[
CWrite["."];
Bhl=SeriesCoefficient[b[x][[;;lhigh,(-llow);;]],{x,\[Infinity],1-p}];
t[[;;lhigh,(-llow);;]]=vars*x^p/.GaussSolve[Bhl+Ah.vars-vars.Al-p*vars,Flatten[vars]];
Transform[b,t,Print->False]
,
{p,pr,1,-1}]
],
Row[{den,":",p}]
]
]@@@densPR;
t=HistoryConsolidate[b,HistoryAppend->False,Inverse->False]
]


BTSolve::usage="BTSolve[{A,B,C}] returns matrix D which is the solution of the equation D+AD-DC+B=0.";


BTSolve[{A_?SquareMatrixQ,B_?MatrixQ,C_?SquareMatrixQ}]:=Module[{n=Length@A,m=Length@C,T},
If[Dimensions[B]=!={n,m},Abort[]];
T=IdentityMatrix[n*m]+ArrayFlatten[Outer[Times,A,IdentityMatrix[m]]-Outer[Times,IdentityMatrix[n],Transpose@C]];
(*Return[Partition[LinearSolve[T,-Flatten@B],m]]*)
Return[Check[Partition[LinearSolve[T,-Flatten@B],m],Indeterminate*B,{LinearSolve::nosol}]]
]


Denominators::usage="Denominators[\!\(\*
StyleBox[\"m\", \"TI\"]\)|\!\(\*
StyleBox[\"ds\", \"TI\"]\)] tries to define denominators in the system.\nDenominators[\!\(\*
StyleBox[\"m\", \"TI\"]\)|\!\(\*
StyleBox[\"ds\", \"TI\"]\),\!\(\*
StyleBox[\"pat\", \"TI\"]\)] gives only denominators depending on \!\(\*
StyleBox[\"pat\", \"TI\"]\).";


Denominators[ds_?DSystemQ,pat_:_,excl_:_?NumericQ]:=Module[{dens},
dens=Denominators/.Drop[History[ds][[HistoryIndex[ds]]],2];
If[dens===Denominators,
dens=Denominators[Values[ds[]],Alternatives@@Variables[ds]];
HistoryAddExtra[ds,Denominators->dens],
Print[Style["Read Denominators from extras.",Small]]
];
DeleteCases[dens,_?(FreeQ[#,pat]&)|excl]
]


Denominators[m_List,pat_:_,excl_:_?NumericQ]:=Sort@DeleteCases[DeleteDuplicates@Flatten[(First/@FactorList[#])&/@Denominator/@Flatten[m]],_?(FreeQ[#,pat]&)|excl]
Denominators[ex_,pat_:_,excl_:_?NumericQ]:=Sort@DeleteCases[First/@FactorList[Denominator@ex],_?(FreeQ[#,pat]&)|excl]


Denominators[as_Assiciation,pat_:_,excl_:_?NumericQ]:=Denominators[Values[as],Alternatives@@Keys[as],_?(FreeQ[#,pat]&)|excl]


PolesPosition::usage="PolesPosition[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] tries to determine all singular points of the matrix \!\(\*
StyleBox[\"m\", \"TI\"]\).";


PolesPosition[m_List,x_Symbol]:=Module[{xf,t,mr},
xf=x/.#&/@Union@Flatten[Solve[#==0,x]&/@Denominators[{m},x]];
mr=Factor[m/t^2/.x->1/t];
If[Quiet[Check[mr/.t->0;False,True,Power::infy]],Sort[Append[xf,\[Infinity]]],Sort[xf]]
]


PolesPosition[ds_Association,x_Symbol]:=PolesPosition[ds[x],x]
PolesPosition[ds_?DSystemQ,x_Symbol]:=PolesPosition[ds[x],x]


PoincareRank::usage="PoincareRank[\!\(\*
StyleBox[\"m\", \"TI\"]\),{\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)}] gives the Poincare rank \!\(\*
StyleBox[\"r\", \"TI\"]\) of the singular point \!\(\*
StyleBox[\"x\", \"TI\"]\)=\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\) of \!\(\*
StyleBox[\"m\", \"TI\"]\). When \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(0\)]\)\[NotEqual]\[Infinity] the Poincare rank is the pole order minus 1 (by convention, we put \!\(\*
StyleBox[\"r\", \"TI\"]\)=-1 for regular point). For \!\(\*SubscriptBox[\(x\), \(0\)]\)=\[Infinity] the Poincare rank is 1 minus the leading series order.";


PoincareRank[m_,{x_Symbol,x0_}]:=Max[-1,2*Boole[x0===\[Infinity]]-1-LeadingOrder[m,{x,x0}]]


PoincareRank[ds_Association,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]
PoincareRank[ds_?DSystemQ,{x_Symbol,x0_}]:=PoincareRank[ds[x],{x,x0}]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


PolesInfo[ds_Association]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]
PolesInfo[ds_?DSystemQ]:=(#->PolesInfo[ds[#],#])&/@Keys[ds]


PolesInfo::usage="PolesInfo[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of pairs {\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(i\)]\) is the position of the pole, and \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\) is its Poincare rank.";


PolesInfo[m_,x_Symbol]:=Module[{xs,n},
xs=PolesPosition[m,x];
{#,PoincareRank[m,{x,#}]}&/@xs
]


PolesInfo[ds_Association,x_Symbol]:=PolesInfo[ds[x],x]
PolesInfo[ds_?DSystemQ,x_Symbol]:=PolesInfo[ds[x],x]


DenominatorsInfo::usage="DenominatorsInfo[\!\(\*
StyleBox[\"m\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives a list of pairs {\!\(\*SubscriptBox[
StyleBox[\"d\", \"TI\"], \(i\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"d\", \"TI\"], \(i\)]\) are irreducible denominators and \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(i\)]\) are their Poincare ranks. The last entry is special: {\!\(\*SuperscriptBox[
StyleBox[\"x\", \"TI\"], \(-1\)]\),\!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(\[Infinity]\)]\)}, where \!\(\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \(\[Infinity]\)]\) is the Poincare rank at infinity.";


DenominatorsInfo[m_,x_]:=Module[{dens=Denominators[m,x]},Append[{#,-1-PolyLeadingOrder[m,#,x]}&/@dens,{1/x,PoincareRank[m,{x,\[Infinity]}]}]]


DenominatorsInfo[ds_Association,x_Symbol]:=DenominatorsInfo[ds[x],x]
DenominatorsInfo[ds_?DSystemQ,x_Symbol]:=DenominatorsInfo[ds[x],x]


FactorPlus::usage="FactorPlus[expr] factors expr iff it has head \"Plus\"";


SetAttributes[FactorPlus,Listable];


FactorPlus[expr_Plus]:=Factor[expr];
FactorPlus[expr_]:=expr;


FactorListPlus::usage="FactorListPlus[expr] factors expr iff it has head \"Plus\" and gives a list of the factors, together with their exponents.";


FactorListPlus[expr_Plus]:=FactorList[expr];
FactorListPlus[expr_]:=Factors[expr];


Factors::usage="Factors[expr] returns the list of expr factors not trying to factorize it.";


Factors[expr_]:=Replace[Replace[{expr},Times->Sequence,{2},Heads->True],{x_^n_Integer:>{x,n},x_:>{x,1}},{1}]


ker[m_?MatrixQ]:=Module[{cs,l=Length@First@m (*# of cols*),cs1,eqs,sol},
cs=Table[Unique["c"],{l}];
eqs=Dot[m,cs];
sol=GaussSolve[eqs,cs];(*always should be a solution*)
cs1=Complement[cs,First/@sol];
If[cs1==={},
Return[{0&/@cs}],
Return[Transpose@Outer[Coefficient,cs/.sol,cs1]]
]
]


im=ker@*ker@*Transpose;


bjf::usage="bjf[\!\(\*
StyleBox[\"A\", \"TI\"]\),\!\(\*
StyleBox[\"B\", \"TI\"]\),\!\(\*
StyleBox[\"k\", \"TI\"]\)] constructs block matrix of the form ({
 {A, B, 0},
 {0, A, B},
 {0, 0, A}
}) where \!\(\*
StyleBox[\"A\", \"TI\"]\) is repeated \!\(\*
StyleBox[\"k\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)times. In particular, blockMatrix[\[Lambda],1,\!\(\*
StyleBox[\"k\", \"TI\"]\)] gives \!\(\*
StyleBox[\"k\", \"TI\"]\)*\!\(\*
StyleBox[\"k\", \"TI\"]\) Jordan cell.";
bjf[a_,b_,k_Integer]:=Module[{ap,bp},ArrayFlatten[IdentityMatrix[k]*ap+Rest[Transpose[IdentityMatrix[{k,k+1}]]]*bp/.{ap->a,bp->b}]];


End[];


EndPackage[]


If[($LibraUseFermat=MemberQ[$ContextPath,"Fermatica`"]),Print["Prepared to use Fermatica for matrix operations!"]];


If[NameQ["Global`$LibraTODO"]&&Symbol["Global`$LibraTODO"],CellPrint[Cell["todo:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@Libra`Private`todolist;
CellPrint[Cell["done:", "Print", CellFrame->{{0, 0}, {0, 1}}]];
Print[Style["\[Checkmark] "<>#,{"Text",Small}]]&/@Libra`Private`donelist];
